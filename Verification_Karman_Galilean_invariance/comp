# 1 ".qccX6CNeI/karman_GI.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 ".qccX6CNeI/karman_GI.c"
# 1 "karman_GI-cpp.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "karman_GI-cpp.c"
# 1 "/Users/weugene/basilisk/src/common.h"
# 1 "/usr/include/stdlib.h" 1 3 4
# 61 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/Availability.h" 1 3 4
# 206 "/usr/include/Availability.h" 3 4
# 1 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/AvailabilityInternal.h" 1 3 4
# 207 "/usr/include/Availability.h" 2 3 4
# 62 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/_types.h" 1 3 4
# 27 "/usr/include/_types.h" 3 4
# 1 "/usr/include/sys/_types.h" 1 3 4
# 32 "/usr/include/sys/_types.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 587 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 588 "/usr/include/sys/cdefs.h" 2 3 4
# 653 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/sys/_posix_availability.h" 1 3 4
# 654 "/usr/include/sys/cdefs.h" 2 3 4
# 33 "/usr/include/sys/_types.h" 2 3 4
# 1 "/usr/include/machine/_types.h" 1 3 4
# 32 "/usr/include/machine/_types.h" 3 4
# 1 "/usr/include/i386/_types.h" 1 3 4
# 37 "/usr/include/i386/_types.h" 3 4

# 37 "/usr/include/i386/_types.h" 3 4
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/usr/include/i386/_types.h" 3 4
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef long int __darwin_ptrdiff_t;







typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 33 "/usr/include/machine/_types.h" 2 3 4
# 34 "/usr/include/sys/_types.h" 2 3 4
# 55 "/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];

# 1 "/usr/include/sys/_pthread/_pthread_types.h" 1 3 4
# 57 "/usr/include/sys/_pthread/_pthread_types.h" 3 4
struct __darwin_pthread_handler_rec {
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};

struct _opaque_pthread_attr_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_cond_t {
 long __sig;
 char __opaque[40];
};

struct _opaque_pthread_condattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_mutex_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_mutexattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_once_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_rwlock_t {
 long __sig;
 char __opaque[192];
};

struct _opaque_pthread_rwlockattr_t {
 long __sig;
 char __opaque[16];
};

struct _opaque_pthread_t {
 long __sig;
 struct __darwin_pthread_handler_rec *__cleanup_stack;
 char __opaque[8176];
};

typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
# 81 "/usr/include/sys/_types.h" 2 3 4
# 28 "/usr/include/_types.h" 2 3 4
# 40 "/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 64 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/include/sys/wait.h" 1 3 4
# 79 "/usr/include/sys/wait.h" 3 4
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;





# 1 "/usr/include/sys/_types/_pid_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_pid_t.h" 3 4
typedef __darwin_pid_t pid_t;
# 90 "/usr/include/sys/wait.h" 2 3 4
# 1 "/usr/include/sys/_types/_id_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_id_t.h" 3 4
typedef __darwin_id_t id_t;
# 91 "/usr/include/sys/wait.h" 2 3 4
# 109 "/usr/include/sys/wait.h" 3 4
# 1 "/usr/include/sys/signal.h" 1 3 4
# 73 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/sys/appleapiopts.h" 1 3 4
# 74 "/usr/include/sys/signal.h" 2 3 4
# 82 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/machine/signal.h" 1 3 4
# 32 "/usr/include/machine/signal.h" 3 4
# 1 "/usr/include/i386/signal.h" 1 3 4
# 39 "/usr/include/i386/signal.h" 3 4
typedef int sig_atomic_t;
# 33 "/usr/include/machine/signal.h" 2 3 4
# 83 "/usr/include/sys/signal.h" 2 3 4
# 146 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/machine/_mcontext.h" 1 3 4
# 29 "/usr/include/machine/_mcontext.h" 3 4
# 1 "/usr/include/i386/_mcontext.h" 1 3 4
# 34 "/usr/include/i386/_mcontext.h" 3 4
# 1 "/usr/include/mach/machine/_structs.h" 1 3 4
# 33 "/usr/include/mach/machine/_structs.h" 3 4
# 1 "/usr/include/mach/i386/_structs.h" 1 3 4
# 36 "/usr/include/mach/i386/_structs.h" 3 4
# 1 "/usr/include/machine/types.h" 1 3 4
# 35 "/usr/include/machine/types.h" 3 4
# 1 "/usr/include/i386/types.h" 1 3 4
# 76 "/usr/include/i386/types.h" 3 4
# 1 "/usr/include/sys/_types/_int8_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int8_t.h" 3 4
typedef signed char int8_t;
# 77 "/usr/include/i386/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_int16_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int16_t.h" 3 4
typedef short int16_t;
# 78 "/usr/include/i386/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_int32_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int32_t.h" 3 4
typedef int int32_t;
# 79 "/usr/include/i386/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_int64_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_int64_t.h" 3 4
typedef long long int64_t;
# 80 "/usr/include/i386/types.h" 2 3 4

# 1 "/usr/include/sys/_types/_u_int8_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_u_int8_t.h" 3 4
typedef unsigned char u_int8_t;
# 82 "/usr/include/i386/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_u_int16_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_u_int16_t.h" 3 4
typedef unsigned short u_int16_t;
# 83 "/usr/include/i386/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_u_int32_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_u_int32_t.h" 3 4
typedef unsigned int u_int32_t;
# 84 "/usr/include/i386/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_u_int64_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_u_int64_t.h" 3 4
typedef unsigned long long u_int64_t;
# 85 "/usr/include/i386/types.h" 2 3 4


typedef int64_t register_t;




# 1 "/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_intptr_t.h" 3 4
# 1 "/usr/include/machine/types.h" 1 3 4
# 31 "/usr/include/sys/_types/_intptr_t.h" 2 3 4

typedef __darwin_intptr_t intptr_t;
# 93 "/usr/include/i386/types.h" 2 3 4
# 1 "/usr/include/sys/_types/_uintptr_t.h" 1 3 4
# 30 "/usr/include/sys/_types/_uintptr_t.h" 3 4
typedef unsigned long uintptr_t;
# 94 "/usr/include/i386/types.h" 2 3 4
# 111 "/usr/include/i386/types.h" 3 4
typedef u_int64_t syscall_arg_t;
# 36 "/usr/include/machine/types.h" 2 3 4
# 37 "/usr/include/mach/i386/_structs.h" 2 3 4
# 46 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
# 92 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,





    __rc :2,






             :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 150 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 194 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
# 213 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
# 229 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_ymm_reg
{
 char __ymm_reg[32];
};
# 245 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_zmm_reg
{
 char __zmm_reg[64];
};
# 259 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_opmask_reg
{
 char __opmask_reg[8];
};
# 281 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};


struct __darwin_i386_avx_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
};


struct __darwin_i386_avx512_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_opmask_reg __fpu_k0;
 struct __darwin_opmask_reg __fpu_k1;
 struct __darwin_opmask_reg __fpu_k2;
 struct __darwin_opmask_reg __fpu_k3;
 struct __darwin_opmask_reg __fpu_k4;
 struct __darwin_opmask_reg __fpu_k5;
 struct __darwin_opmask_reg __fpu_k6;
 struct __darwin_opmask_reg __fpu_k7;
 struct __darwin_ymm_reg __fpu_zmmh0;
 struct __darwin_ymm_reg __fpu_zmmh1;
 struct __darwin_ymm_reg __fpu_zmmh2;
 struct __darwin_ymm_reg __fpu_zmmh3;
 struct __darwin_ymm_reg __fpu_zmmh4;
 struct __darwin_ymm_reg __fpu_zmmh5;
 struct __darwin_ymm_reg __fpu_zmmh6;
 struct __darwin_ymm_reg __fpu_zmmh7;
};
# 575 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_exception_state
{
 __uint16_t __trapno;
 __uint16_t __cpu;
 __uint32_t __err;
 __uint32_t __faultvaddr;
};
# 595 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};
# 627 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
# 682 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};


struct __darwin_x86_avx_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
};


struct __darwin_x86_avx512_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
 struct __darwin_opmask_reg __fpu_k0;
 struct __darwin_opmask_reg __fpu_k1;
 struct __darwin_opmask_reg __fpu_k2;
 struct __darwin_opmask_reg __fpu_k3;
 struct __darwin_opmask_reg __fpu_k4;
 struct __darwin_opmask_reg __fpu_k5;
 struct __darwin_opmask_reg __fpu_k6;
 struct __darwin_opmask_reg __fpu_k7;
 struct __darwin_ymm_reg __fpu_zmmh0;
 struct __darwin_ymm_reg __fpu_zmmh1;
 struct __darwin_ymm_reg __fpu_zmmh2;
 struct __darwin_ymm_reg __fpu_zmmh3;
 struct __darwin_ymm_reg __fpu_zmmh4;
 struct __darwin_ymm_reg __fpu_zmmh5;
 struct __darwin_ymm_reg __fpu_zmmh6;
 struct __darwin_ymm_reg __fpu_zmmh7;
 struct __darwin_ymm_reg __fpu_zmmh8;
 struct __darwin_ymm_reg __fpu_zmmh9;
 struct __darwin_ymm_reg __fpu_zmmh10;
 struct __darwin_ymm_reg __fpu_zmmh11;
 struct __darwin_ymm_reg __fpu_zmmh12;
 struct __darwin_ymm_reg __fpu_zmmh13;
 struct __darwin_ymm_reg __fpu_zmmh14;
 struct __darwin_ymm_reg __fpu_zmmh15;
 struct __darwin_zmm_reg __fpu_zmm16;
 struct __darwin_zmm_reg __fpu_zmm17;
 struct __darwin_zmm_reg __fpu_zmm18;
 struct __darwin_zmm_reg __fpu_zmm19;
 struct __darwin_zmm_reg __fpu_zmm20;
 struct __darwin_zmm_reg __fpu_zmm21;
 struct __darwin_zmm_reg __fpu_zmm22;
 struct __darwin_zmm_reg __fpu_zmm23;
 struct __darwin_zmm_reg __fpu_zmm24;
 struct __darwin_zmm_reg __fpu_zmm25;
 struct __darwin_zmm_reg __fpu_zmm26;
 struct __darwin_zmm_reg __fpu_zmm27;
 struct __darwin_zmm_reg __fpu_zmm28;
 struct __darwin_zmm_reg __fpu_zmm29;
 struct __darwin_zmm_reg __fpu_zmm30;
 struct __darwin_zmm_reg __fpu_zmm31;
};
# 1140 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_exception_state64
{
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
# 1160 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
# 1188 "/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_cpmu_state64
{
 __uint64_t __ctrs[16];
};
# 34 "/usr/include/mach/machine/_structs.h" 2 3 4
# 35 "/usr/include/i386/_mcontext.h" 2 3 4




struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};


struct __darwin_mcontext_avx32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx_state __fs;
};



struct __darwin_mcontext_avx512_32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx512_state __fs;
};
# 97 "/usr/include/i386/_mcontext.h" 3 4
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};


struct __darwin_mcontext_avx64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};



struct __darwin_mcontext_avx512_64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx512_state64 __fs;
};
# 156 "/usr/include/i386/_mcontext.h" 3 4
typedef struct __darwin_mcontext64 *mcontext_t;
# 30 "/usr/include/machine/_mcontext.h" 2 3 4
# 147 "/usr/include/sys/signal.h" 2 3 4

# 1 "/usr/include/sys/_pthread/_pthread_attr_t.h" 1 3 4
# 31 "/usr/include/sys/_pthread/_pthread_attr_t.h" 3 4
typedef __darwin_pthread_attr_t pthread_attr_t;
# 149 "/usr/include/sys/signal.h" 2 3 4

# 1 "/usr/include/sys/_types/_sigaltstack.h" 1 3 4
# 42 "/usr/include/sys/_types/_sigaltstack.h" 3 4
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
# 151 "/usr/include/sys/signal.h" 2 3 4
# 1 "/usr/include/sys/_types/_ucontext.h" 1 3 4
# 39 "/usr/include/sys/_types/_ucontext.h" 3 4
# 1 "/usr/include/machine/_mcontext.h" 1 3 4
# 40 "/usr/include/sys/_types/_ucontext.h" 2 3 4


struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;

 struct __darwin_mcontext64 __mcontext_data;

};


typedef struct __darwin_ucontext ucontext_t;
# 152 "/usr/include/sys/signal.h" 2 3 4


# 1 "/usr/include/sys/_types/_sigset_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_sigset_t.h" 3 4
typedef __darwin_sigset_t sigset_t;
# 155 "/usr/include/sys/signal.h" 2 3 4
# 1 "/usr/include/sys/_types/_size_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_size_t.h" 3 4
typedef __darwin_size_t size_t;
# 156 "/usr/include/sys/signal.h" 2 3 4
# 1 "/usr/include/sys/_types/_uid_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_uid_t.h" 3 4
typedef __darwin_uid_t uid_t;
# 157 "/usr/include/sys/signal.h" 2 3 4

union sigval {

 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 269 "/usr/include/sys/signal.h" 3 4
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
         void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
# 367 "/usr/include/sys/signal.h" 3 4
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
# 389 "/usr/include/sys/signal.h" 3 4

void (*signal(int, void (*)(int)))(int);

# 110 "/usr/include/sys/wait.h" 2 3 4
# 1 "/usr/include/sys/resource.h" 1 3 4
# 80 "/usr/include/sys/resource.h" 3 4
# 1 "/usr/include/sys/_types/_timeval.h" 1 3 4
# 34 "/usr/include/sys/_types/_timeval.h" 3 4
struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 81 "/usr/include/sys/resource.h" 2 3 4
# 89 "/usr/include/sys/resource.h" 3 4
typedef __uint64_t rlim_t;
# 152 "/usr/include/sys/resource.h" 3 4
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;

 long ru_opaque[14];
# 180 "/usr/include/sys/resource.h" 3 4
};
# 365 "/usr/include/sys/resource.h" 3 4
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
# 424 "/usr/include/sys/resource.h" 3 4

int getpriority(int, id_t);



int getrlimit(int, struct rlimit *) __asm("_" "getrlimit" );
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);



int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit" );

# 111 "/usr/include/sys/wait.h" 2 3 4
# 247 "/usr/include/sys/wait.h" 3 4

pid_t wait(int *) __asm("_" "wait" );
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid" );

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid" );






# 66 "/usr/include/stdlib.h" 2 3 4
# 80 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 34 "/usr/include/sys/_types/_wchar_t.h" 3 4
typedef __darwin_wchar_t wchar_t;
# 81 "/usr/include/stdlib.h" 2 3 4

typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;


# 1 "/usr/include/sys/_types/_null.h" 1 3 4
# 100 "/usr/include/stdlib.h" 2 3 4
# 117 "/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
# 135 "/usr/include/stdlib.h" 3 4

void abort(void) __attribute__((noreturn));
int abs(int) __attribute__((const));
int atexit(void (* )(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *__key, const void *__base, size_t __nel,
     size_t __width, int (* __compar)(const void *, const void *));
void *calloc(size_t __count, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1,2)));
div_t div(int, int) __attribute__((const));
void exit(int) __attribute__((noreturn));
void free(void *);
char *getenv(const char *);
long labs(long) __attribute__((const));
ldiv_t ldiv(long, long) __attribute__((const));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);

void *malloc(size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1)));
int mblen(const char *__s, size_t __n);
size_t mbstowcs(wchar_t * restrict , const char * restrict, size_t);
int mbtowc(wchar_t * restrict, const char * restrict, size_t);
int posix_memalign(void **__memptr, size_t __alignment, size_t __size) ;
void qsort(void *__base, size_t __nel, size_t __width,
     int (* __compar)(const void *, const void *));
int rand(void) ;
void *realloc(void *__ptr, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));
void srand(unsigned) ;
double strtod(const char *, char **) __asm("_" "strtod" );
float strtof(const char *, char **) __asm("_" "strtof" );
long strtol(const char *__str, char **__endptr, int __base);
long double
  strtold(const char *, char **);

long long
  strtoll(const char *__str, char **__endptr, int __base);

unsigned long
  strtoul(const char *__str, char **__endptr, int __base);

unsigned long long
  strtoull(const char *__str, char **__endptr, int __base);
# 192 "/usr/include/stdlib.h" 3 4



int system(const char *) __asm("_" "system" );



size_t wcstombs(char * restrict, const wchar_t * restrict, size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((noreturn));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *restrict, int *restrict);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *restrict, int *restrict);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);



long jrand48(unsigned short[3]) ;
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void) ;
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void) ;
long nrand48(unsigned short[3]) ;
int posix_openpt(int);
char *ptsname(int);





int putenv(char *) __asm("_" "putenv" );
long random(void) ;
int rand_r(unsigned *) ;



char *realpath(const char * restrict, char * restrict) __asm("_" "realpath" );

unsigned short
 *seed48(unsigned short[3]);
int setenv(const char * __name, const char * __value, int __overwrite) __asm("_" "setenv" );

void setkey(const char *) __asm("_" "setkey" );



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv" );
# 354 "/usr/include/stdlib.h" 3 4

# 2 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 1 3 4
# 14 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 3 4
# 1 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include/stdarg.h" 1 3 4
# 40 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 15 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 2 3 4
# 78 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 3 4
# 1 "/usr/include/_stdio.h" 1 3 4
# 75 "/usr/include/_stdio.h" 3 4
# 1 "/usr/include/sys/_types/_va_list.h" 1 3 4
# 32 "/usr/include/sys/_types/_va_list.h" 3 4
typedef __darwin_va_list va_list;
# 76 "/usr/include/_stdio.h" 2 3 4



# 1 "/usr/include/sys/stdio.h" 1 3 4
# 37 "/usr/include/sys/stdio.h" 3 4


int renameat(int, const char *, int, const char *) ;
# 51 "/usr/include/sys/stdio.h" 3 4

# 80 "/usr/include/_stdio.h" 2 3 4

typedef __darwin_off_t fpos_t;
# 92 "/usr/include/_stdio.h" 3 4
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
# 126 "/usr/include/_stdio.h" 3 4
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (* _close)(void *);
 int (* _read) (void *, char *, int);
 fpos_t (* _seek) (void *, fpos_t, int);
 int (* _write)(void *, const char *, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;
# 79 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 2 3 4


extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;

# 155 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 3 4

void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * restrict, fpos_t *);
char *fgets(char * restrict, int, FILE *);



FILE *fopen(const char * restrict __filename, const char * restrict __mode) __asm("_" "fopen" );

int fprintf(FILE * restrict, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * restrict, FILE * restrict) __asm("_" "fputs" );
size_t fread(void * restrict __ptr, size_t __size, size_t __nitems, FILE * restrict __stream);
FILE *freopen(const char * restrict, const char * restrict,
                 FILE * restrict) __asm("_" "freopen" );
int fscanf(FILE * restrict, const char * restrict, ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * restrict __ptr, size_t __size, size_t __nitems, FILE * restrict __stream) __asm("_" "fwrite" );
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *);
int printf(const char * restrict, ...) __attribute__((__format__ (__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *__old, const char *__new);
void rewind(FILE *);
int scanf(const char * restrict, ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * restrict, char * restrict);
int setvbuf(FILE * restrict, char * restrict, int, size_t);
int sprintf(char * restrict, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3))) ;
int sscanf(const char * restrict, const char * restrict, ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);





char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * restrict, const char * restrict, __gnuc_va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * restrict, __gnuc_va_list) __attribute__((__format__ (__printf__, 1, 0)));
int vsprintf(char * restrict, const char * restrict, __gnuc_va_list) __attribute__((__format__ (__printf__, 2, 0))) ;

# 218 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 3 4




char *ctermid(char *);





FILE *fdopen(int, const char *) __asm("_" "fdopen" );

int fileno(FILE *);

# 245 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 3 4

int pclose(FILE *) ;



FILE *popen(const char *, const char *) __asm("_" "popen" ) ;


# 266 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 3 4

int __srget(FILE *);
int __svfscanf(FILE *, const char *, __gnuc_va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);








extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 303 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 3 4

void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);











char *tempnam(const char *__dir, const char *__prefix) __asm("_" "tempnam" );

# 342 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 3 4
# 1 "/usr/include/sys/_types/_off_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_off_t.h" 3 4
typedef __darwin_off_t off_t;
# 343 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 2 3 4


int fseeko(FILE * __stream, off_t __offset, int __whence);
off_t ftello(FILE * __stream);





int snprintf(char * restrict __str, size_t __size, const char * restrict __format, ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * restrict __stream, const char * restrict __format, __gnuc_va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * restrict __format, __gnuc_va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * restrict __str, size_t __size, const char * restrict __format, __gnuc_va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * restrict __str, const char * restrict __format, __gnuc_va_list) __attribute__((__format__ (__scanf__, 2, 0)));

# 367 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 3 4
# 1 "/usr/include/sys/_types/_ssize_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_ssize_t.h" 3 4
typedef __darwin_ssize_t ssize_t;
# 368 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 2 3 4


int dprintf(int, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3))) ;
int vdprintf(int, const char * restrict, __gnuc_va_list) __attribute__((__format__ (__printf__, 2, 0))) ;
ssize_t getdelim(char ** restrict __linep, size_t * restrict __linecapp, int __delimiter, FILE * restrict __stream) ;
ssize_t getline(char ** restrict __linep, size_t * restrict __linecapp, FILE * restrict __stream) ;
FILE *fmemopen(void * restrict __buf, size_t __size, const char * restrict __mode) ;
FILE *open_memstream(char **__bufp, size_t *__sizep) ;

# 425 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 3 4
# 1 "/usr/include/secure/_stdio.h" 1 3 4
# 31 "/usr/include/secure/_stdio.h" 3 4
# 1 "/usr/include/secure/_common.h" 1 3 4
# 32 "/usr/include/secure/_stdio.h" 2 3 4
# 42 "/usr/include/secure/_stdio.h" 3 4
extern int __sprintf_chk (char * restrict, int, size_t,
     const char * restrict, ...);
# 52 "/usr/include/secure/_stdio.h" 3 4
extern int __snprintf_chk (char * restrict, size_t, int, size_t,
      const char * restrict, ...);







extern int __vsprintf_chk (char * restrict, int, size_t,
      const char * restrict, va_list);







extern int __vsnprintf_chk (char * restrict, size_t, int, size_t,
       const char * restrict, va_list);
# 426 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdio.h" 2 3 4
# 3 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include/stddef.h" 1 3 4
# 143 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 4 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include/stdbool.h" 1 3 4
# 5 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include/stdarg.h" 1 3 4
# 99 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 6 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 69 "/usr/include/string.h" 3 4

void *memchr(const void *__s, int __c, size_t __n);
int memcmp(const void *__s1, const void *__s2, size_t __n);
void *memcpy(void *__dst, const void *__src, size_t __n);
void *memmove(void *__dst, const void *__src, size_t __len);
void *memset(void *__b, int __c, size_t __len);
char *strcat(char *__s1, const char *__s2);
char *strchr(const char *__s, int __c);
int strcmp(const char *__s1, const char *__s2);
int strcoll(const char *__s1, const char *__s2);
char *strcpy(char *__dst, const char *__src);
size_t strcspn(const char *__s, const char *__charset);
char *strerror(int __errnum) __asm("_" "strerror" );
size_t strlen(const char *__s);
char *strncat(char *__s1, const char *__s2, size_t __n);
int strncmp(const char *__s1, const char *__s2, size_t __n);
char *strncpy(char *__dst, const char *__src, size_t __n);
char *strpbrk(const char *__s, const char *__charset);
char *strrchr(const char *__s, int __c);
size_t strspn(const char *__s, const char *__charset);
char *strstr(const char *__big, const char *__little);
char *strtok(char *__str, const char *__sep);
size_t strxfrm(char *__s1, const char *__s2, size_t __n);

# 103 "/usr/include/string.h" 3 4

char *strtok_r(char *__str, const char *__sep, char **__lasts);

# 115 "/usr/include/string.h" 3 4

int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen);
char *strdup(const char *__s1);
void *memccpy(void *__dst, const void *__src, int __c, size_t __n);

# 129 "/usr/include/string.h" 3 4

char *stpcpy(char *__dst, const char *__src);
char *stpncpy(char *__dst, const char *__src, size_t __n) ;
char *strndup(const char *__s1, size_t __n) ;
size_t strnlen(const char *__s1, size_t __n) ;
char *strsignal(int __sig);

# 190 "/usr/include/string.h" 3 4
# 1 "/usr/include/secure/_string.h" 1 3 4
# 191 "/usr/include/string.h" 2 3 4
# 7 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include/float.h" 1 3 4
# 8 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/limits.h" 1 3 4
# 34 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/limits.h" 3 4
# 1 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/limits.h" 1 3 4
# 194 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 64 "/usr/include/limits.h" 3 4
# 1 "/usr/include/machine/limits.h" 1 3 4





# 1 "/usr/include/i386/limits.h" 1 3 4
# 40 "/usr/include/i386/limits.h" 3 4
# 1 "/usr/include/i386/_limits.h" 1 3 4
# 41 "/usr/include/i386/limits.h" 2 3 4
# 7 "/usr/include/machine/limits.h" 2 3 4
# 65 "/usr/include/limits.h" 2 3 4
# 1 "/usr/include/sys/syslimits.h" 1 3 4
# 66 "/usr/include/limits.h" 2 3 4
# 195 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/limits.h" 2 3 4
# 8 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/limits.h" 2 3 4
# 9 "/Users/weugene/basilisk/src/common.h" 2

# 1 "/usr/include/assert.h" 1 3 4
# 75 "/usr/include/assert.h" 3 4

void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn)) ;




# 11 "/Users/weugene/basilisk/src/common.h" 2

# 1 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/math.h" 1 3 4
# 48 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/math.h" 3 4

# 59 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/math.h" 3 4
    typedef float float_t;
    typedef double double_t;
# 126 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/math.h" 3 4
extern int __math_errhandling(void);
# 159 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/math.h" 3 4
extern int __fpclassifyf(float);
extern int __fpclassifyd(double);
extern int __fpclassifyl(long double);
# 203 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/math.h" 3 4
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isfinitef(float);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isfinited(double);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isfinitel(long double);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isinff(float);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isinfd(double);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isinfl(long double);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isnanf(float);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isnand(double);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isnanl(long double);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isnormalf(float);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isnormald(double);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isnormall(long double);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_signbitf(float);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_signbitd(double);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_signbitl(long double);

extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isfinitef(float __x) {
    return __x == __x && __builtin_fabsf(__x) != __builtin_inff();
}
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isfinited(double __x) {
    return __x == __x && __builtin_fabs(__x) != __builtin_inf();
}
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isfinitel(long double __x) {
    return __x == __x && __builtin_fabsl(__x) != __builtin_infl();
}
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isinff(float __x) {
    return __builtin_fabsf(__x) == __builtin_inff();
}
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isinfd(double __x) {
    return __builtin_fabs(__x) == __builtin_inf();
}
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isinfl(long double __x) {
    return __builtin_fabsl(__x) == __builtin_infl();
}
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isnanf(float __x) {
    return __x != __x;
}
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isnand(double __x) {
    return __x != __x;
}
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isnanl(long double __x) {
    return __x != __x;
}
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_signbitf(float __x) {
    union { float __f; unsigned int __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 31);
}
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_signbitd(double __x) {
    union { double __f; unsigned long long __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 63);
}

extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_signbitl(long double __x) {
    union {
        long double __ld;
        struct{ unsigned long long __m; unsigned short __sexp; } __p;
    } __u;
    __u.__ld = __x;
    return (int)(__u.__p.__sexp >> 15);
}







extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isnormalf(float __x) {
    return __inline_isfinitef(__x) && __builtin_fabsf(__x) >= 1.17549435082228750796873653722224568e-38F;
}
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isnormald(double __x) {
    return __inline_isfinited(__x) && __builtin_fabs(__x) >= ((double)2.22507385850720138309023271733240406e-308L);
}
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __inline_isnormall(long double __x) {
    return __inline_isfinitel(__x) && __builtin_fabsl(__x) >= 3.36210314311209350626267781732175260e-4932L;
}
# 337 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/math.h" 3 4
extern float acosf(float);
extern double acos(double);
extern long double acosl(long double);

extern float asinf(float);
extern double asin(double);
extern long double asinl(long double);

extern float atanf(float);
extern double atan(double);
extern long double atanl(long double);

extern float atan2f(float, float);
extern double atan2(double, double);
extern long double atan2l(long double, long double);

extern float cosf(float);
extern double cos(double);
extern long double cosl(long double);

extern float sinf(float);
extern double sin(double);
extern long double sinl(long double);

extern float tanf(float);
extern double tan(double);
extern long double tanl(long double);

extern float acoshf(float);
extern double acosh(double);
extern long double acoshl(long double);

extern float asinhf(float);
extern double asinh(double);
extern long double asinhl(long double);

extern float atanhf(float);
extern double atanh(double);
extern long double atanhl(long double);

extern float coshf(float);
extern double cosh(double);
extern long double coshl(long double);

extern float sinhf(float);
extern double sinh(double);
extern long double sinhl(long double);

extern float tanhf(float);
extern double tanh(double);
extern long double tanhl(long double);

extern float expf(float);
extern double exp(double);
extern long double expl(long double);

extern float exp2f(float);
extern double exp2(double);
extern long double exp2l(long double);

extern float expm1f(float);
extern double expm1(double);
extern long double expm1l(long double);

extern float logf(float);
extern double log(double);
extern long double logl(long double);

extern float log10f(float);
extern double log10(double);
extern long double log10l(long double);

extern float log2f(float);
extern double log2(double);
extern long double log2l(long double);

extern float log1pf(float);
extern double log1p(double);
extern long double log1pl(long double);

extern float logbf(float);
extern double logb(double);
extern long double logbl(long double);

extern float modff(float, float *);
extern double modf(double, double *);
extern long double modfl(long double, long double *);

extern float ldexpf(float, int);
extern double ldexp(double, int);
extern long double ldexpl(long double, int);

extern float frexpf(float, int *);
extern double frexp(double, int *);
extern long double frexpl(long double, int *);

extern int ilogbf(float);
extern int ilogb(double);
extern int ilogbl(long double);

extern float scalbnf(float, int);
extern double scalbn(double, int);
extern long double scalbnl(long double, int);

extern float scalblnf(float, long int);
extern double scalbln(double, long int);
extern long double scalblnl(long double, long int);

extern float fabsf(float);
extern double fabs(double);
extern long double fabsl(long double);

extern float cbrtf(float);
extern double cbrt(double);
extern long double cbrtl(long double);

extern float hypotf(float, float);
extern double hypot(double, double);
extern long double hypotl(long double, long double);

extern float powf(float, float);
extern double pow(double, double);
extern long double powl(long double, long double);

extern float sqrtf(float);
extern double sqrt(double);
extern long double sqrtl(long double);

extern float erff(float);
extern double erf(double);
extern long double erfl(long double);

extern float erfcf(float);
extern double erfc(double);
extern long double erfcl(long double);




extern float lgammaf(float);
extern double lgamma(double);
extern long double lgammal(long double);

extern float tgammaf(float);
extern double tgamma(double);
extern long double tgammal(long double);

extern float ceilf(float);
extern double ceil(double);
extern long double ceill(long double);

extern float floorf(float);
extern double floor(double);
extern long double floorl(long double);

extern float nearbyintf(float);
extern double nearbyint(double);
extern long double nearbyintl(long double);

extern float rintf(float);
extern double rint(double);
extern long double rintl(long double);

extern long int lrintf(float);
extern long int lrint(double);
extern long int lrintl(long double);

extern float roundf(float);
extern double round(double);
extern long double roundl(long double);

extern long int lroundf(float);
extern long int lround(double);
extern long int lroundl(long double);




extern long long int llrintf(float);
extern long long int llrint(double);
extern long long int llrintl(long double);

extern long long int llroundf(float);
extern long long int llround(double);
extern long long int llroundl(long double);


extern float truncf(float);
extern double trunc(double);
extern long double truncl(long double);

extern float fmodf(float, float);
extern double fmod(double, double);
extern long double fmodl(long double, long double);

extern float remainderf(float, float);
extern double remainder(double, double);
extern long double remainderl(long double, long double);

extern float remquof(float, float, int *);
extern double remquo(double, double, int *);
extern long double remquol(long double, long double, int *);

extern float copysignf(float, float);
extern double copysign(double, double);
extern long double copysignl(long double, long double);

extern float nanf(const char *);
extern double nan(const char *);
extern long double nanl(const char *);

extern float nextafterf(float, float);
extern double nextafter(double, double);
extern long double nextafterl(long double, long double);

extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);

extern float fdimf(float, float);
extern double fdim(double, double);
extern long double fdiml(long double, long double);

extern float fmaxf(float, float);
extern double fmax(double, double);
extern long double fmaxl(long double, long double);

extern float fminf(float, float);
extern double fmin(double, double);
extern long double fminl(long double, long double);

extern float fmaf(float, float, float);
extern double fma(double, double, double);
extern long double fmal(long double, long double, long double);
# 580 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/math.h" 3 4
extern float __inff(void) __attribute__((deprecated));
extern double __inf(void) __attribute__((deprecated));
extern long double __infl(void) __attribute__((deprecated));

extern float __nan(void) ;
# 612 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/math.h" 3 4
extern float __exp10f(float) ;
extern double __exp10(double) ;





extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp);
# 629 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/math.h" 3 4
extern float __cospif(float) ;
extern double __cospi(double) ;
extern float __sinpif(float) ;
extern double __sinpi(double) ;
extern float __tanpif(float) ;
extern double __tanpi(double) ;
# 660 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/math.h" 3 4
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp);
extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp);






struct __float2 { float __sinval; float __cosval; };
struct __double2 { double __sinval; double __cosval; };

extern struct __float2 __sincosf_stret(float);
extern struct __double2 __sincos_stret(double);
extern struct __float2 __sincospif_stret(float);
extern struct __double2 __sincospi_stret(double);

extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincosf_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincos_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincospif_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincospi_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}







extern double j0(double) ;
extern double j1(double) ;
extern double jn(int, double) ;
extern double y0(double) ;
extern double y1(double) ;
extern double yn(int, double) ;
extern double scalb(double, double);
extern int signgam;
# 791 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/math.h" 3 4

# 13 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/usr/include/time.h" 1 3 4
# 68 "/usr/include/time.h" 3 4
# 1 "/usr/include/sys/_types/_clock_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_clock_t.h" 3 4
typedef __darwin_clock_t clock_t;
# 69 "/usr/include/time.h" 2 3 4


# 1 "/usr/include/sys/_types/_time_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_time_t.h" 3 4
typedef __darwin_time_t time_t;
# 72 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/sys/_types/_timespec.h" 1 3 4
# 33 "/usr/include/sys/_types/_timespec.h" 3 4
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
# 73 "/usr/include/time.h" 2 3 4

struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
# 97 "/usr/include/time.h" 3 4
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone" );

extern int daylight;


char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" );
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" );
size_t strftime(char * restrict, size_t, const char * restrict, const struct tm * restrict) __asm("_" "strftime" );
char *strptime(const char * restrict, const char * restrict, struct tm * restrict) __asm("_" "strptime" );
time_t time(time_t *);


void tzset(void);



char *asctime_r(const struct tm * restrict, char * restrict);
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * restrict, struct tm * restrict);
struct tm *localtime_r(const time_t * restrict, struct tm * restrict);
# 141 "/usr/include/time.h" 3 4
int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) __asm("_" "nanosleep" );
# 152 "/usr/include/time.h" 3 4
typedef enum {
_CLOCK_REALTIME = 0,

_CLOCK_MONOTONIC = 6,
# 167 "/usr/include/time.h" 3 4
_CLOCK_PROCESS_CPUTIME_ID = 12,

_CLOCK_THREAD_CPUTIME_ID = 16

} clockid_t;


int clock_getres(clockid_t __clock_id, struct timespec *__res);


int clock_gettime(clockid_t __clock_id, struct timespec *__tp);








int clock_settime(clockid_t __clock_id, const struct timespec *__tp);






# 14 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/usr/include/sys/time.h" 1 3 4
# 75 "/usr/include/sys/time.h" 3 4
# 1 "/usr/include/sys/_types/_fd_def.h" 1 3 4
# 48 "/usr/include/sys/_types/_fd_def.h" 3 4

typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;



static __inline int
__darwin_fd_isset(int _n, const struct fd_set *_p)
{
 return (_p->fds_bits[(unsigned long)_n/(sizeof(__int32_t) * 8)] & ((__int32_t)(((unsigned long)1)<<((unsigned long)_n % (sizeof(__int32_t) * 8)))));
}
# 76 "/usr/include/sys/time.h" 2 3 4
# 85 "/usr/include/sys/time.h" 3 4
# 1 "/usr/include/sys/_types/_suseconds_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_suseconds_t.h" 3 4
typedef __darwin_suseconds_t suseconds_t;
# 86 "/usr/include/sys/time.h" 2 3 4





struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};
# 110 "/usr/include/sys/time.h" 3 4
# 1 "/usr/include/sys/_types/_fd_setsize.h" 1 3 4
# 111 "/usr/include/sys/time.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_set.h" 1 3 4
# 112 "/usr/include/sys/time.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_clr.h" 1 3 4
# 113 "/usr/include/sys/time.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_isset.h" 1 3 4
# 114 "/usr/include/sys/time.h" 2 3 4
# 1 "/usr/include/sys/_types/_fd_zero.h" 1 3 4
# 115 "/usr/include/sys/time.h" 2 3 4
# 187 "/usr/include/sys/time.h" 3 4

# 196 "/usr/include/sys/time.h" 3 4
int getitimer(int, struct itimerval *);
int gettimeofday(struct timeval * restrict, void * restrict);

# 1 "/usr/include/sys/_select.h" 1 3 4
# 39 "/usr/include/sys/_select.h" 3 4
int select(int, fd_set * restrict, fd_set * restrict,
  fd_set * restrict, struct timeval * restrict)




  __asm("_" "select" "$1050")




  ;
# 200 "/usr/include/sys/time.h" 2 3 4

int setitimer(int, const struct itimerval * restrict,
  struct itimerval * restrict);
int utimes(const char *, const struct timeval *);


# 15 "/Users/weugene/basilisk/src/common.h" 2
# 367 "/Users/weugene/basilisk/src/common.h"

# 367 "/Users/weugene/basilisk/src/common.h"
typedef struct {
  void * p;
  long max, len;
} Array;

Array * array_new()
{
  Array * a = ((Array *) malloc((1)*sizeof(Array)));
  a->p = 
# 375 "/Users/weugene/basilisk/src/common.h" 3 4
        ((void *)0)
# 375 "/Users/weugene/basilisk/src/common.h"
            ;
  a->max = a->len = 0;
  return a;
}

void array_free (Array * a)
{
  free(a->p);
  free(a);
}

void array_append (Array * a, void * elem, size_t size)
{
  if (a->len + size >= a->max) {
    a->max += ((size) > (4096) ? (size) : (4096));
    a->p = realloc(a->p,a->max);
  }
  
# 392 "/Users/weugene/basilisk/src/common.h" 3 4
 __builtin___memcpy_chk (
# 392 "/Users/weugene/basilisk/src/common.h"
 ((char *)a->p) + a->len
# 392 "/Users/weugene/basilisk/src/common.h" 3 4
 , 
# 392 "/Users/weugene/basilisk/src/common.h"
 elem, size
# 392 "/Users/weugene/basilisk/src/common.h" 3 4
 , __builtin_object_size (
# 392 "/Users/weugene/basilisk/src/common.h"
 ((char *)a->p) + a->len
# 392 "/Users/weugene/basilisk/src/common.h" 3 4
 , 0))
# 392 "/Users/weugene/basilisk/src/common.h"
                                             ;
  a->len += size;
}

void * array_shrink (Array * a)
{
  void * p = realloc(a->p,a->len);
  free(a);
  return p;
}
# 794 "/Users/weugene/basilisk/src/common.h"
void init_solver()
{
# 806 "/Users/weugene/basilisk/src/common.h"
}
# 815 "/Users/weugene/basilisk/src/common.h"
double _val_higher_dimension = 0.;
# 815 "/Users/weugene/basilisk/src/common.h"

double undefined;

# 1 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include/stdint.h" 1 3 4
# 9 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include/stdint.h" 3 4
# 1 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdint.h" 1 3 4
# 32 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdint.h" 3 4
# 1 "/usr/include/_types/_uint8_t.h" 1 3 4
# 31 "/usr/include/_types/_uint8_t.h" 3 4

# 31 "/usr/include/_types/_uint8_t.h" 3 4
typedef unsigned char uint8_t;
# 33 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint16_t.h" 1 3 4
# 31 "/usr/include/_types/_uint16_t.h" 3 4
typedef unsigned short uint16_t;
# 34 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint32_t.h" 1 3 4
# 31 "/usr/include/_types/_uint32_t.h" 3 4
typedef unsigned int uint32_t;
# 35 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uint64_t.h" 1 3 4
# 31 "/usr/include/_types/_uint64_t.h" 3 4
typedef unsigned long long uint64_t;
# 36 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdint.h" 2 3 4


typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
# 67 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdint.h" 3 4
# 1 "/usr/include/_types/_intmax_t.h" 1 3 4
# 32 "/usr/include/_types/_intmax_t.h" 3 4
typedef long int intmax_t;
# 68 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdint.h" 2 3 4
# 1 "/usr/include/_types/_uintmax_t.h" 1 3 4
# 32 "/usr/include/_types/_uintmax_t.h" 3 4
typedef long unsigned int uintmax_t;
# 69 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include-fixed/stdint.h" 2 3 4
# 10 "/usr/local/Cellar/gcc/9.2.0_1/lib/gcc/9/gcc/x86_64-apple-darwin17/9.2.0/include/stdint.h" 2 3 4
# 819 "/Users/weugene/basilisk/src/common.h" 2
# 1 "/Users/weugene/basilisk/src/fp_osx.h" 1
# 84 "/Users/weugene/basilisk/src/fp_osx.h"
# 1 "/usr/include/fenv.h" 1 3 4
# 193 "/usr/include/fenv.h" 3 4
typedef struct {
    unsigned short __control;
    unsigned short __status;
    unsigned int __mxcsr;
    char __reserved[8];
} fenv_t;

typedef unsigned short fexcept_t;
# 220 "/usr/include/fenv.h" 3 4
extern const fenv_t _FE_DFL_ENV;
# 244 "/usr/include/fenv.h" 3 4
extern const fenv_t _FE_DFL_DISABLE_SSE_DENORMS_ENV;
# 297 "/usr/include/fenv.h" 3 4
extern int feclearexcept(int );
extern int fegetexceptflag(fexcept_t * , int );
extern int feraiseexcept(int );
extern int fesetexceptflag(const fexcept_t * , int );
extern int fetestexcept(int );
# 318 "/usr/include/fenv.h" 3 4
extern int fegetround(void);
extern int fesetround(int );
# 351 "/usr/include/fenv.h" 3 4
extern int fegetenv(fenv_t * );
extern int feholdexcept(fenv_t * );
extern int fesetenv(const fenv_t * );
extern int feupdateenv(const fenv_t * );
# 85 "/Users/weugene/basilisk/src/fp_osx.h" 2
# 159 "/Users/weugene/basilisk/src/fp_osx.h"

# 159 "/Users/weugene/basilisk/src/fp_osx.h"
int
fegetexcept (void)
{
  static fenv_t fenv;

  return fegetenv (&fenv) ? -1 : (fenv.__control & 
# 164 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
                                                  0x003f
# 164 "/Users/weugene/basilisk/src/fp_osx.h"
                                                               );
}

int
feenableexcept (unsigned int excepts)
{
  static fenv_t fenv;
  unsigned int new_excepts = excepts & 
# 171 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
                                      0x003f
# 171 "/Users/weugene/basilisk/src/fp_osx.h"
                                                   ,
               old_excepts;

  if ( fegetenv (&fenv) ) return -1;
  old_excepts = fenv.__control & 
# 175 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
                                0x003f
# 175 "/Users/weugene/basilisk/src/fp_osx.h"
                                             ;


  fenv.__control &= ~new_excepts;
  fenv.__mxcsr &= ~(new_excepts << 7);

  return ( fesetenv (&fenv) ? -1 : old_excepts );
}

int
fedisableexcept (unsigned int excepts)
{
  static fenv_t fenv;
  unsigned int new_excepts = excepts & 
# 188 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
                                      0x003f
# 188 "/Users/weugene/basilisk/src/fp_osx.h"
                                                   ,
               old_excepts;

  if ( fegetenv (&fenv) ) return -1;
  old_excepts = fenv.__control & 
# 192 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
                                0x003f
# 192 "/Users/weugene/basilisk/src/fp_osx.h"
                                             ;


  fenv.__control |= new_excepts;
  fenv.__mxcsr |= new_excepts << 7;

  return ( fesetenv (&fenv) ? -1 : old_excepts );
}
# 232 "/Users/weugene/basilisk/src/fp_osx.h"
# 1 "/usr/include/signal.h" 1 3 4
# 66 "/usr/include/signal.h" 3 4
# 1 "/usr/include/sys/_pthread/_pthread_t.h" 1 3 4
# 31 "/usr/include/sys/_pthread/_pthread_t.h" 3 4

# 31 "/usr/include/sys/_pthread/_pthread_t.h" 3 4
typedef __darwin_pthread_t pthread_t;
# 67 "/usr/include/signal.h" 2 3 4







int raise(int);




void (* bsd_signal(int, void (* )(int)))(int);
int kill(pid_t, int) __asm("_" "kill" );
int killpg(pid_t, int) __asm("_" "killpg" );
int pthread_kill(pthread_t, int);
int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_" "pthread_sigmask" );
int sigaction(int, const struct sigaction * restrict,
     struct sigaction * restrict);
int sigaddset(sigset_t *, int);
int sigaltstack(const stack_t * restrict, stack_t * restrict) __asm("_" "sigaltstack" ) ;
int sigdelset(sigset_t *, int);
int sigemptyset(sigset_t *);
int sigfillset(sigset_t *);
int sighold(int);
int sigignore(int);
int siginterrupt(int, int);
int sigismember(const sigset_t *, int);
int sigpause(int) __asm("_" "sigpause" );
int sigpending(sigset_t *);
int sigprocmask(int, const sigset_t * restrict, sigset_t * restrict);
int sigrelse(int);
void (* sigset(int, void (* )(int)))(int);
int sigsuspend(const sigset_t *) __asm("_" "sigsuspend" );
int sigwait(const sigset_t * restrict, int * restrict) __asm("_" "sigwait" );











extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int
__sigbits(int __signo)
{
    return __signo > 32 ? 0 : (1 << (__signo - 1));
}
# 233 "/Users/weugene/basilisk/src/fp_osx.h" 2




# 236 "/Users/weugene/basilisk/src/fp_osx.h"
static const char *fe_code_name[] = {
  "FPE_NOOP",
  "FPE_FLTDIV", "FPE_FLTINV", "FPE_FLTOVF", "FPE_FLTUND",
  "FPE_FLTRES", "FPE_FLTSUB", "FPE_INTDIV", "FPE_INTOVF"
  "FPE_UNKNOWN"
};
# 257 "/Users/weugene/basilisk/src/fp_osx.h"
void
fhdl ( int sig, siginfo_t *sip, ucontext_t *scp )
{
  int fe_code = sip->si_code;
  unsigned int excepts = fetestexcept (
# 261 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
                                      0x003f
# 261 "/Users/weugene/basilisk/src/fp_osx.h"
                                                   );

  switch (fe_code)
  {



    case 
# 268 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
        1
# 268 "/Users/weugene/basilisk/src/fp_osx.h"
                  : fe_code = 1; break;
    case 
# 269 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
        5
# 269 "/Users/weugene/basilisk/src/fp_osx.h"
                  : fe_code = 2; break;
    case 
# 270 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
        2
# 270 "/Users/weugene/basilisk/src/fp_osx.h"
                  : fe_code = 3; break;
    case 
# 271 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
        3
# 271 "/Users/weugene/basilisk/src/fp_osx.h"
                  : fe_code = 4; break;
    case 
# 272 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
        4
# 272 "/Users/weugene/basilisk/src/fp_osx.h"
                  : fe_code = 5; break;
    case 
# 273 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
        6
# 273 "/Users/weugene/basilisk/src/fp_osx.h"
                  : fe_code = 6; break;
    case 
# 274 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
        7
# 274 "/Users/weugene/basilisk/src/fp_osx.h"
                  : fe_code = 7; break;
    case 
# 275 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
        8
# 275 "/Users/weugene/basilisk/src/fp_osx.h"
                  : fe_code = 8; break;
            default: fe_code = 9;
   }

  if ( sig == 
# 279 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
             8 
# 279 "/Users/weugene/basilisk/src/fp_osx.h"
                    )
  {

    unsigned short x87cr,x87sr;
    unsigned int mxcsr;

    __asm ("fnstcw %0" : "=m" (x87cr));;
    __asm ("fnstsw %0" : "=m" (x87sr));;
    __asm ("stmxcsr %0" : "=m" (mxcsr));;
    printf ("X87CR:   0x%04X\n", x87cr);
    printf ("X87SR:   0x%04X\n", x87sr);
    printf ("MXCSR:   0x%08X\n", mxcsr);
# 300 "/Users/weugene/basilisk/src/fp_osx.h"
    printf ("signal:  SIGFPE with code %s\n", fe_code_name[fe_code]);
    printf ("invalid flag:    0x%04X\n", excepts & 
# 301 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
                                                  0x0001
# 301 "/Users/weugene/basilisk/src/fp_osx.h"
                                                            );
    printf ("divByZero flag:  0x%04X\n", excepts & 
# 302 "/Users/weugene/basilisk/src/fp_osx.h" 3 4
                                                  0x0004
# 302 "/Users/weugene/basilisk/src/fp_osx.h"
                                                              );
  }
  else printf ("Signal is not SIGFPE, it's %i.\n", sig);

  abort();
}
# 820 "/Users/weugene/basilisk/src/common.h" 2



static void set_fpe (void) {
  int64_t lnan = 0x7ff0000000000001;
  
# 825 "/Users/weugene/basilisk/src/common.h" 3 4
 (__builtin_expect(!(
# 825 "/Users/weugene/basilisk/src/common.h"
 sizeof (int64_t) == sizeof (double)
# 825 "/Users/weugene/basilisk/src/common.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/common.h", 825, 
# 825 "/Users/weugene/basilisk/src/common.h"
 "sizeof (int64_t) == sizeof (double)"
# 825 "/Users/weugene/basilisk/src/common.h" 3 4
 ) : (void)0)
# 825 "/Users/weugene/basilisk/src/common.h"
                                             ;
  
# 826 "/Users/weugene/basilisk/src/common.h" 3 4
 __builtin___memcpy_chk (
# 826 "/Users/weugene/basilisk/src/common.h"
 &undefined
# 826 "/Users/weugene/basilisk/src/common.h" 3 4
 , 
# 826 "/Users/weugene/basilisk/src/common.h"
 &lnan, sizeof (double)
# 826 "/Users/weugene/basilisk/src/common.h" 3 4
 , __builtin_object_size (
# 826 "/Users/weugene/basilisk/src/common.h"
 &undefined
# 826 "/Users/weugene/basilisk/src/common.h" 3 4
 , 0))
# 826 "/Users/weugene/basilisk/src/common.h"
                                            ;
  feenableexcept (
# 827 "/Users/weugene/basilisk/src/common.h" 3 4
 0x0004
# 827 "/Users/weugene/basilisk/src/common.h"
 |
# 827 "/Users/weugene/basilisk/src/common.h" 3 4
 0x0001
# 827 "/Users/weugene/basilisk/src/common.h"
 );
}
# 837 "/Users/weugene/basilisk/src/common.h"
typedef struct {
  long n;
  long tn;
  int depth;
  int maxdepth;
} Grid;
Grid * grid = 
# 843 "/Users/weugene/basilisk/src/common.h" 3 4
             ((void *)0)
# 843 "/Users/weugene/basilisk/src/common.h"
                 ;

double X0 = 0., Y0 = 0., Z0 = 0.;

double L0 = 1.;


int N = 64;




typedef struct { int i; } scalar;

typedef struct {
  scalar x;

  scalar y;




} vector;

typedef struct {
  vector x;

  vector y;




} tensor;

struct { int x, y, z; } Period = {
# 877 "/Users/weugene/basilisk/src/common.h" 3 4
                                 0
# 877 "/Users/weugene/basilisk/src/common.h"
                                      , 
# 877 "/Users/weugene/basilisk/src/common.h" 3 4
                                        0
# 877 "/Users/weugene/basilisk/src/common.h"
                                             , 
# 877 "/Users/weugene/basilisk/src/common.h" 3 4
                                               0
# 877 "/Users/weugene/basilisk/src/common.h"
                                                    };

typedef struct {
  double x, y, z;
} coord;
# 894 "/Users/weugene/basilisk/src/common.h"
void normalize (coord * n)
{
  double norm = 0.;
  {
# 897 "/Users/weugene/basilisk/src/common.h"

    norm += ((n->x)*(n->x));
# 897 "/Users/weugene/basilisk/src/common.h"

    norm += ((n->y)*(n->y));}
  norm = sqrt(norm);
  {
# 900 "/Users/weugene/basilisk/src/common.h"

    n->x /= norm;
# 900 "/Users/weugene/basilisk/src/common.h"

    n->y /= norm;}
}

struct _origin { double x, y, z; };

void origin (struct _origin p) {
  X0 = p.x; Y0 = p.y; Z0 = p.z;
}

void size (double L) {
  L0 = L;
}

double zero (double s0, double s1, double s2) { return 0.; }






  enum { right, left, top, bottom };



int nboundary = 2*2;
# 934 "/Users/weugene/basilisk/src/common.h"
double * _constant = 
# 934 "/Users/weugene/basilisk/src/common.h" 3 4
                    ((void *)0)
# 934 "/Users/weugene/basilisk/src/common.h"
                        ;
extern size_t datasize;
typedef struct _Point Point;
# 1 "/Users/weugene/basilisk/src/grid/boundaries.h"


typedef struct _Boundary Boundary;

struct _Boundary {
  void (* destroy) (Boundary * b);
  void (* level) (const Boundary * b, scalar * list, int l);

  void (* restriction) (const Boundary * b, scalar * list, int l);
};

static Boundary ** boundaries = 
# 12 "/Users/weugene/basilisk/src/grid/boundaries.h" 3 4
                               ((void *)0)
# 12 "/Users/weugene/basilisk/src/grid/boundaries.h"
                                   ;

void add_boundary (Boundary * b) {
  int len = 0;
  if (boundaries) {
    Boundary ** i = boundaries;
    while (*i++) len++;
  }
  boundaries = (Boundary * *) realloc(boundaries,(len + 2)*sizeof(Boundary *));
  boundaries[len] = b;
  boundaries[len+1] = 
# 22 "/Users/weugene/basilisk/src/grid/boundaries.h" 3 4
                     ((void *)0)
# 22 "/Users/weugene/basilisk/src/grid/boundaries.h"
                         ;
}

void free_boundaries() {
  if (!boundaries)
    return;
  Boundary ** i = boundaries, * b;
  while ((b = *i++))
    if (b->destroy)
      b->destroy (b);
    else
      free(b);
  free(boundaries);
  boundaries = 
# 35 "/Users/weugene/basilisk/src/grid/boundaries.h" 3 4
              ((void *)0)
# 35 "/Users/weugene/basilisk/src/grid/boundaries.h"
                  ;
}
# 47 "/Users/weugene/basilisk/src/grid/boundaries.h"
typedef struct {
  Boundary parent;
  int d;
} BoxBoundary;
# 939 "/Users/weugene/basilisk/src/common.h"



typedef struct {
# 944 "/Users/weugene/basilisk/src/common.h"

  double (** boundary) (Point, Point, scalar, void *);
  double (** boundary_homogeneous) (Point, Point, scalar, void *);
  double (* gradient) (double, double, double);
  void (* delete) (scalar);
  char * name;
  struct {
    int x;

    int y;




  } d;
  vector v;
  
# 960 "/Users/weugene/basilisk/src/common.h" 3 4
 _Bool 
# 960 "/Users/weugene/basilisk/src/common.h"
      face, nodump;
# 17 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  void (* prolongation) (Point, scalar);
  void (* restriction) (Point, scalar);
# 8 "/Users/weugene/basilisk/src/grid/tree-common.h"

  void (* refine) (Point, scalar);
# 94 "/Users/weugene/basilisk/src/grid/tree-common.h"

  void (* coarsen) (Point, scalar);
# 81 "/Users/weugene/basilisk/src/fractions.h"

  vector n;

} _Attributes;
_Attributes * _attribute;
# 942 "/Users/weugene/basilisk/src/common.h"
# 965 "/Users/weugene/basilisk/src/common.h"
int list_len (scalar * list)
{
  if (!list) return 0;
  int ns = 0;
  if (list) for (scalar s = *list, *_i0 = list; ((scalar *)&s)->i >= 0; s = *++_i0) ns++;
  return ns;
}

scalar * list_append (scalar * list, scalar s)
{
  int len = list_len (list);
  list = (scalar *) realloc(list,(len + 2)*sizeof(scalar));
  list[len] = s;
  list[len + 1].i = -1;
  return list;
}

scalar * list_prepend (scalar * list, scalar s)
{
  int len = list_len (list);
  list = (scalar *) realloc(list,(len + 2)*sizeof(scalar));
  for (int i = len; i >= 1; i--)
    list[i] = list[i-1];
  list[0] = s;
  list[len + 1].i = -1;
  return list;
}

scalar * list_add (scalar * list, scalar s)
{
  if (list) for (scalar t = *list, *_i1 = list; ((scalar *)&t)->i >= 0; t = *++_i1)
    if (t.i == s.i)
      return list;
  return list_append (list, s);
}

int list_lookup (scalar * l, scalar s)
{
  if (l != 
# 1003 "/Users/weugene/basilisk/src/common.h" 3 4
          ((void *)0)
# 1003 "/Users/weugene/basilisk/src/common.h"
              )
    if (l) for (scalar s1 = *l, *_i2 = l; ((scalar *)&s1)->i >= 0; s1 = *++_i2)
      if (s1.i == s.i)
 return 
# 1006 "/Users/weugene/basilisk/src/common.h" 3 4
       1
# 1006 "/Users/weugene/basilisk/src/common.h"
           ;
  return 
# 1007 "/Users/weugene/basilisk/src/common.h" 3 4
        0
# 1007 "/Users/weugene/basilisk/src/common.h"
             ;
}

scalar * list_copy (scalar * l)
{
  scalar * list = 
# 1012 "/Users/weugene/basilisk/src/common.h" 3 4
                 ((void *)0)
# 1012 "/Users/weugene/basilisk/src/common.h"
                     ;
  if (l != 
# 1013 "/Users/weugene/basilisk/src/common.h" 3 4
          ((void *)0)
# 1013 "/Users/weugene/basilisk/src/common.h"
              )
    if (l) for (scalar s = *l, *_i3 = l; ((scalar *)&s)->i >= 0; s = *++_i3)
      list = list_append (list, s);
  return list;
}

scalar * list_concat (scalar * l1, scalar * l2)
{
  scalar * l3 = list_copy (l1);
  if (l2) for (scalar s = *l2, *_i4 = l2; ((scalar *)&s)->i >= 0; s = *++_i4)
    l3 = list_append (l3, s);
  return l3;
}

void list_print (scalar * l, FILE * fp)
{
  int i = 0;
  if (l) for (scalar s = *l, *_i5 = l; ((scalar *)&s)->i >= 0; s = *++_i5)
    fprintf (fp, "%s%s", i++ == 0 ? "{" : ",", _attribute[s.i].name);
  fputs (i > 0 ? "}\n" : "{}\n", fp);
}

int vectors_len (vector * list)
{
  if (!list) return 0;
  int nv = 0;
  if (list) for (vector v = *list, *_i6 = list; ((scalar *)&v)->i >= 0; v = *++_i6) nv++;
  return nv;
}

vector * vectors_append (vector * list, vector v)
{
  int len = vectors_len (list);
  list = (vector *) realloc(list,(len + 2)*sizeof(vector));
  list[len] = v;
  list[len + 1] = (vector){{-1}};
  return list;
}

vector * vectors_add (vector * list, vector v)
{
  if (list) for (vector w = *list, *_i7 = list; ((scalar *)&w)->i >= 0; w = *++_i7) {
    
# 1055 "/Users/weugene/basilisk/src/common.h" 3 4
   _Bool 
# 1055 "/Users/weugene/basilisk/src/common.h"
        id = 
# 1055 "/Users/weugene/basilisk/src/common.h" 3 4
             1
# 1055 "/Users/weugene/basilisk/src/common.h"
                 ;
    {
# 1056 "/Users/weugene/basilisk/src/common.h"

      if (w.x.i != v.x.i)
 id = 
# 1058 "/Users/weugene/basilisk/src/common.h" 3 4
     0
# 1058 "/Users/weugene/basilisk/src/common.h"
          ;
# 1056 "/Users/weugene/basilisk/src/common.h"

      if (w.y.i != v.y.i)
 id = 
# 1058 "/Users/weugene/basilisk/src/common.h" 3 4
     0
# 1058 "/Users/weugene/basilisk/src/common.h"
          ;}
    if (id)
      return list;
  }
  return vectors_append (list, v);
}

vector * vectors_copy (vector * l)
{
  vector * list = 
# 1067 "/Users/weugene/basilisk/src/common.h" 3 4
                 ((void *)0)
# 1067 "/Users/weugene/basilisk/src/common.h"
                     ;
  if (l != 
# 1068 "/Users/weugene/basilisk/src/common.h" 3 4
          ((void *)0)
# 1068 "/Users/weugene/basilisk/src/common.h"
              )
    if (l) for (vector v = *l, *_i8 = l; ((scalar *)&v)->i >= 0; v = *++_i8)
      list = vectors_append (list, v);
  return list;
}

vector * vectors_from_scalars (scalar * s)
{
  vector * list = 
# 1076 "/Users/weugene/basilisk/src/common.h" 3 4
                 ((void *)0)
# 1076 "/Users/weugene/basilisk/src/common.h"
                     ;
  while (s->i >= 0) {
    vector v;
    {
# 1079 "/Users/weugene/basilisk/src/common.h"
 {
      
# 1080 "/Users/weugene/basilisk/src/common.h" 3 4
     (__builtin_expect(!(
# 1080 "/Users/weugene/basilisk/src/common.h"
     s->i >= 0
# 1080 "/Users/weugene/basilisk/src/common.h" 3 4
     ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/common.h", 1080, 
# 1080 "/Users/weugene/basilisk/src/common.h"
     "s->i >= 0"
# 1080 "/Users/weugene/basilisk/src/common.h" 3 4
     ) : (void)0)
# 1080 "/Users/weugene/basilisk/src/common.h"
                       ;
      v.x = *s++;
    }
# 1079 "/Users/weugene/basilisk/src/common.h"
 {
      
# 1080 "/Users/weugene/basilisk/src/common.h" 3 4
     (__builtin_expect(!(
# 1080 "/Users/weugene/basilisk/src/common.h"
     s->i >= 0
# 1080 "/Users/weugene/basilisk/src/common.h" 3 4
     ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/common.h", 1080, 
# 1080 "/Users/weugene/basilisk/src/common.h"
     "s->i >= 0"
# 1080 "/Users/weugene/basilisk/src/common.h" 3 4
     ) : (void)0)
# 1080 "/Users/weugene/basilisk/src/common.h"
                       ;
      v.y = *s++;
    }}
    list = vectors_append (list, v);
  }
  return list;
}

int tensors_len (tensor * list)
{
  if (!list) return 0;
  int nt = 0;
  if (list) for (tensor t = *list, *_i9 = list; ((scalar *)&t)->i >= 0; t = *++_i9) nt++;
  return nt;
}

tensor * tensors_append (tensor * list, tensor t)
{
  int len = tensors_len (list);
  list = (tensor *) realloc(list,(len + 2)*sizeof(tensor));
  list[len] = t;
  list[len + 1] = (tensor){{{-1}}};
  return list;
}

tensor * tensors_from_vectors (vector * v)
{
  tensor * list = 
# 1107 "/Users/weugene/basilisk/src/common.h" 3 4
                 ((void *)0)
# 1107 "/Users/weugene/basilisk/src/common.h"
                     ;
  while (v->x.i >= 0) {
    tensor t;
    {
# 1110 "/Users/weugene/basilisk/src/common.h"
 {
      
# 1111 "/Users/weugene/basilisk/src/common.h" 3 4
     (__builtin_expect(!(
# 1111 "/Users/weugene/basilisk/src/common.h"
     v->x.i >= 0
# 1111 "/Users/weugene/basilisk/src/common.h" 3 4
     ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/common.h", 1111, 
# 1111 "/Users/weugene/basilisk/src/common.h"
     "v->x.i >= 0"
# 1111 "/Users/weugene/basilisk/src/common.h" 3 4
     ) : (void)0)
# 1111 "/Users/weugene/basilisk/src/common.h"
                         ;
      t.x = *v++;
    }
# 1110 "/Users/weugene/basilisk/src/common.h"
 {
      
# 1111 "/Users/weugene/basilisk/src/common.h" 3 4
     (__builtin_expect(!(
# 1111 "/Users/weugene/basilisk/src/common.h"
     v->y.i >= 0
# 1111 "/Users/weugene/basilisk/src/common.h" 3 4
     ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/common.h", 1111, 
# 1111 "/Users/weugene/basilisk/src/common.h"
     "v->y.i >= 0"
# 1111 "/Users/weugene/basilisk/src/common.h" 3 4
     ) : (void)0)
# 1111 "/Users/weugene/basilisk/src/common.h"
                         ;
      t.y = *v++;
    }}
    list = tensors_append (list, t);
  }
  return list;
}

scalar * all = 
# 1119 "/Users/weugene/basilisk/src/common.h" 3 4
              ((void *)0)
# 1119 "/Users/weugene/basilisk/src/common.h"
                  ;



scalar (* init_scalar) (scalar, const char *);
scalar (* init_vertex_scalar) (scalar, const char *);
vector (* init_vector) (vector, const char *);
tensor (* init_tensor) (tensor, const char *);
vector (* init_face_vector) (vector, const char *);





typedef struct _Event Event;
typedef int (* Expr) (int *, double *, Event *);

struct _Event {
  int last, nexpr;
  int (* action) (const int, const double, Event *);
  Expr expr[3];
  int * arrayi;
  double * arrayt;
  char * file;
  int line;
  char * name;
  double t;
  int i, a;
  void * data;
  Event * next;
};

static Event * Events = 
# 1151 "/Users/weugene/basilisk/src/common.h" 3 4
                       ((void *)0)
# 1151 "/Users/weugene/basilisk/src/common.h"
                           ;

int iter = 0, inext = 0;
double t = 0, tnext = 0;
void init_events (void);
void event_register (Event event);
void _init_solver (void);







typedef struct {
  clock_t c;
  struct timeval tv;
  double tm;
} timer;

timer timer_start (void)
{
  timer t;
  t.c = clock();
  gettimeofday (&t.tv, 
# 1175 "/Users/weugene/basilisk/src/common.h" 3 4
                      ((void *)0)
# 1175 "/Users/weugene/basilisk/src/common.h"
                          );



  return t;
}

double timer_elapsed (timer t)
{
  struct timeval tvend;
  gettimeofday (&tvend, 
# 1185 "/Users/weugene/basilisk/src/common.h" 3 4
                       ((void *)0)
# 1185 "/Users/weugene/basilisk/src/common.h"
                           );
  return ((tvend.tv_sec - t.tv.tv_sec) +
   (tvend.tv_usec - t.tv.tv_usec)/1e6);
}


vector zerof= {{65536 + 0},{65536 + 1}};
vector unityf= {{65536 + 2},{65536 + 3}};
scalar unity= {65536 + 4};
scalar zeroc= {65536 + 5};



 vector fm = {{65536 + 2},{65536 + 3}};
 scalar cm = {(65536 + 4)};
# 1213 "/Users/weugene/basilisk/src/common.h"
static FILE ** qpopen_pipes = 
# 1213 "/Users/weugene/basilisk/src/common.h" 3 4
                             ((void *)0)
# 1213 "/Users/weugene/basilisk/src/common.h"
                                 ;

FILE * qpopen (const char * command, const char * type)
{
  if (0 > 0)
    return fopen ("/dev/null", type);
  FILE * fp = popen (command, type);
  if (fp) {
    FILE ** i = qpopen_pipes;
    int n = 0;
    while (i && *i) { n++; i++; }
    qpopen_pipes = (FILE * *) realloc(qpopen_pipes,(n + 2)*sizeof(FILE *));
    qpopen_pipes[n] = fp;
    qpopen_pipes[n+1] = 
# 1226 "/Users/weugene/basilisk/src/common.h" 3 4
                       ((void *)0)
# 1226 "/Users/weugene/basilisk/src/common.h"
                           ;
  }
  return fp;
}

int qpclose (FILE * fp)
{
  if (0 > 0)
    return fclose (fp);
  FILE ** i = qpopen_pipes;
  while (i && *i) {
    if (*i == fp)
      *i = (FILE *) 1;
    i++;
  }
  return pclose (fp);
}

static void qpclose_all()
{
  FILE ** i = qpopen_pipes;
  while (i && *i) {
    if (*i != (FILE *) 1)
      pclose (*i);
    i++;
  }
  free(qpopen_pipes);
  qpopen_pipes = 
# 1253 "/Users/weugene/basilisk/src/common.h" 3 4
                ((void *)0)
# 1253 "/Users/weugene/basilisk/src/common.h"
                    ;
}






FILE * lfopen (const char * name, const char * mode)
{
  char fname[80];
  
# 1264 "/Users/weugene/basilisk/src/common.h" 3 4
 __builtin___sprintf_chk (
# 1264 "/Users/weugene/basilisk/src/common.h"
 fname
# 1264 "/Users/weugene/basilisk/src/common.h" 3 4
 , 0, __builtin_object_size (
# 1264 "/Users/weugene/basilisk/src/common.h"
 fname
# 1264 "/Users/weugene/basilisk/src/common.h" 3 4
 , 2 > 1 ? 1 : 0), 
# 1264 "/Users/weugene/basilisk/src/common.h"
 "%s-%d", name, 0
# 1264 "/Users/weugene/basilisk/src/common.h" 3 4
 )
# 1264 "/Users/weugene/basilisk/src/common.h"
                                      ;
  return fopen (fname, mode);
}



void * matrix_new (int n, int p, size_t size)
{
  void ** m = ((void * *) malloc((n)*sizeof(void *)));
  char * a = ((char *) malloc((n*p*size)*sizeof(char)));
  for (int i = 0; i < n; i++)
    m[i] = a + i*p*size;
  return m;
}

double matrix_inverse (double ** m, int n, double pivmin)
{
  int indxc[n], indxr[n], ipiv[n];
  int i, icol = 0, irow = 0, j, k, l, ll;
  double big, dum, pivinv, minpiv = ((double)1e30);

  for (j = 0; j < n; j++)
    ipiv[j] = -1;

  for (i = 0; i < n; i++) {
    big = 0.0;
    for (j = 0; j < n; j++)
      if (ipiv[j] != 0)
 for (k = 0; k < n; k++) {
   if (ipiv[k] == -1) {
     if (fabs (m[j][k]) >= big) {
       big = fabs (m[j][k]);
       irow = j;
       icol = k;
     }
   }
 }
    ipiv[icol]++;
    if (irow != icol)
      for (l = 0; l < n; l++)
 { double tmp = m[irow][l]; m[irow][l] = m[icol][l]; m[icol][l] = tmp; };
    indxr[i] = irow;
    indxc[i] = icol;
    if (fabs (m[icol][icol]) <= pivmin)
      return 0.;
    if (fabs (m[icol][icol]) < minpiv)
      minpiv = fabs (m[icol][icol]);
    pivinv = 1.0/m[icol][icol];
    m[icol][icol] = 1.0;
    for (l = 0; l < n; l++) m[icol][l] *= pivinv;
    for (ll = 0; ll < n; ll++)
      if (ll != icol) {
 dum = m[ll][icol];
 m[ll][icol] = 0.0;
 for (l = 0; l < n; l++)
   m[ll][l] -= m[icol][l]*dum;
      }
  }
  for (l = n - 1; l >= 0; l--) {
    if (indxr[l] != indxc[l])
      for (k = 0; k < n; k++)
 { double tmp = m[k][indxr[l]]; m[k][indxr[l]] = m[k][indxc[l]]; m[k][indxc[l]] = tmp; };
  }
  return minpiv;
}

void matrix_free (void * m)
{
  free(((void **) m)[0]);
  free(m);
}
# 13 "karman_GI-cpp.c"
# 1 "grid/quadtree.h"
# 1 "/Users/weugene/basilisk/src/grid/quadtree.h"
# 1 "grid/tree.h"
# 1 "/Users/weugene/basilisk/src/grid/tree.h"
# 1 "grid/mempool.h"
# 1 "/Users/weugene/basilisk/src/grid/mempool.h"





typedef struct _Pool Pool;

struct _Pool {
  Pool * next;
};

typedef struct {
  char * first, * lastb;
  size_t size;
  size_t poolsize;
  Pool * pool, * last;
} Mempool;

typedef struct {
  char * next;
} FreeBlock;

Mempool * mempool_new (size_t poolsize, size_t size)
{

  
# 26 "/Users/weugene/basilisk/src/grid/mempool.h" 3 4
 (__builtin_expect(!(
# 26 "/Users/weugene/basilisk/src/grid/mempool.h"
 poolsize % 8 == 0
# 26 "/Users/weugene/basilisk/src/grid/mempool.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/mempool.h", 26, 
# 26 "/Users/weugene/basilisk/src/grid/mempool.h"
 "poolsize % 8 == 0"
# 26 "/Users/weugene/basilisk/src/grid/mempool.h" 3 4
 ) : (void)0)
# 26 "/Users/weugene/basilisk/src/grid/mempool.h"
                           ;
  
# 27 "/Users/weugene/basilisk/src/grid/mempool.h" 3 4
 (__builtin_expect(!(
# 27 "/Users/weugene/basilisk/src/grid/mempool.h"
 size >= sizeof(FreeBlock)
# 27 "/Users/weugene/basilisk/src/grid/mempool.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/mempool.h", 27, 
# 27 "/Users/weugene/basilisk/src/grid/mempool.h"
 "size >= sizeof(FreeBlock)"
# 27 "/Users/weugene/basilisk/src/grid/mempool.h" 3 4
 ) : (void)0)
# 27 "/Users/weugene/basilisk/src/grid/mempool.h"
                                   ;


  poolsize = ((1 << 20) < (poolsize + sizeof(Pool)) ? (1 << 20) : (poolsize + sizeof(Pool)));
  Mempool * m = ((Mempool *) calloc(1,sizeof(Mempool)));
  m->poolsize = poolsize;
  m->size = size;
  return m;
}

void mempool_destroy (Mempool * m)
{
  Pool * p = m->pool;
  while (p) {
    Pool * next = p->next;
    free(p);
    p = next;
  }
  free(m);
}

void * mempool_alloc (Mempool * m)
{
  if (!m->first) {

    Pool * p = (Pool *) malloc(m->poolsize);
    p->next = 
# 53 "/Users/weugene/basilisk/src/grid/mempool.h" 3 4
             ((void *)0)
# 53 "/Users/weugene/basilisk/src/grid/mempool.h"
                 ;
    if (m->last)
      m->last->next = p;
    else
      m->pool = p;
    m->last = p;
    m->first = m->lastb = ((char *)m->last) + sizeof(Pool);
    FreeBlock * b = (FreeBlock *) m->first;
    b->next = 
# 61 "/Users/weugene/basilisk/src/grid/mempool.h" 3 4
             ((void *)0)
# 61 "/Users/weugene/basilisk/src/grid/mempool.h"
                 ;
  }
  void * ret = m->first;
  FreeBlock * b = (FreeBlock *) ret;
  char * next = b->next;
  if (!next) {
    m->lastb += m->size;
    next = m->lastb;
    if (next + m->size > ((char *) m->last) + m->poolsize)
      next = 
# 70 "/Users/weugene/basilisk/src/grid/mempool.h" 3 4
            ((void *)0)
# 70 "/Users/weugene/basilisk/src/grid/mempool.h"
                ;
    else {
      FreeBlock * b = (FreeBlock *) next;
      b->next = 
# 73 "/Users/weugene/basilisk/src/grid/mempool.h" 3 4
               ((void *)0)
# 73 "/Users/weugene/basilisk/src/grid/mempool.h"
                   ;
    }
  }
  m->first = next;





  return ret;
}

void * mempool_alloc0 (Mempool * m)
{
  void * ret = mempool_alloc (m);
  
# 88 "/Users/weugene/basilisk/src/grid/mempool.h" 3 4
 __builtin___memset_chk (
# 88 "/Users/weugene/basilisk/src/grid/mempool.h"
 ret
# 88 "/Users/weugene/basilisk/src/grid/mempool.h" 3 4
 , 
# 88 "/Users/weugene/basilisk/src/grid/mempool.h"
 0, m->size
# 88 "/Users/weugene/basilisk/src/grid/mempool.h" 3 4
 , __builtin_object_size (
# 88 "/Users/weugene/basilisk/src/grid/mempool.h"
 ret
# 88 "/Users/weugene/basilisk/src/grid/mempool.h" 3 4
 , 0))
# 88 "/Users/weugene/basilisk/src/grid/mempool.h"
                         ;
  return ret;
}

void mempool_free (Mempool * m, void * p)
{





  FreeBlock * b = (FreeBlock *) p;
  b->next = m->first;
  m->first = (char *) p;
}
# 2 "/Users/weugene/basilisk/src/grid/tree.h"
# 10 "/Users/weugene/basilisk/src/grid/tree.h"
# 22 "/Users/weugene/basilisk/src/grid/tree.h"
typedef struct {
  unsigned short flags;

  unsigned short neighbors;
  int pid;
} Cell;

enum {
  active = 1 << 0,
  leaf = 1 << 1,
  border = 1 << 2,
  vertex = 1 << 3,
  user = 4,

  face_x = 1 << 0

  , face_y = 1 << 1




};
# 54 "/Users/weugene/basilisk/src/grid/tree.h"
typedef struct {
  int i;

  int j;




} IndexLevel;

typedef struct {
  IndexLevel * p;
  int n, nm;
} CacheLevel;

typedef struct {
  int i;

  int j;




  int level, flags;
} Index;

typedef struct {
  Index * p;
  int n, nm;
} Cache;




static char * new_refarray (size_t len, size_t size) {
  return (char *) calloc(len + 1,size);
}

static void refarray (void * p, size_t len, size_t size) {
  int * refcount = (int *)(((char *)p) + len*size);
  (*refcount)++;
}

static 
# 97 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
      _Bool 
# 97 "/Users/weugene/basilisk/src/grid/tree.h"
           unrefarray (void * p, size_t len, size_t size) {
  int * refcount = (int *)(((char *)p) + len*size);
  (*refcount)--;
  if (*refcount == 0) {
    free(p);
    return 
# 102 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
          1
# 102 "/Users/weugene/basilisk/src/grid/tree.h"
              ;
  }
  return 
# 104 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
        0
# 104 "/Users/weugene/basilisk/src/grid/tree.h"
             ;
}




typedef struct {



  char *** m;



  Mempool * pool;
  int nc;
  int len;
} Layer;

static size_t _size (size_t depth)
{
  return (1 << depth) + 2*2;
}

static size_t poolsize (size_t depth, size_t size)
{




  return ((_size(depth))*(_size(depth)))*size;



}
# 140 "/Users/weugene/basilisk/src/grid/tree.h"

static inline
void assign_periodic_x (void ** m, int i, int nl, void * b)
{
  m[i] = b;
  if (Period.x) {
    for (int j = i; j < nl + 2*2; j += nl)
      m[j] = b;
    for (int j = i - nl; j >= 0; j -= nl)
      m[j] = b;
  }
}
# 140 "/Users/weugene/basilisk/src/grid/tree.h"

static inline
void assign_periodic_y (void ** m, int i, int nl, void * b)
{
  m[i] = b;
  if (Period.y) {
    for (int j = i; j < nl + 2*2; j += nl)
      m[j] = b;
    for (int j = i - nl; j >= 0; j -= nl)
      m[j] = b;
  }
}

static Layer * new_layer (int depth)
{
  Layer * l = ((Layer *) malloc((1)*sizeof(Layer)));
  l->len = _size (depth);
  if (depth == 0)
    l->pool = 
# 158 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
             ((void *)0)
# 158 "/Users/weugene/basilisk/src/grid/tree.h"
                 ;
  else {
    size_t size = sizeof(Cell) + datasize;


    l->pool = mempool_new (poolsize (depth, size), (1 << 2)*size);
  }



  l->m = ((char ** *) calloc(l->len,sizeof(char **)));



  l->nc = 0;
  return l;
}

static void destroy_layer (Layer * l)
{
  if (l->pool)
    mempool_destroy (l->pool);
  free(l->m);
  free(l);
}
# 200 "/Users/weugene/basilisk/src/grid/tree.h"
static void layer_add_row (Layer * l, int i, int j)
{
  if (!l->m[i]) {
    assign_periodic_x ((void **) l->m, i, l->len - 2*2,
         (void *) new_refarray (l->len, sizeof (char *)));
    l->nc++;
  }
  refarray (l->m[i], l->len, sizeof(char *));






}

static 
# 216 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
      _Bool 
# 216 "/Users/weugene/basilisk/src/grid/tree.h"
           layer_remove_row (Layer * l, int i, int j)
{




  if (unrefarray (l->m[i], l->len, sizeof (char *))) {
    assign_periodic_x ((void **) l->m, i, l->len - 2*2, 
# 223 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                       ((void *)0)
# 223 "/Users/weugene/basilisk/src/grid/tree.h"
                                                           );
    if (--l->nc == 0) {
      destroy_layer (l);
      return 
# 226 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
            1
# 226 "/Users/weugene/basilisk/src/grid/tree.h"
                ;
    }
    
# 228 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
   (__builtin_expect(!(
# 228 "/Users/weugene/basilisk/src/grid/tree.h"
   l->nc >= 0
# 228 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
   ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree.h", 228, 
# 228 "/Users/weugene/basilisk/src/grid/tree.h"
   "l->nc >= 0"
# 228 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
   ) : (void)0)
# 228 "/Users/weugene/basilisk/src/grid/tree.h"
                      ;
  }
  return 
# 230 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
        0
# 230 "/Users/weugene/basilisk/src/grid/tree.h"
             ;
}




typedef struct {
  Grid g;
  Layer ** L;

  Cache leaves;
  Cache faces;
  Cache vertices;
  Cache refined;
  CacheLevel * active;
  CacheLevel * prolongation;
  CacheLevel * boundary;

  CacheLevel * restriction;

  
# 250 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
 _Bool 
# 250 "/Users/weugene/basilisk/src/grid/tree.h"
      dirty;
} Tree;



struct _Point {

  int i;

  int j;




  int level;
};
static Point last_point;



static void cache_level_append (CacheLevel * c, Point p)
{
  if (c->n >= c->nm) {
    c->nm += 128;
    c->p = (IndexLevel *) realloc(c->p,(c->nm)*sizeof(IndexLevel));
  }
  c->p[c->n].i = p.i;

  c->p[c->n].j = p.j;




  c->n++;
}

static void cache_level_shrink (CacheLevel * c)
{
  if (c->nm > (c->n/128 + 1)*128) {
    c->nm = (c->n/128 + 1)*128;
    
# 290 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
   (__builtin_expect(!(
# 290 "/Users/weugene/basilisk/src/grid/tree.h"
   c->nm > c->n
# 290 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
   ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree.h", 290, 
# 290 "/Users/weugene/basilisk/src/grid/tree.h"
   "c->nm > c->n"
# 290 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
   ) : (void)0)
# 290 "/Users/weugene/basilisk/src/grid/tree.h"
                        ;
    c->p = (IndexLevel *) realloc(c->p,sizeof (Index)*c->nm);
  }
}

static void cache_append (Cache * c, Point p, unsigned short flags)
{
  if (c->n >= c->nm) {
    c->nm += 128;
    c->p = (Index *) realloc(c->p,(c->nm)*sizeof(Index));
  }
  c->p[c->n].i = p.i;

  c->p[c->n].j = p.j;




  c->p[c->n].level = p.level;
  c->p[c->n].flags = flags;
  c->n++;
}

void cache_shrink (Cache * c)
{
  cache_level_shrink ((CacheLevel *)c);
}
# 343 "/Users/weugene/basilisk/src/grid/tree.h"
# 349 "/Users/weugene/basilisk/src/grid/tree.h"
# 354 "/Users/weugene/basilisk/src/grid/tree.h"
# 360 "/Users/weugene/basilisk/src/grid/tree.h"
# 363 "/Users/weugene/basilisk/src/grid/tree.h"
# 403 "/Users/weugene/basilisk/src/grid/tree.h"
# 422 "/Users/weugene/basilisk/src/grid/tree.h"
# 458 "/Users/weugene/basilisk/src/grid/tree.h"
# 1 "grid/foreach_cell.h"
# 1 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 66 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 89 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 123 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 134 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 147 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 244 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 250 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 262 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 275 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 281 "/Users/weugene/basilisk/src/grid/foreach_cell.h"
# 461 "/Users/weugene/basilisk/src/grid/tree.h"
# 478 "/Users/weugene/basilisk/src/grid/tree.h"
# 486 "/Users/weugene/basilisk/src/grid/tree.h"
# 493 "/Users/weugene/basilisk/src/grid/tree.h"
# 524 "/Users/weugene/basilisk/src/grid/tree.h"
# 533 "/Users/weugene/basilisk/src/grid/tree.h"
# 558 "/Users/weugene/basilisk/src/grid/tree.h"
# 583 "/Users/weugene/basilisk/src/grid/tree.h"
# 591 "/Users/weugene/basilisk/src/grid/tree.h"
# 614 "/Users/weugene/basilisk/src/grid/tree.h"
# 628 "/Users/weugene/basilisk/src/grid/tree.h"
# 635 "/Users/weugene/basilisk/src/grid/tree.h"
# 1 "grid/neighbors.h"
# 1 "/Users/weugene/basilisk/src/grid/neighbors.h"
# 17 "/Users/weugene/basilisk/src/grid/neighbors.h"
# 25 "/Users/weugene/basilisk/src/grid/neighbors.h"
# 31 "/Users/weugene/basilisk/src/grid/neighbors.h"
# 639 "/Users/weugene/basilisk/src/grid/tree.h"

static inline 
# 640 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
             _Bool 
# 640 "/Users/weugene/basilisk/src/grid/tree.h"
                  has_local_children (Point point)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 641 "/Users/weugene/basilisk/src/grid/tree.h"

   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0))
      return 
# 644 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
            1
# 644 "/Users/weugene/basilisk/src/grid/tree.h"
                ; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
  return 
# 645 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
        0
# 645 "/Users/weugene/basilisk/src/grid/tree.h"
             ;
}

static inline void cache_append_face (Point point, unsigned short flags)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 649 "/Users/weugene/basilisk/src/grid/tree.h"

  Tree * q = ((Tree *)grid);
  cache_append (&q->faces, point, flags);

  if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & vertex)) {
    cache_append (&q->vertices, point, 0);
    (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags |= vertex;
  }
  {
# 657 "/Users/weugene/basilisk/src/grid/tree.h"

    if ((flags & face_y) && !(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]))))).flags & vertex)) {
      cache_append (&q->vertices, (Point) { point.i + 1, point.j + 0, point.level }, 0);
      (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0])))).flags |= vertex;
    }
# 657 "/Users/weugene/basilisk/src/grid/tree.h"

    if ((flags & face_x) && !(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]))))).flags & vertex)) {
      cache_append (&q->vertices, (Point) { point.i + 0, point.j + 1, point.level }, 0);
      (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1])))).flags |= vertex;
    }}
# 672 "/Users/weugene/basilisk/src/grid/tree.h"
}



void check_periodic (Tree * q)
{
# 703 "/Users/weugene/basilisk/src/grid/tree.h"
}

static void update_cache_f (void)
{
  Tree * q = ((Tree *)grid);

  check_periodic (q);

   { { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < q->vertices.n; _k++) { point.i = q->vertices.p[_k].i; point.j = q->vertices.p[_k].j; point.level = q->vertices.p[_k].level; _flags = q->vertices.p[_k].flags; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 711 "/Users/weugene/basilisk/src/grid/tree.h"

    if (level <= (grid->depth) && (point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))
      (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags &= ~vertex; } } } }; }


  q->leaves.n = q->faces.n = q->vertices.n = 0;
  for (int l = 0; l <= (grid->depth); l++)
    q->active[l].n = q->prolongation[l].n =
      q->boundary[l].n = q->restriction[l].n = 0;

  const unsigned short fboundary = 1 << user;
   { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 722 "/Users/weugene/basilisk/src/grid/tree.h"
 {



    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & active)) {


      cache_level_append (&q->active[level], point);
    }
# 746 "/Users/weugene/basilisk/src/grid/tree.h"
    if (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid < 0)) {

       { { int _nn = 1 + 0 ? 1 + 0 : 2; int _i = point.i, _j = point.j; for (int _k = - _nn; _k <= _nn; _k++) { point.i = _i + _k; for (int _l = - _nn; _l <= _nn; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) && ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid < 0) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags & fboundary)) {
   cache_level_append (&q->boundary[level], point);
   (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags |= fboundary;
 } } } point.i = _i; point.j = _j;}; }
    }

    else if (level > 0 && (((*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0]))))).pid == 0))
      cache_level_append (&q->restriction[level], point);

    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {
      if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0)) {
 cache_append (&q->leaves, point, 0);

 unsigned short flags = 0;
 {
# 763 "/Users/weugene/basilisk/src/grid/tree.h"

   if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0])))).pid < 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0])))).pid >= 0) ||
       (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]))))).flags & leaf))
     flags |= face_x;
# 763 "/Users/weugene/basilisk/src/grid/tree.h"

   if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1])))).pid < 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1])))).pid >= 0) ||
       (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]))))).flags & leaf))
     flags |= face_y;}
 if (flags)
   cache_append (&q->faces, point, flags);
 {
# 769 "/Users/weugene/basilisk/src/grid/tree.h"

   if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0])))).pid < 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0])))).pid >= 0) ||
       (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]))))).pid == 0) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]))))).flags & leaf)))
     cache_append (&q->faces, (Point) { point.i + 1, point.j + 0, point.level }, face_x);
# 769 "/Users/weugene/basilisk/src/grid/tree.h"

   if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1])))).pid < 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1])))).pid >= 0) ||
       (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]))))).pid == 0) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]))))).flags & leaf)))
     cache_append (&q->faces, (Point) { point.i + 0, point.j + 1, point.level }, face_y);}

 for (int i = 0; i <= 1; i++)

   for (int j = 0; j <= 1; j++)




       if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j]))))).flags & vertex)) {
  cache_append (&q->vertices, (Point) { point.i + i, point.j + j, point.level }, 0);
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j])))).flags |= vertex;
       }

        if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors > 0)
   cache_level_append (&q->prolongation[level], point);
      }
      else if (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid < 0) || (((*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0]))))).pid == 0)) {

 unsigned short flags = 0;
 {
# 792 "/Users/weugene/basilisk/src/grid/tree.h"

   if ((point.i+-1 >= 0 && point.i+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) &&
       (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]))))).pid == 0) && (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0])))).pid >= 0))
     flags |= face_x;
# 792 "/Users/weugene/basilisk/src/grid/tree.h"

   if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+-1 >= 0 && point.j+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) &&
       (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]))))).pid == 0) && (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1])))).pid >= 0))
     flags |= face_y;}
 if (flags)
   cache_append_face (point, flags);
 {
# 798 "/Users/weugene/basilisk/src/grid/tree.h"

   if ((point.i+1 >= 0 && point.i+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]))))).pid == 0) &&
       (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0])))).pid >= 0))
     cache_append_face ((Point) { point.i + 1, point.j + 0, point.level }, face_x);
# 798 "/Users/weugene/basilisk/src/grid/tree.h"

   if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+1 >= 0 && point.j+1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]))))).pid == 0) &&
       (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1])))).pid >= 0))
     cache_append_face ((Point) { point.i + 0, point.j + 1, point.level }, face_y);}
      }

      continue;

    }
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }


  cache_shrink (&q->leaves);
  cache_shrink (&q->faces);
  cache_shrink (&q->vertices);
  for (int l = 0; l <= (grid->depth); l++) {
    cache_level_shrink (&q->active[l]);
    cache_level_shrink (&q->prolongation[l]);
    cache_level_shrink (&q->boundary[l]);
    cache_level_shrink (&q->restriction[l]);
}

  q->dirty = 
# 820 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
            0
# 820 "/Users/weugene/basilisk/src/grid/tree.h"
                 ;


  for (int l = (grid->depth); l >= 0; l--)
     { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _boundary = ((Tree *)grid)->boundary[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = l; int _k; for (_k = 0; _k < _boundary.n; _k++) { point.i = _boundary.p[_k].i; point.j = _boundary.p[_k].j; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 824 "/Users/weugene/basilisk/src/grid/tree.h"

      (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags &= ~fboundary; } } } }; }}; }



  grid->n = q->leaves.n;


  grid->tn = grid->n;
  grid->maxdepth = grid->depth;

}
# 841 "/Users/weugene/basilisk/src/grid/tree.h"
# 863 "/Users/weugene/basilisk/src/grid/tree.h"
# 875 "/Users/weugene/basilisk/src/grid/tree.h"
# 880 "/Users/weugene/basilisk/src/grid/tree.h"
# 890 "/Users/weugene/basilisk/src/grid/tree.h"
# 898 "/Users/weugene/basilisk/src/grid/tree.h"
void reset (void * alist, double val)
{
  scalar * list = (scalar *) alist;
  Tree * q = ((Tree *)grid);

  for (int l = 0; l <= (grid->depth); l++) {
    Layer * L = q->L[l];
    for (int i = 0; i < L->len; i++)
      if (L->m[i])





 for (int j = 0; j < L->len; j++)
   if (L->m[i][j])

     if (list) for (scalar s = *list, *_i10 = list; ((scalar *)&s)->i >= 0; s = *++_i10)
       if (!((s).i >= 65536))
  ((double *)(L->m[i][j] + sizeof(Cell)))[s.i] = val;
# 926 "/Users/weugene/basilisk/src/grid/tree.h"
  }
}
# 936 "/Users/weugene/basilisk/src/grid/tree.h"


static void update_depth (int inc)
{
  Tree * q = ((Tree *)grid);
  grid->depth += inc;
  q->L = &(q->L[-1]);
  q->L = (Layer * *) realloc(q->L,(grid->depth + 2)*sizeof(Layer *));
  q->L = &(q->L[1]);
  if (inc > 0)
    q->L[grid->depth] = new_layer (grid->depth);
  { for (int i = 0; i <= (grid->depth) - inc; i++) free(q->active[i].p); free(q->active); q->active = ((CacheLevel *) calloc((grid->depth) + 1,sizeof(CacheLevel)));};
  { for (int i = 0; i <= (grid->depth) - inc; i++) free(q->prolongation[i].p); free(q->prolongation); q->prolongation = ((CacheLevel *) calloc((grid->depth) + 1,sizeof(CacheLevel)));};
  { for (int i = 0; i <= (grid->depth) - inc; i++) free(q->boundary[i].p); free(q->boundary); q->boundary = ((CacheLevel *) calloc((grid->depth) + 1,sizeof(CacheLevel)));};
  { for (int i = 0; i <= (grid->depth) - inc; i++) free(q->restriction[i].p); free(q->restriction); q->restriction = ((CacheLevel *) calloc((grid->depth) + 1,sizeof(CacheLevel)));};
}

static void alloc_children (Point point)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 954 "/Users/weugene/basilisk/src/grid/tree.h"

  if (point.level == grid->depth)
    update_depth (+1);
  else if ((level < (grid->depth) && point.i > 0 && point.i <= (1 << level) + 2 && point.j > 0 && point.j <= (1 << level) + 2 && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0][2*point.j-2 +0]))
    return;


  Layer * L = ((Tree *)grid)->L[point.level + 1];
  size_t len = sizeof(Cell) + datasize;
  char * b = (char *) mempool_alloc0 (L->pool);
  int nl = L->len - 2*2;
  int i = 2*point.i - 2;
  for (int k = 0; k < 2; k++, i++) {






    layer_add_row (L, i, 0);
    int j = 2*point.j - 2;
    for (int l = 0; l < 2; l++, j++) {
      
# 976 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
     (__builtin_expect(!(
# 976 "/Users/weugene/basilisk/src/grid/tree.h"
     !L->m[i][j]
# 976 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
     ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree.h", 976, 
# 976 "/Users/weugene/basilisk/src/grid/tree.h"
     "!L->m[i][j]"
# 976 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
     ) : (void)0)
# 976 "/Users/weugene/basilisk/src/grid/tree.h"
                         ;
      assign_periodic_y ((void **) L->m[i], j, nl, (void *) b);
      b += len;
    }
# 992 "/Users/weugene/basilisk/src/grid/tree.h"
  }

  int pid = (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid = pid;




  } } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
}
# 1021 "/Users/weugene/basilisk/src/grid/tree.h"
static void free_children (Point point)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 1022 "/Users/weugene/basilisk/src/grid/tree.h"


  Layer * L = ((Tree *)grid)->L[point.level + 1];
  int i = 2*point.i - 2, nl = L->len - 2*2;
  
# 1026 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
 (__builtin_expect(!(
# 1026 "/Users/weugene/basilisk/src/grid/tree.h"
 L->m[i][2*point.j - 2]
# 1026 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree.h", 1026, 
# 1026 "/Users/weugene/basilisk/src/grid/tree.h"
 "L->m[i][2*point.j - 2]"
# 1026 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
 ) : (void)0)
# 1026 "/Users/weugene/basilisk/src/grid/tree.h"
                                ;
  mempool_free (L->pool, L->m[i][2*point.j - 2]);
  for (int k = 0; k < 2; k++, i++) {
    int j = 2*point.j - 2;
    for (int l = 0; l < 2; l++, j++)
      assign_periodic_y ((void **) L->m[i], j, nl, 
# 1031 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                  ((void *)0)
# 1031 "/Users/weugene/basilisk/src/grid/tree.h"
                                                      );
    if (layer_remove_row (L, i, j)) {
      
# 1033 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
     (__builtin_expect(!(
# 1033 "/Users/weugene/basilisk/src/grid/tree.h"
     point.level + 1 == grid->depth
# 1033 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
     ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree.h", 1033, 
# 1033 "/Users/weugene/basilisk/src/grid/tree.h"
     "point.level + 1 == grid->depth"
# 1033 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
     ) : (void)0)
# 1033 "/Users/weugene/basilisk/src/grid/tree.h"
                                            ;
      update_depth (-1);
    }
  }
}
# 1061 "/Users/weugene/basilisk/src/grid/tree.h"
void increment_neighbors (Point point)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 1062 "/Users/weugene/basilisk/src/grid/tree.h"

  ((Tree *)grid)->dirty = 
# 1063 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                         1
# 1063 "/Users/weugene/basilisk/src/grid/tree.h"
                             ;
  if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors++ == 0)
    alloc_children (point);
   { { int _nn = 2/2 + 0 ? 2/2 + 0 : 2; int _i = point.i, _j = point.j; for (int _k = - _nn; _k <= _nn; _k++) { point.i = _i + _k; for (int _l = - _nn; _l <= _nn; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors++ == 0)
      alloc_children (point); } } point.i = _i; point.j = _j;}; }
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors--;
}

void decrement_neighbors (Point point)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 1073 "/Users/weugene/basilisk/src/grid/tree.h"

  ((Tree *)grid)->dirty = 
# 1074 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                         1
# 1074 "/Users/weugene/basilisk/src/grid/tree.h"
                             ;
   { { int _nn = 2/2 + 0 ? 2/2 + 0 : 2; int _i = point.i, _j = point.j; for (int _k = - _nn; _k <= _nn; _k++) { point.i = _i + _k; for (int _l = - _nn; _l <= _nn; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) {
      (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors--;
      if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors == 0)
 free_children (point);
    } } } point.i = _i; point.j = _j;}; }
  if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors) {
    int pid = (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid;
     { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
      (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags = 0;
      (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid = pid;
    } } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
  }
}

static void apply_periodic_elem (char ** m, int len)
{
  if (m) {
    int end = len - 2;
    for (int k = 0; k < 2; k++) {
      m[k] = m[k + end - 2];
      m[end + k] = m[k + 2];
    }
  }
}

static void apply_periodic (Tree * q)
{
# 1111 "/Users/weugene/basilisk/src/grid/tree.h"
  if (Period.y) {
    for (int i = 0; i < q->L[0]->len; i++)
      for (int j = 0; j < q->L[0]->len; j++)
 q->L[0]->m[i][j] = q->L[0]->m[i][2];
    for (int l = 1; l <= (grid->depth); l++) {
      Layer * L = q->L[l];
      for (int i = 0; i < L->len; i++)
 apply_periodic_elem (L->m[i], L->len);
    }
  }
# 1136 "/Users/weugene/basilisk/src/grid/tree.h"
}

void realloc_scalar (void)
{

  Tree * q = ((Tree *)grid);
  size_t newlen = sizeof(Cell) + datasize;
  size_t oldlen = newlen - sizeof(double);

  Layer * L = q->L[0];
  int len = L->len;
  for (int i = Period.x*2; i < len - Period.x*2; i++) {



    for (int j = Period.y*2; j < len - Period.y*2; j++) {

      L->m[i][j] = (char *) realloc(L->m[i][j],(newlen)*sizeof(char));




    }

  }

  for (int l = 1; l <= (grid->depth); l++) {
    Layer * L = q->L[l];
    int len = L->len;
    Mempool * oldpool = L->pool;
    L->pool = mempool_new (poolsize (l, newlen), (1 << 2)*newlen);
    for (int i = Period.x*2; i < len - Period.x*2; i += 2)
      if (L->m[i]) {
# 1177 "/Users/weugene/basilisk/src/grid/tree.h"
 for (int j = Period.y*2; j < len - Period.y*2; j += 2)
   if (L->m[i][j]) {

     char * new = (char *) mempool_alloc (L->pool);
     for (int k = 0; k < 2; k++)
       for (int o = 0; o < 2; o++) {
  
# 1183 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
 __builtin___memcpy_chk (
# 1183 "/Users/weugene/basilisk/src/grid/tree.h"
 new
# 1183 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
 , 
# 1183 "/Users/weugene/basilisk/src/grid/tree.h"
 L->m[i+k][j+o], oldlen
# 1183 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
 , __builtin_object_size (
# 1183 "/Users/weugene/basilisk/src/grid/tree.h"
 new
# 1183 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
 , 0))
# 1183 "/Users/weugene/basilisk/src/grid/tree.h"
                                     ;
  L->m[i+k][j+o] = new;
  new += newlen;
       }
# 1200 "/Users/weugene/basilisk/src/grid/tree.h"
   }

      }
    mempool_destroy (oldpool);
  }
  apply_periodic (q);
  check_periodic (q);
}
# 1226 "/Users/weugene/basilisk/src/grid/tree.h"
static inline void no_restriction (Point point, scalar s);

static 
# 1228 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
      _Bool 
# 1228 "/Users/weugene/basilisk/src/grid/tree.h"
           normal_neighbor (Point point, scalar * scalars, vector * vectors)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 1229 "/Users/weugene/basilisk/src/grid/tree.h"

  for (int k = 1; k <= 1; k++)
    {
# 1231 "/Users/weugene/basilisk/src/grid/tree.h"

      for (int i = -k; i <= k; i += 2*k)
 if (((point.i+i >= 0 && point.i+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0])))).pid < 0))) {
   Point neighbor = (Point) { point.i + i, point.j + 0, point.level };
   int id = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid - 1);
   if (scalars) for (scalar s = *scalars, *_i12 = scalars; ((scalar *)&s)->i >= 0; s = *++_i12)
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = _attribute[s.i].boundary[id](neighbor, point, s, 
# 1237 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                                    ((void *)0)
# 1237 "/Users/weugene/basilisk/src/grid/tree.h"
                                                                        );
   if (vectors) for (vector v = *vectors, *_i13 = vectors; ((scalar *)&v)->i >= 0; v = *++_i13) {
     scalar vn = v.x;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i] = _attribute[vn.i].boundary[id](neighbor, point, v.x, 
# 1240 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                                         ((void *)0)
# 1240 "/Users/weugene/basilisk/src/grid/tree.h"
                                                                             );

     scalar vt = v.y;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i] = _attribute[vt.i].boundary[id](neighbor, point, v.y, 
# 1243 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                                         ((void *)0)
# 1243 "/Users/weugene/basilisk/src/grid/tree.h"
                                                                             );





   }
   return 
# 1250 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
         1
# 1250 "/Users/weugene/basilisk/src/grid/tree.h"
             ;
 }
# 1231 "/Users/weugene/basilisk/src/grid/tree.h"

      for (int i = -k; i <= k; i += 2*k)
 if (((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+i >= 0 && point.j+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i])))).pid < 0))) {
   Point neighbor = (Point) { point.i + 0, point.j + i, point.level };
   int id = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid - 1);
   if (scalars) for (scalar s = *scalars, *_i12 = scalars; ((scalar *)&s)->i >= 0; s = *++_i12)
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = _attribute[s.i].boundary[id](neighbor, point, s, 
# 1237 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                                    ((void *)0)
# 1237 "/Users/weugene/basilisk/src/grid/tree.h"
                                                                        );
   if (vectors) for (vector v = *vectors, *_i13 = vectors; ((scalar *)&v)->i >= 0; v = *++_i13) {
     scalar vn = v.x;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i] = _attribute[vn.i].boundary[id](neighbor, point, v.y, 
# 1240 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                                         ((void *)0)
# 1240 "/Users/weugene/basilisk/src/grid/tree.h"
                                                                             );

     scalar vt = v.y;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i] = _attribute[vt.i].boundary[id](neighbor, point, v.x, 
# 1243 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                                         ((void *)0)
# 1243 "/Users/weugene/basilisk/src/grid/tree.h"
                                                                             );





   }
   return 
# 1250 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
         1
# 1250 "/Users/weugene/basilisk/src/grid/tree.h"
             ;
 }}
  return 
# 1252 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
        0
# 1252 "/Users/weugene/basilisk/src/grid/tree.h"
             ;
}

static 
# 1255 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
      _Bool 
# 1255 "/Users/weugene/basilisk/src/grid/tree.h"
           diagonal_neighbor_2D (Point point,
      scalar * scalars, vector * vectors)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 1257 "/Users/weugene/basilisk/src/grid/tree.h"


  for (int k = 1; k <= 1; k++)



      for (int i = -k; i <= k; i += 2*k)
 for (int j = -k; j <= k; j += 2*k)
   if ((point.i+i >= 0 && point.i+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i] && point.j+j >= 0 && point.j+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j]) && ((point.i+i >= 0 && point.i+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i] && point.j+j >= 0 && point.j+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j])))).pid < 0)) &&
       (point.i+i >= 0 && point.i+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) && ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0])))).pid < 0) &&
       (point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+j >= 0 && point.j+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j]) && ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j])))).pid < 0)) {
     Point n = (Point) { point.i + i, point.j + j, point.level },
       n1 = (Point) { point.i + i, point.j + 0, point.level }, n2 = (Point) { point.i + 0, point.j + j, point.level };
     int id1 = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0])))).pid - 1), id2 = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j])))).pid - 1);
     if (scalars) for (scalar s = *scalars, *_i14 = scalars; ((scalar *)&s)->i >= 0; s = *++_i14)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = (_attribute[s.i].boundary[id1](n,n1,s,
# 1272 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                           ((void *)0)
# 1272 "/Users/weugene/basilisk/src/grid/tree.h"
                                                               ) +
       _attribute[s.i].boundary[id2](n,n2,s,
# 1273 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                           ((void *)0)
# 1273 "/Users/weugene/basilisk/src/grid/tree.h"
                                               ) -
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j]) + sizeof(Cell)))[s.i]);
     if (vectors) for (vector v = *vectors, *_i15 = vectors; ((scalar *)&v)->i >= 0; v = *++_i15) {
       scalar vt = v.y, vn = v.x;
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i] = (_attribute[vt.i].boundary[id1](n,n1,v.x,
# 1277 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                                ((void *)0)
# 1277 "/Users/weugene/basilisk/src/grid/tree.h"
                                                                    ) +
         _attribute[vn.i].boundary[id2](n,n2,v.x,
# 1278 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                ((void *)0)
# 1278 "/Users/weugene/basilisk/src/grid/tree.h"
                                                    ) -
         ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j]) + sizeof(Cell)))[v.x.i]);
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i] = (_attribute[vn.i].boundary[id1](n,n1,v.y,
# 1280 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                                ((void *)0)
# 1280 "/Users/weugene/basilisk/src/grid/tree.h"
                                                                    ) +
         _attribute[vt.i].boundary[id2](n,n2,v.y,
# 1281 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                ((void *)0)
# 1281 "/Users/weugene/basilisk/src/grid/tree.h"
                                                    ) -
         ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j]) + sizeof(Cell)))[v.y.i]);






     }
     return 
# 1290 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
           1
# 1290 "/Users/weugene/basilisk/src/grid/tree.h"
               ;
   }

  return 
# 1293 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
        0
# 1293 "/Users/weugene/basilisk/src/grid/tree.h"
             ;
}

static 
# 1296 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
      _Bool 
# 1296 "/Users/weugene/basilisk/src/grid/tree.h"
           diagonal_neighbor_3D (Point point,
      scalar * scalars, vector * vectors)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 1298 "/Users/weugene/basilisk/src/grid/tree.h"
# 1340 "/Users/weugene/basilisk/src/grid/tree.h"
  return 
# 1340 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
        0
# 1340 "/Users/weugene/basilisk/src/grid/tree.h"
             ;
}
# 1344 "/Users/weugene/basilisk/src/grid/tree.h"

static Point tangential_neighbor_x (Point point, 
# 1345 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                _Bool 
# 1345 "/Users/weugene/basilisk/src/grid/tree.h"
                                                     * zn)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 1346 "/Users/weugene/basilisk/src/grid/tree.h"

  for (int k = 1; k <= 1; k++)
    for (int j = -k; j <= k; j += 2*k) {
      if (((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+j >= 0 && point.j+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j])))).pid < 0)) || ((point.i+-1 >= 0 && point.i+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1] && point.j+j >= 0 && point.j+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+j]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+j])))).pid < 0))) {
 *zn = 
# 1350 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
      0
# 1350 "/Users/weugene/basilisk/src/grid/tree.h"
           ;
 return (Point) { point.i + 0, point.j + j, point.level };
      }







    }
  return (Point){.level = -1};
}
# 1344 "/Users/weugene/basilisk/src/grid/tree.h"

static Point tangential_neighbor_y (Point point, 
# 1345 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                _Bool 
# 1345 "/Users/weugene/basilisk/src/grid/tree.h"
                                                     * zn)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 1346 "/Users/weugene/basilisk/src/grid/tree.h"

  for (int k = 1; k <= 1; k++)
    for (int j = -k; j <= k; j += 2*k) {
      if (((point.i+j >= 0 && point.i+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+0])))).pid < 0)) || ((point.i+j >= 0 && point.i+j < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j] && point.j+-1 >= 0 && point.j+-1 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+j][point.j+-1]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+j][point.j+-1])))).pid < 0))) {
 *zn = 
# 1350 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
      0
# 1350 "/Users/weugene/basilisk/src/grid/tree.h"
           ;
 return (Point) { point.i + j, point.j + 0, point.level };
      }







    }
  return (Point){.level = -1};
}


static inline 
# 1365 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
             _Bool 
# 1365 "/Users/weugene/basilisk/src/grid/tree.h"
                  is_boundary_point (Point point) { int ig = 0; (void)(ig); int jg = 0; (void)(jg); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 1365 "/Users/weugene/basilisk/src/grid/tree.h"

  return ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid < 0);
}

static void box_boundary_level (const Boundary * b, scalar * list, int l)
{
  ;
  scalar * scalars = 
# 1372 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                    ((void *)0)
# 1372 "/Users/weugene/basilisk/src/grid/tree.h"
                        ;
  vector * vectors = 
# 1373 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                    ((void *)0)
# 1373 "/Users/weugene/basilisk/src/grid/tree.h"
                        , * faces = 
# 1373 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                    ((void *)0)
# 1373 "/Users/weugene/basilisk/src/grid/tree.h"
                                        ;
  if (list) for (scalar s = *list, *_i16 = list; ((scalar *)&s)->i >= 0; s = *++_i16)
    if (!((s).i >= 65536) && _attribute[s.i].refine != no_restriction) {
      if (_attribute[s.i].v.x.i == s.i) {
 if (_attribute[s.i].face)
   faces = vectors_add (faces, _attribute[s.i].v);
 else
   vectors = vectors_add (vectors, _attribute[s.i].v);
      }
      else if (_attribute[s.i].v.x.i < 0 && _attribute[s.i].boundary[0])
 scalars = list_add (scalars, s);
    }

   { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _boundary = ((Tree *)grid)->boundary[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = l; int _k; for (_k = 0; _k < _boundary.n; _k++) { point.i = _boundary.p[_k].i; point.j = _boundary.p[_k].j; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 1386 "/Users/weugene/basilisk/src/grid/tree.h"
 {
    if (!normal_neighbor (point, scalars, vectors) &&
 !diagonal_neighbor_2D (point, scalars, vectors) &&
 !diagonal_neighbor_3D (point, scalars, vectors)) {

      if (scalars) for (scalar s = *scalars, *_i17 = scalars; ((scalar *)&s)->i >= 0; s = *++_i17)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = undefined;
      if (vectors) for (vector v = *vectors, *_i18 = vectors; ((scalar *)&v)->i >= 0; v = *++_i18)
 {
# 1394 "/Users/weugene/basilisk/src/grid/tree.h"

   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i] = undefined;
# 1394 "/Users/weugene/basilisk/src/grid/tree.h"

   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i] = undefined;}
    }
    if (faces) {
      int id = (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid - 1);
      {
# 1399 "/Users/weugene/basilisk/src/grid/tree.h"

 for (int i = -1; i <= 1; i += 2) {

   if (((point.i+i >= 0 && point.i+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0])))).pid < 0))) {
     Point neighbor = (Point) { point.i + i, point.j + 0, point.level };
     if (faces) for (vector v = *faces, *_i19 = faces; ((scalar *)&v)->i >= 0; v = *++_i19) {
       scalar vn = v.x;
       if (_attribute[vn.i].boundary[id])
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(i + 1)/2][point.j+0]) + sizeof(Cell)))[v.x.i] = _attribute[vn.i].boundary[id](neighbor, point, v.x, 
# 1407 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                                              ((void *)0)
# 1407 "/Users/weugene/basilisk/src/grid/tree.h"
                                                                                  );
     }
   }

   else if (i == -1) {

     
# 1413 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
    _Bool 
# 1413 "/Users/weugene/basilisk/src/grid/tree.h"
         zn;
     Point neighbor = tangential_neighbor_x (point, &zn);
     if (neighbor.level >= 0) {
       int id = is_boundary_point (neighbor) ?
  (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0])))).pid - 1) : (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid - 1);
       if (faces) for (vector v = *faces, *_i20 = faces; ((scalar *)&v)->i >= 0; v = *++_i20) {

  scalar vt = v.y;



  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i] = _attribute[vt.i].boundary[id](neighbor, point, v.x, 
# 1424 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                                      ((void *)0)
# 1424 "/Users/weugene/basilisk/src/grid/tree.h"
                                                                          );
       }
     }
     else

       if (faces) for (vector v = *faces, *_i21 = faces; ((scalar *)&v)->i >= 0; v = *++_i21)
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i] = 0.;
   }

 }
# 1399 "/Users/weugene/basilisk/src/grid/tree.h"

 for (int i = -1; i <= 1; i += 2) {

   if (((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+i >= 0 && point.j+i < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) && !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i])))).pid < 0))) {
     Point neighbor = (Point) { point.i + 0, point.j + i, point.level };
     if (faces) for (vector v = *faces, *_i19 = faces; ((scalar *)&v)->i >= 0; v = *++_i19) {
       scalar vn = v.x;
       if (_attribute[vn.i].boundary[id])
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+(i + 1)/2]) + sizeof(Cell)))[v.y.i] = _attribute[vn.i].boundary[id](neighbor, point, v.y, 
# 1407 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                                              ((void *)0)
# 1407 "/Users/weugene/basilisk/src/grid/tree.h"
                                                                                  );
     }
   }

   else if (i == -1) {

     
# 1413 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
    _Bool 
# 1413 "/Users/weugene/basilisk/src/grid/tree.h"
         zn;
     Point neighbor = tangential_neighbor_y (point, &zn);
     if (neighbor.level >= 0) {
       int id = is_boundary_point (neighbor) ?
  (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1])))).pid - 1) : (- (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid - 1);
       if (faces) for (vector v = *faces, *_i20 = faces; ((scalar *)&v)->i >= 0; v = *++_i20) {

  scalar vt = v.y;



  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i] = _attribute[vt.i].boundary[id](neighbor, point, v.y, 
# 1424 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                                                                      ((void *)0)
# 1424 "/Users/weugene/basilisk/src/grid/tree.h"
                                                                          );
       }
     }
     else

       if (faces) for (vector v = *faces, *_i21 = faces; ((scalar *)&v)->i >= 0; v = *++_i21)
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i] = 0.;
   }

 }}
    }
  } } } } }; }}; }

  free(scalars);
  free(vectors);
  free(faces);
  ;
}
# 1450 "/Users/weugene/basilisk/src/grid/tree.h"
static double masked_average (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 1451 "/Users/weugene/basilisk/src/grid/tree.h"

  double sum = 0., n = 0.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid < 0) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] != ((double)1e30))
      sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i], n++; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
  return n ? sum/n : ((double)1e30);
}
# 1459 "/Users/weugene/basilisk/src/grid/tree.h"

static double masked_average_x (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 1461 "/Users/weugene/basilisk/src/grid/tree.h"

  double sum = 0., n = 0.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if (child.x < 0 && (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid < 0) || !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0])))).pid < 0)) &&
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[s.i] != ((double)1e30))
      sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[s.i], n++; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
  return n ? sum/n : ((double)1e30);
}
# 1459 "/Users/weugene/basilisk/src/grid/tree.h"

static double masked_average_y (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 1461 "/Users/weugene/basilisk/src/grid/tree.h"

  double sum = 0., n = 0.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if (child.y < 0 && (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid < 0) || !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1])))).pid < 0)) &&
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[s.i] != ((double)1e30))
      sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[s.i], n++; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
  return n ? sum/n : ((double)1e30);
}

static void masked_boundary_restriction (const Boundary * b,
      scalar * list, int l)
{
  scalar * scalars = 
# 1473 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                    ((void *)0)
# 1473 "/Users/weugene/basilisk/src/grid/tree.h"
                        ;
  vector * faces = 
# 1474 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
                  ((void *)0)
# 1474 "/Users/weugene/basilisk/src/grid/tree.h"
                      ;
  if (list) for (scalar s = *list, *_i22 = list; ((scalar *)&s)->i >= 0; s = *++_i22)
    if (!((s).i >= 65536) && _attribute[s.i].refine != no_restriction) {
      if (_attribute[s.i].v.x.i == s.i && _attribute[s.i].face)
 faces = vectors_add (faces, _attribute[s.i].v);
      else
 scalars = list_add (scalars, s);
    }

   { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _cache = ((Tree *)grid)->restriction[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = l; int _k; for (_k = 0; _k < _cache.n; _k++) { point.i = _cache.p[_k].i; point.j = _cache.p[_k].j; ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 1483 "/Users/weugene/basilisk/src/grid/tree.h"
 {
    if (scalars) for (scalar s = *scalars, *_i23 = scalars; ((scalar *)&s)->i >= 0; s = *++_i23)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = masked_average (parent, s);
    if (faces) for (vector v = *faces, *_i24 = faces; ((scalar *)&v)->i >= 0; v = *++_i24)
      {
# 1487 "/Users/weugene/basilisk/src/grid/tree.h"
 {
 double average = masked_average_x (parent, v.x);
 if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0])))).pid < 0))
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i] = average;
 if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0])))).pid < 0))
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[v.x.i] = average;
      }
# 1487 "/Users/weugene/basilisk/src/grid/tree.h"
 {
 double average = masked_average_y (parent, v.y);
 if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1])))).pid < 0))
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i] = average;
 if (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1])))).pid < 0))
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[v.y.i] = average;
      }}
  } } } } }; }}; }

  free(scalars);
  free(faces);
}
# 1523 "/Users/weugene/basilisk/src/grid/tree.h"
static void free_cache (CacheLevel * c)
{
  for (int l = 0; l <= (grid->depth); l++)
    free(c[l].p);
  free(c);
}

void free_grid (void)
{
  if (!grid)
    return;
  free_boundaries();
  Tree * q = ((Tree *)grid);
  free(q->leaves.p);
  free(q->faces.p);
  free(q->vertices.p);
  free(q->refined.p);


  Layer * L = q->L[0];




  for (int i = Period.x*2; i < L->len - Period.x*2; i++) {
    for (int j = Period.y*2; j < L->len - Period.y*2; j++)
      free(L->m[i][j]);
    free(L->m[i]);
  }

  for (int l = 1; l <= (grid->depth); l++) {
    Layer * L = q->L[l];
    for (int i = Period.x*2; i < L->len - Period.x*2; i++)
      free(L->m[i]);
  }
# 1579 "/Users/weugene/basilisk/src/grid/tree.h"
  for (int l = 0; l <= (grid->depth); l++)
    destroy_layer (q->L[l]);
  q->L = &(q->L[-1]);
  free(q->L);
  free_cache (q->active);
  free_cache (q->prolongation);
  free_cache (q->boundary);
  free_cache (q->restriction);
  free(q);
  grid = 
# 1588 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
        ((void *)0)
# 1588 "/Users/weugene/basilisk/src/grid/tree.h"
            ;
}

static void refine_level (int depth);


void init_grid (int n)
{ ;

  
# 1597 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
 (__builtin_expect(!(
# 1597 "/Users/weugene/basilisk/src/grid/tree.h"
 sizeof(Cell) % 8 == 0
# 1597 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree.h", 1597, 
# 1597 "/Users/weugene/basilisk/src/grid/tree.h"
 "sizeof(Cell) % 8 == 0"
# 1597 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
 ) : (void)0)
# 1597 "/Users/weugene/basilisk/src/grid/tree.h"
                               ;

  free_grid();
  int depth = 0;
  while (n > 1) {
    if (n % 2) {
      fprintf (
# 1603 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
              __stderrp
# 1603 "/Users/weugene/basilisk/src/grid/tree.h"
                       , "tree: N must be a power-of-two\n");
      exit (1);
    }
    n /= 2;
    depth++;
  }
  Tree * q = ((Tree *) calloc(1,sizeof(Tree)));
  grid = (Grid *) q;
  grid->depth = 0;


  q->L = ((Layer * *) malloc((2)*sizeof(Layer *)));

  q->L[0] = 
# 1616 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
           ((void *)0)
# 1616 "/Users/weugene/basilisk/src/grid/tree.h"
               ; q->L = &(q->L[1]);

  Layer * L = new_layer (0);
  q->L[0] = L;
# 1635 "/Users/weugene/basilisk/src/grid/tree.h"
  for (int i = Period.x*2; i < L->len - Period.x*2; i++) {
    layer_add_row (L, i, 0);
    for (int j = Period.y*2; j < L->len - Period.y*2; j++)
      L->m[i][j] = (char *) calloc(1,sizeof(Cell) + datasize);
  }
  apply_periodic (q);
  (*((Cell *)(L->m[2][2]))).flags |= leaf;
  if (0 == 0)
    (*((Cell *)(L->m[2][2]))).flags |= active;
  for (int k = - 2*(1 - Period.x); k <= 2*(1 - Period.x); k++)
    for (int l = -2*(1 - Period.y); l <= 2*(1 - Period.y); l++)
      (*((Cell *)(L->m[2 +k][2 +l]))).pid = (k < 0 ? -1 - left :
         k > 0 ? -1 - right :
         l > 0 ? -1 - top :
         l < 0 ? -1 - bottom :
         0);
  (*((Cell *)(L->m[2][2]))).pid = 0;
# 1675 "/Users/weugene/basilisk/src/grid/tree.h"
  q->active = ((CacheLevel *) calloc(1,sizeof(CacheLevel)));
  q->prolongation = ((CacheLevel *) calloc(1,sizeof(CacheLevel)));
  q->boundary = ((CacheLevel *) calloc(1,sizeof(CacheLevel)));
  q->restriction = ((CacheLevel *) calloc(1,sizeof(CacheLevel)));
  q->dirty = 
# 1679 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
            1
# 1679 "/Users/weugene/basilisk/src/grid/tree.h"
                ;
  N = 1 << depth;





  Boundary * b = ((Boundary *) calloc(1,sizeof(Boundary)));
  b->level = box_boundary_level;
  b->restriction = masked_boundary_restriction;
  add_boundary (b);
  refine_level (depth);
  reset (all, 0.);
  { if (((Tree *)grid)->dirty) update_cache_f(); };
 ; }


void check_two_one (void)
{
   { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) { if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & active) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0)) {{
# 1698 "/Users/weugene/basilisk/src/grid/tree.h"

    if (level > 0)
      for (int k = -1; k <= 1; k++)
 for (int l = -1; l <= 1; l++) {

   int i = (point.i + 2)/2 + k;
   int j = (point.j + 2)/2 + l;
   double x = ((i - 2 + 0.5)*(1./(1 << point.level))*2. - 0.5);
   double y = ((j - 2 + 0.5)*(1./(1 << point.level))*2. - 0.5);
   if (x > -0.5 && x < 0.5 && y > -0.5 && y < 0.5 &&
       !((*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+k] [(point.j+2)/2+l])))).flags & active)) {
     FILE * fp = fopen("check_two_one_loc", "w");
     fprintf (fp,
       "# %d %d\n"
       "%g %g\n%g %g\n",
       k, l,
       (((point.i - 2) + 0.5)*(1./(1 << point.level)) - 0.5),
       (((point.j - 2) + 0.5)*(1./(1 << point.level)) - 0.5),
       x, y);
     fclose (fp);





     
# 1723 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
    (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree.h", 1723, 
# 1723 "/Users/weugene/basilisk/src/grid/tree.h"
    "false"
# 1723 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
    ) : (void)0)
# 1723 "/Users/weugene/basilisk/src/grid/tree.h"
                  ;
   }
 } } } continue; } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
}


struct _locate { double x, y, z; };

Point locate (struct _locate p)
{
  for (int l = (grid->depth); l >= 0; l--) {
    Point point = { .level = l };
    int n = 1 << point.level;
    point.i = (p.x - X0)/L0*n + 2;

    point.j = (p.y - Y0)/L0*n + 2;




    if (point.i >= 0 && point.i < n + 2*2

 && point.j >= 0 && point.j < n + 2*2




 ) {
      if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf))
 return point;
    }
    else
      break;
  }
  Point point = { .level = -1 };
  return point;
}




# 1763 "/Users/weugene/basilisk/src/grid/tree.h" 3 4
_Bool 
# 1763 "/Users/weugene/basilisk/src/grid/tree.h"
    tree_is_full()
{
  { if (((Tree *)grid)->dirty) update_cache_f(); };
  return (grid->tn == 1L << grid->maxdepth*2);
}
# 1 "grid/tree-common.h"
# 1 "/Users/weugene/basilisk/src/grid/tree-common.h"
# 1 "grid/multigrid-common.h"
# 1 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
# 1 "grid/cartesian-common.h"
# 1 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
# 1 "grid/events.h"
# 1 "/Users/weugene/basilisk/src/grid/events.h"







static void event_error (Event * ev, const char * s)
{
  fprintf (
# 10 "/Users/weugene/basilisk/src/grid/events.h" 3 4
          __stderrp
# 10 "/Users/weugene/basilisk/src/grid/events.h"
                   , "%s:%d: error: %s\n", ev->file, ev->line, s);
  exit (1);
}

static void init_event (Event * ev)
{
  if (ev->arrayi || ev->arrayt) {
    ev->i = ev->t = -1;
    if (ev->arrayi)
      ev->i = ev->arrayi[0];
    else
      ev->t = ev->arrayt[0];
    ev->a = 1;
    ev->expr[1] = 
# 23 "/Users/weugene/basilisk/src/grid/events.h" 3 4
                 ((void *)0)
# 23 "/Users/weugene/basilisk/src/grid/events.h"
                     ;
  }
  else {
    if (ev->nexpr > 0) {
      Expr init = 
# 27 "/Users/weugene/basilisk/src/grid/events.h" 3 4
                 ((void *)0)
# 27 "/Users/weugene/basilisk/src/grid/events.h"
                     , cond = 
# 27 "/Users/weugene/basilisk/src/grid/events.h" 3 4
                              ((void *)0)
# 27 "/Users/weugene/basilisk/src/grid/events.h"
                                  , inc = 
# 27 "/Users/weugene/basilisk/src/grid/events.h" 3 4
                                          ((void *)0)
# 27 "/Users/weugene/basilisk/src/grid/events.h"
                                              ;
      for (int j = 0; j < ev->nexpr; j++) {
 int i = -123456; double t = i;
 (* ev->expr[j]) (&i, &t, ev);
 if (i == -123456 && t == -123456) {

   if (cond)
     event_error (ev, "events can only use a single condition");
   cond = ev->expr[j];
 }
 else {

   int i1 = i; double t1 = t;
   (* ev->expr[j]) (&i1, &t1, ev);
   if (i1 == i && t1 == t) {


     if (init)
       event_error (ev, "events can only use a single initialisation");
     init = ev->expr[j];
   }
   else {

     if (inc)
       event_error (ev, "events can only use a single increment");
     inc = ev->expr[j];
   }
 }
      }
      ev->expr[0] = init;
      ev->expr[1] = cond;
      ev->expr[2] = inc;
      ev->nexpr = 0;
    }
    ev->i = ev->t = -1;
    if (ev->expr[0]) {
      (* ev->expr[0]) (&ev->i, &ev->t, ev);
      if (ev->i == 1234567890 || ev->t == 1234567890) {
 ev->i = 1234567890; ev->t = -1;
      }
    }
    else if (ev->expr[2]) {
      (* ev->expr[2]) (&ev->i, &ev->t, ev);
      if (ev->i != -1)
 ev->i = 0;
      if (ev->t != -1)
 ev->t = 0;
    }
  }
}

enum { event_done, event_alive, event_stop };

static int event_finished (Event * ev)
{
  ev->t = ev->i = -1;
  return event_done;
}

void event_register (Event event) {
  
# 87 "/Users/weugene/basilisk/src/grid/events.h" 3 4
 (__builtin_expect(!(
# 87 "/Users/weugene/basilisk/src/grid/events.h"
 Events
# 87 "/Users/weugene/basilisk/src/grid/events.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/events.h", 87, 
# 87 "/Users/weugene/basilisk/src/grid/events.h"
 "Events"
# 87 "/Users/weugene/basilisk/src/grid/events.h" 3 4
 ) : (void)0)
# 87 "/Users/weugene/basilisk/src/grid/events.h"
                ;
  
# 88 "/Users/weugene/basilisk/src/grid/events.h" 3 4
 (__builtin_expect(!(
# 88 "/Users/weugene/basilisk/src/grid/events.h"
 !event.last
# 88 "/Users/weugene/basilisk/src/grid/events.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/events.h", 88, 
# 88 "/Users/weugene/basilisk/src/grid/events.h"
 "!event.last"
# 88 "/Users/weugene/basilisk/src/grid/events.h" 3 4
 ) : (void)0)
# 88 "/Users/weugene/basilisk/src/grid/events.h"
                     ;
  int n = 0, parent = -1;
  for (Event * ev = Events; !ev->last; ev++) {
    if (!strcmp (event.name, ev->name)) {
      
# 92 "/Users/weugene/basilisk/src/grid/events.h" 3 4
     (__builtin_expect(!(
# 92 "/Users/weugene/basilisk/src/grid/events.h"
     parent < 0
# 92 "/Users/weugene/basilisk/src/grid/events.h" 3 4
     ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/events.h", 92, 
# 92 "/Users/weugene/basilisk/src/grid/events.h"
     "parent < 0"
# 92 "/Users/weugene/basilisk/src/grid/events.h" 3 4
     ) : (void)0)
# 92 "/Users/weugene/basilisk/src/grid/events.h"
                        ;
      parent = n;
    }
    n++;
  }
  if (parent < 0) {
    Events = (Event *) realloc(Events,(n + 2)*sizeof(Event));
    Events[n] = event;
    Events[n].next = 
# 100 "/Users/weugene/basilisk/src/grid/events.h" 3 4
                    ((void *)0)
# 100 "/Users/weugene/basilisk/src/grid/events.h"
                        ;
    Events[n + 1].last = 
# 101 "/Users/weugene/basilisk/src/grid/events.h" 3 4
                        1
# 101 "/Users/weugene/basilisk/src/grid/events.h"
                            ;
    init_event (&Events[n]);
  }
  else {
    Event * ev = ((Event *) calloc(1,sizeof(Event)));
    *ev = Events[parent];
    Events[parent] = event;
    Events[parent].next = ev;
    init_event (&Events[parent]);
  }
}

static int event_cond (Event * ev, int i, double t)
{
  if (!ev->expr[1])
    return 
# 116 "/Users/weugene/basilisk/src/grid/events.h" 3 4
          1
# 116 "/Users/weugene/basilisk/src/grid/events.h"
              ;
  return (* ev->expr[1]) (&i, &t, ev);
}
# 131 "/Users/weugene/basilisk/src/grid/events.h"
static int event_do (Event * ev, 
# 131 "/Users/weugene/basilisk/src/grid/events.h" 3 4
                                _Bool 
# 131 "/Users/weugene/basilisk/src/grid/events.h"
                                     action)
{
  if ((iter > ev->i && t > ev->t) || !event_cond (ev, iter, t))
    return event_finished (ev);
  if (iter == ev->i || fabs (t - ev->t) <= 1e-9) {
    if (action) {
      
# 137 "/Users/weugene/basilisk/src/grid/events.h" 3 4
     _Bool 
# 137 "/Users/weugene/basilisk/src/grid/events.h"
          finished = 
# 137 "/Users/weugene/basilisk/src/grid/events.h" 3 4
                     0
# 137 "/Users/weugene/basilisk/src/grid/events.h"
                          ;
      for (Event * e = ev; e; e = e->next) {



 if ((* e->action) (iter, t, e))
   finished = 
# 143 "/Users/weugene/basilisk/src/grid/events.h" 3 4
             1
# 143 "/Users/weugene/basilisk/src/grid/events.h"
                 ;
      }
      if (finished) {
 event_finished (ev);
 return event_stop;
      }
    }
    if (ev->arrayi) {
      ev->i = ev->arrayi[ev->a++];
      if (ev->i < 0)
 return event_finished (ev);
    }
    if (ev->arrayt) {
      ev->t = ev->arrayt[ev->a++];
      if (ev->t < 0)
 return event_finished (ev);
    }
    else if (ev->expr[2]) {
      int i0 = ev->i;
      (* ev->expr[2]) (&ev->i, &ev->t, ev);
      if (i0 == -1 && ev->i != i0)
 ev->i += iter + 1;
      if (!event_cond (ev, iter + 1, ev->t))
 return event_finished (ev);
    }
    else if (ev->expr[0] && !ev->expr[1])
      return event_finished (ev);
  }
  return event_alive;
}

static void end_event_do (
# 174 "/Users/weugene/basilisk/src/grid/events.h" 3 4
                         _Bool 
# 174 "/Users/weugene/basilisk/src/grid/events.h"
                              action)
{




  for (Event * ev = Events; !ev->last; ev++)
    if (ev->i == 1234567890 && action)
      for (Event * e = ev; e; e = e->next) {



 e->action (iter, t, e);
      }
}

int events (
# 190 "/Users/weugene/basilisk/src/grid/events.h" 3 4
           _Bool 
# 190 "/Users/weugene/basilisk/src/grid/events.h"
                action)
{





  if (iter == 0)
    for (Event * ev = Events; !ev->last; ev++)
      init_event (ev);

  int cond = 0, cond1 = 0;
  inext = 1234567890; tnext = ((double)1e30);
  for (Event * ev = Events; !ev->last && !cond; ev++)
    if (ev->i != 1234567890 &&
 (ev->expr[1] || (ev->expr[0] && !ev->expr[1] && !ev->expr[2]) || ev->arrayi || ev->arrayt))
      cond = 1;
  for (Event * ev = Events; !ev->last; ev++) {
    int status = event_do (ev, action);
    if (status == event_stop) {
      end_event_do (action);
      return 0;
    }
    if (status == event_alive && ev->i != 1234567890 &&
 (ev->expr[1] || (ev->expr[0] && !ev->expr[1] && !ev->expr[2]) || ev->arrayi || ev->arrayt))
      cond1 = 1;
    if (ev->t > t && ev->t < tnext)
      tnext = ev->t;
    if (ev->i > iter && ev->i < inext)
      inext = ev->i;
  }
  if ((!cond || cond1) && (tnext != ((double)1e30) || inext != 1234567890)) {
    inext = iter + 1;
    return 1;
  }
  end_event_do (action);
  return 0;
}

void event (const char * name)
{
  for (Event * ev = Events; !ev->last; ev++)
    if (!strcmp (ev->name, name))
      for (Event * e = ev; e; e = e->next) {



 (* e->action) (0, 0, e);
      }
}

double dtnext (double dt)
{
  if (tnext != ((double)1e30) && tnext > t) {
    unsigned int n = (tnext - t)/dt;
    
# 245 "/Users/weugene/basilisk/src/grid/events.h" 3 4
   (__builtin_expect(!(
# 245 "/Users/weugene/basilisk/src/grid/events.h"
   n < 0x7fffffff
# 245 "/Users/weugene/basilisk/src/grid/events.h" 3 4
   ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/events.h", 245, 
# 245 "/Users/weugene/basilisk/src/grid/events.h"
   "n < INT_MAX"
# 245 "/Users/weugene/basilisk/src/grid/events.h" 3 4
   ) : (void)0)
# 245 "/Users/weugene/basilisk/src/grid/events.h"
                       ;
    if (n == 0)
      dt = tnext - t;
    else {
      double dt1 = (tnext - t)/n;
      if (dt1 > dt + 1e-9)
 dt = (tnext - t)/(n + 1);
      else if (dt1 < dt)
 dt = dt1;
      tnext = t + dt;
    }
  }
  else
    tnext = t + dt;
  return dt;
}
# 2 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

void (* debug) (Point);
# 32 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
# 1 "grid/fpe.h"
# 1 "/Users/weugene/basilisk/src/grid/fpe.h"



# 1 "/usr/include/unistd.h" 1 3 4
# 72 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/sys/unistd.h" 1 3 4
# 84 "/usr/include/sys/unistd.h" 3 4
# 1 "/usr/include/sys/_types/_posix_vdisable.h" 1 3 4
# 85 "/usr/include/sys/unistd.h" 2 3 4
# 122 "/usr/include/sys/unistd.h" 3 4
# 1 "/usr/include/sys/_types/_seek_set.h" 1 3 4
# 123 "/usr/include/sys/unistd.h" 2 3 4
# 202 "/usr/include/sys/unistd.h" 3 4
# 1 "/usr/include/sys/_types/_gid_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_gid_t.h" 3 4

# 31 "/usr/include/sys/_types/_gid_t.h" 3 4
typedef __darwin_gid_t gid_t;
# 203 "/usr/include/sys/unistd.h" 2 3 4




int faccessat(int, const char *, int, int) ;
int fchownat(int, const char *, uid_t, gid_t, int) ;
int linkat(int, const char *, int, const char *, int) ;
ssize_t readlinkat(int, const char *, char *, size_t) ;
int symlinkat(const char *, int, const char *) ;
int unlinkat(int, const char *, int) ;


# 73 "/usr/include/unistd.h" 2 3 4
# 83 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/sys/_types/_useconds_t.h" 1 3 4
# 31 "/usr/include/sys/_types/_useconds_t.h" 3 4
typedef __darwin_useconds_t useconds_t;
# 84 "/usr/include/unistd.h" 2 3 4
# 428 "/usr/include/unistd.h" 3 4

void _exit(int) __attribute__((noreturn));
int access(const char *, int);
unsigned int
  alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);

int close(int) __asm("_" "close" );

int dup(int);
int dup2(int, int);
int execl(const char * __path, const char * __arg0, ...) ;
int execle(const char * __path, const char * __arg0, ...) ;
int execlp(const char * __file, const char * __arg0, ...) ;
int execv(const char * __path, char * const * __argv) ;
int execve(const char * __file, char * const * __argv, char * const * __envp) ;
int execvp(const char * __file, char * const * __argv) ;
pid_t fork(void) ;
long fpathconf(int, int);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);



int getgroups(int, gid_t []);

char *getlogin(void);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
int isatty(int);
int link(const char *, const char *);
off_t lseek(int, off_t, int);
long pathconf(const char *, int);

int pause(void) __asm("_" "pause" );

int pipe(int [2]);

ssize_t read(int, void *, size_t) __asm("_" "read" );

int rmdir(const char *);
int setgid(gid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
int setuid(uid_t);

unsigned int
  sleep(unsigned int) __asm("_" "sleep" );

long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
char *ttyname(int);


int ttyname_r(int, char *, size_t) __asm("_" "ttyname_r" );




int unlink(const char *);

ssize_t write(int __fd, const void * __buf, size_t __nbyte) __asm("_" "write" );

# 505 "/usr/include/unistd.h" 3 4

size_t confstr(int, char *, size_t) __asm("_" "confstr" );

int getopt(int, char * const [], const char *) __asm("_" "getopt" );

extern char *optarg;
extern int optind, opterr, optopt;

# 530 "/usr/include/unistd.h" 3 4

# 542 "/usr/include/unistd.h" 3 4
char *crypt(const char *, const char *);






void encrypt(char *, int) __asm("_" "encrypt" );



int fchdir(int);
long gethostid(void);
pid_t getpgid(pid_t);
pid_t getsid(pid_t);
# 570 "/usr/include/unistd.h" 3 4
int lchown(const char *, uid_t, gid_t) __asm("_" "lchown" );

int lockf(int, int, off_t) __asm("_" "lockf" );

int nice(int) __asm("_" "nice" );

ssize_t pread(int __fd, void * __buf, size_t __nbyte, off_t __offset) __asm("_" "pread" );

ssize_t pwrite(int __fd, const void * __buf, size_t __nbyte, off_t __offset) __asm("_" "pwrite" );
# 591 "/usr/include/unistd.h" 3 4
pid_t setpgrp(void) __asm("_" "setpgrp" );




int setregid(gid_t, gid_t) __asm("_" "setregid" );

int setreuid(uid_t, uid_t) __asm("_" "setreuid" );

void swab(const void * restrict, void * restrict, ssize_t);
void sync(void);
int truncate(const char *, off_t);
useconds_t ualarm(useconds_t, useconds_t);
int usleep(useconds_t) __asm("_" "usleep" );
pid_t vfork(void) ;


int fsync(int) __asm("_" "fsync" );

int ftruncate(int, off_t);
int getlogin_r(char *, size_t);

# 623 "/usr/include/unistd.h" 3 4

int fchown(int, uid_t, gid_t);
int gethostname(char *, size_t);
ssize_t readlink(const char * restrict, char * restrict, size_t);
int setegid(gid_t);
int seteuid(uid_t);
int symlink(const char *, const char *);

# 5 "/Users/weugene/basilisk/src/grid/fpe.h" 2


# 6 "/Users/weugene/basilisk/src/grid/fpe.h"
static int gdb()
{
  if (last_point.level >= 0) {
    debug (last_point);
    fputc ('\n', 
# 10 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
                __stderrp
# 10 "/Users/weugene/basilisk/src/grid/fpe.h"
                         );
    fflush (
# 11 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
           __stderrp
# 11 "/Users/weugene/basilisk/src/grid/fpe.h"
                    );
  }
  char command[80];
  
# 14 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
 __builtin___sprintf_chk (
# 14 "/Users/weugene/basilisk/src/grid/fpe.h"
 command
# 14 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
 , 0, __builtin_object_size (
# 14 "/Users/weugene/basilisk/src/grid/fpe.h"
 command
# 14 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
 , 2 > 1 ? 1 : 0), 
# 14 "/Users/weugene/basilisk/src/grid/fpe.h"
 "exec xterm -e 'gdb -p %d' & xterm -e 'gnuplot plot -'", getpid()
# 14 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
 )
             
# 15 "/Users/weugene/basilisk/src/grid/fpe.h"
            ;
  return system (command);
}

static void caught_abort (int sig)
{
  fprintf (
# 21 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
          __stderrp
# 21 "/Users/weugene/basilisk/src/grid/fpe.h"
                   , "Caught signal %d (Aborted)\n", sig);
  gdb();
}

static void caught_fpe (int sig)
{
  fprintf (
# 27 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
          __stderrp
# 27 "/Users/weugene/basilisk/src/grid/fpe.h"
                   , "Caught signal %d (Floating Point Exception)\n", sig);
  gdb();
  exit (1);
}

static void caught_segfault (int sig)
{
  fprintf (
# 34 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
          __stderrp
# 34 "/Users/weugene/basilisk/src/grid/fpe.h"
                   , "Caught signal %d (Segmentation Fault)\n", sig);
  gdb();
  exit (2);
}

void catch_fpe (void)
{
  struct sigaction act;
  act.
# 42 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
     __sigaction_u.__sa_handler 
# 42 "/Users/weugene/basilisk/src/grid/fpe.h"
                = caught_fpe;
  
# 43 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
 (*(
# 43 "/Users/weugene/basilisk/src/grid/fpe.h"
 &act.sa_mask
# 43 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
 ) = 0, 0)
# 43 "/Users/weugene/basilisk/src/grid/fpe.h"
                           ;
  act.sa_flags = 0;
  last_point.level = -1;
  sigaction (8, &act, 
# 46 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
                     ((void *)0)
# 46 "/Users/weugene/basilisk/src/grid/fpe.h"
                         );
  act.
# 47 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
     __sigaction_u.__sa_handler 
# 47 "/Users/weugene/basilisk/src/grid/fpe.h"
                = caught_segfault;
  sigaction (11, &act, 
# 48 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
                      ((void *)0)
# 48 "/Users/weugene/basilisk/src/grid/fpe.h"
                          );
  act.
# 49 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
     __sigaction_u.__sa_handler 
# 49 "/Users/weugene/basilisk/src/grid/fpe.h"
                = caught_abort;
  act.sa_flags = 
# 50 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
                0x0004
# 50 "/Users/weugene/basilisk/src/grid/fpe.h"
                            ;
  sigaction (6, &act, 
# 51 "/Users/weugene/basilisk/src/grid/fpe.h" 3 4
                     ((void *)0)
# 51 "/Users/weugene/basilisk/src/grid/fpe.h"
                         );
}
# 35 "/Users/weugene/basilisk/src/grid/cartesian-common.h"



scalar new_scalar (const char * name)
{
  int nvar = datasize/sizeof(double);
  scalar s;
  for (s.i = 0; s.i < nvar; s.i++)
    if (!list_lookup (all, s)) {
      init_scalar (s, name);
      ;
      all = list_append (all, s);
      return s;
    }


  
# 51 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
 (__builtin_expect(!(
# 51 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 nvar < 65536
# 51 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/cartesian-common.h", 51, 
# 51 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 "nvar < _NVARMAX"
# 51 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
 ) : (void)0)
# 51 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                         ;
  datasize += sizeof(double); nvar++;
  _attribute = (_Attributes *) realloc(_attribute,(nvar)*sizeof(_Attributes));
  
# 54 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
 __builtin___memset_chk (
# 54 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 &_attribute[nvar-1]
# 54 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
 , 
# 54 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 0, sizeof (_Attributes)
# 54 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
 , __builtin_object_size (
# 54 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 &_attribute[nvar-1]
# 54 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
 , 0))
# 54 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                                      ;
  s = (scalar){nvar - 1};
  realloc_scalar();
  init_scalar (s, name);
  ;
  all = list_append (all, s);
  return s;
}

scalar new_vertex_scalar (const char * name)
{
  return init_vertex_scalar (new_scalar (name), name);
}

static vector alloc_vector (const char * name)
{
  vector v;
  char cname[strlen(name) + 3];
  struct { char * x, * y, * z; } ext = {"%s.x", "%s.y", "%s.z"};
  {
# 73 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   __builtin___sprintf_chk (
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   cname
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 0, __builtin_object_size (
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   cname
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 2 > 1 ? 1 : 0), 
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   ext.x, name
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   )
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                               ;
    v.x = new_scalar (cname);
  }
# 73 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   __builtin___sprintf_chk (
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   cname
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 0, __builtin_object_size (
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   cname
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 2 > 1 ? 1 : 0), 
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   ext.y, name
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   )
# 74 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                               ;
    v.y = new_scalar (cname);
  }}
  return v;
}

vector new_vector (const char * name)
{
  vector v = alloc_vector (name);
  init_vector (v, 
# 83 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                 ((void *)0)
# 83 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                     );
  return v;
}

vector new_face_vector (const char * name)
{
  vector v = alloc_vector (name);
  init_face_vector (v, 
# 90 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                      ((void *)0)
# 90 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                          );
  return v;
}

tensor new_tensor (const char * name)
{
  char cname[strlen(name) + 3];
  struct { char * x, * y, * z; } ext = {"%s.x", "%s.y", "%s.z"};
  tensor t;
  {
# 99 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   __builtin___sprintf_chk (
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   cname
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 0, __builtin_object_size (
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   cname
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 2 > 1 ? 1 : 0), 
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   ext.x, name
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   )
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                               ;
    t.x = new_vector (cname);
  }
# 99 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   __builtin___sprintf_chk (
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   cname
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 0, __builtin_object_size (
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   cname
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 2 > 1 ? 1 : 0), 
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   ext.y, name
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   )
# 100 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                               ;
    t.y = new_vector (cname);
  }}
  init_tensor (t, 
# 103 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                 ((void *)0)
# 103 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                     );
  return t;
}

tensor new_symmetric_tensor (const char * name)
{
  char cname[strlen(name) + 5];
  struct { char * x, * y, * z; } ext = {"%s.x.x", "%s.y.y", "%s.z.z"};
  tensor t;
  {
# 112 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   __builtin___sprintf_chk (
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   cname
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 0, __builtin_object_size (
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   cname
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 2 > 1 ? 1 : 0), 
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   ext.x, name
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   )
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                               ;
    t.x.x = new_scalar(cname);
  }
# 112 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   __builtin___sprintf_chk (
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   cname
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 0, __builtin_object_size (
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   cname
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 2 > 1 ? 1 : 0), 
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   ext.y, name
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   )
# 113 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                               ;
    t.y.y = new_scalar(cname);
  }}

    
# 117 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   __builtin___sprintf_chk (
# 117 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   cname
# 117 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 0, __builtin_object_size (
# 117 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   cname
# 117 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 2 > 1 ? 1 : 0), 
# 117 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   "%s.x.y", name
# 117 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   )
# 117 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                  ;
    t.x.y = new_scalar(cname);
    t.y.x = t.x.y;
# 132 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
  init_tensor (t, 
# 132 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                 ((void *)0)
# 132 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                     );
  return t;
}

static int nconst = 0;

void init_const_scalar (scalar s, const char * name, double val)
{
  if (s.i - 65536 >= nconst) {
    nconst = s.i - 65536 + 1;
    _constant = (double *) realloc(_constant,(nconst)*sizeof(double));
  }
  _constant[s.i - 65536] = val;
}

scalar new_const_scalar (const char * name, int i, double val)
{
  scalar s = (scalar){i + 65536};
  init_const_scalar (s, name, val);
  return s;
}

void init_const_vector (vector v, const char * name, double * val)
{
  {
# 156 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    init_const_scalar (v.x, name, *val++);
# 156 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    init_const_scalar (v.y, name, *val++);}
}

vector new_const_vector (const char * name, int i, double * val)
{
  vector v;
  {
# 163 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    v.x.i = 65536 + i++;
# 163 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    v.y.i = 65536 + i++;}
  init_const_vector (v, name, val);
  return v;
}

void scalar_clone (scalar a, scalar b)
{
  char * name = _attribute[a.i].name;
  double (** boundary) (Point, Point, scalar, void *) = _attribute[a.i].boundary;
  double (** boundary_homogeneous) (Point, Point, scalar, void *) =
    _attribute[a.i].boundary_homogeneous;
  _attribute[a.i] = _attribute[b.i];
  _attribute[a.i].name = name;
  _attribute[a.i].boundary = boundary;
  _attribute[a.i].boundary_homogeneous = boundary_homogeneous;
  for (int i = 0; i < nboundary; i++) {
    _attribute[a.i].boundary[i] = _attribute[b.i].boundary[i];
    _attribute[a.i].boundary_homogeneous[i] = _attribute[b.i].boundary_homogeneous[i];
  }
}

scalar * list_clone (scalar * l)
{
  scalar * list = 
# 187 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                 ((void *)0)
# 187 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                     ;
  int nvar = datasize/sizeof(double), map[nvar];
  for (int i = 0; i < nvar; i++)
    map[i] = -1;
  if (l) for (scalar s = *l, *_i25 = l; ((scalar *)&s)->i >= 0; s = *++_i25) {
    scalar c = new_scalar("c");
    scalar_clone (c, s);
    map[s.i] = c.i;
    list = list_append (list, c);
  }
  if (list) for (scalar s = *list, *_i26 = list; ((scalar *)&s)->i >= 0; s = *++_i26)
    {
# 198 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      if (_attribute[s.i].v.x.i >= 0 && map[_attribute[s.i].v.x.i] >= 0)
 _attribute[s.i].v.x.i = map[_attribute[s.i].v.x.i];
# 198 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      if (_attribute[s.i].v.y.i >= 0 && map[_attribute[s.i].v.y.i] >= 0)
 _attribute[s.i].v.y.i = map[_attribute[s.i].v.y.i];}
  return list;
}

void delete (scalar * list)
{
  if (all == 
# 206 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
            ((void *)0)
# 206 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                )
    return;

  if (list) for (scalar f = *list, *_i27 = list; ((scalar *)&f)->i >= 0; f = *++_i27) {
    if (_attribute[f.i].delete)
      _attribute[f.i].delete (f);
    free(_attribute[f.i].name); _attribute[f.i].name = 
# 212 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                                                                                   ((void *)0)
# 212 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                                                                       ;
    free(_attribute[f.i].boundary); _attribute[f.i].boundary = 
# 213 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                                                                                           ((void *)0)
# 213 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                                                                               ;
    free(_attribute[f.i].boundary_homogeneous); _attribute[f.i].boundary_homogeneous = 
# 214 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                                                                                                                   ((void *)0)
# 214 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                                                                                                       ;
  }

  if (list == all) {
    all[0].i = -1;
    return;
  }

  ;
  if (list) for (scalar f = *list, *_i28 = list; ((scalar *)&f)->i >= 0; f = *++_i28) {
    scalar * s = all;
    for (; s->i >= 0 && s->i != f.i; s++);
    if (s->i == f.i)
      for (; s->i >= 0; s++)
 s[0] = s[1];
  }
}

typedef void (* free_solver_func) (void);

static Array * free_solver_funcs = 
# 234 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                                  ((void *)0)
# 234 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                      ;

void free_solver_func_add (free_solver_func func)
{
  if (!free_solver_funcs)
    free_solver_funcs = array_new();
  array_append (free_solver_funcs, &func, sizeof(free_solver_func));
}

void free_solver()
{
  if (free_solver_funcs) {
    free_solver_func * a = (free_solver_func *) free_solver_funcs->p;
    for (int i = 0; i < free_solver_funcs->len/sizeof(free_solver_func); i++)
      a[i] ();
    array_free (free_solver_funcs);
  }

  delete (all);
  free(all); all = 
# 253 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                                               ((void *)0)
# 253 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                                   ;
  for (Event * ev = Events; !ev->last; ev++) {
    Event * e = ev->next;
    while (e) {
      Event * next = e->next;
      free(e);
      e = next;
    }
  }

  free(Events); Events = 
# 263 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                                                     ((void *)0)
# 263 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                                         ;
  free(_attribute); _attribute = 
# 264 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                                                             ((void *)0)
# 264 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                                                 ;
  free(_constant); _constant = 
# 265 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                                                           ((void *)0)
# 265 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                                               ;
  free_grid();
  qpclose_all();
# 277 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
}



void (* boundary_level) (scalar *, int l);
void (* boundary_flux) (vector *);


void boundary (scalar * list)
{ ;
  if (list == 
# 287 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
             ((void *)0)
# 287 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                 )
    { ; ; return; }
  vector * listf = 
# 289 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                  ((void *)0)
# 289 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                      ;
  if (list) for (scalar s = *list, *_i29 = list; ((scalar *)&s)->i >= 0; s = *++_i29)
    if (!((s).i >= 65536) && _attribute[s.i].face)
      listf = vectors_add (listf, _attribute[s.i].v);
  if (listf) {
    boundary_flux (listf);
    free(listf);
  }
  boundary_level (list, -1);
 ; }

void cartesian_boundary_level (scalar * list, int l)
{
  { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, l); };
}

void cartesian_boundary_flux (vector * list)
{

}

static double symmetry (Point point, Point neighbor, scalar s, void * data)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 311 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

  return ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i];
}

static double antisymmetry (Point point, Point neighbor, scalar s, void * data)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 316 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

  return -((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i];
}

double (* default_scalar_bc[]) (Point, Point, scalar, void *) = {
  symmetry, symmetry, symmetry, symmetry, symmetry, symmetry
};

scalar cartesian_init_scalar (scalar s, const char * name)
{

  char * pname;
  if (name) {
    free(_attribute[s.i].name);
    pname = strdup(name);
  }
  else
    pname = _attribute[s.i].name;
  free(_attribute[s.i].boundary);
  free(_attribute[s.i].boundary_homogeneous);

  _attribute[s.i] = (const _Attributes){0};
  _attribute[s.i].name = pname;

  _attribute[s.i].boundary = (double (**)(Point, Point, scalar, void *))
    malloc(nboundary*sizeof (void (*)()));
  _attribute[s.i].boundary_homogeneous = (double (**)(Point, Point, scalar, void *))
    malloc(nboundary*sizeof (void (*)()));
  for (int b = 0; b < nboundary; b++)
    _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b] =
      b < 2*2 ? default_scalar_bc[b] : symmetry;
  _attribute[s.i].gradient = 
# 347 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                            ((void *)0)
# 347 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                ;
  {
# 348 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    _attribute[s.i].d.x = 0;
    _attribute[s.i].v.x.i = -1;
  }
# 348 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    _attribute[s.i].d.y = 0;
    _attribute[s.i].v.y.i = -1;
  }}
  _attribute[s.i].face = 
# 352 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                        0
# 352 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                             ;
  return s;
}

scalar cartesian_init_vertex_scalar (scalar s, const char * name)
{
  {
# 358 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    _attribute[s.i].d.x = -1;
# 358 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    _attribute[s.i].d.y = -1;}
  for (int d = 0; d < nboundary; d++)
    _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = 
# 361 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                                                                           ((void *)0)
# 361 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                                                               ;
  return s;
}

double (* default_vector_bc[]) (Point, Point, scalar, void *) = {
  antisymmetry, antisymmetry,
  antisymmetry, antisymmetry,
  antisymmetry, antisymmetry
};

vector cartesian_init_vector (vector v, const char * name)
{
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
  {
# 374 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    if (name) {
      char cname[strlen(name) + 3];
      
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     __builtin___sprintf_chk (
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
     cname
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     , 0, __builtin_object_size (
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
     cname
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     , 2 > 1 ? 1 : 0), 
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
     "%s%s", name, ext.x
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     )
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                         ;
      init_scalar (v.x, cname);
    }
    else
      init_scalar (v.x, 
# 381 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                       ((void *)0)
# 381 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                           );
    _attribute[v.x.i].v = v;
  }
# 374 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    if (name) {
      char cname[strlen(name) + 3];
      
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     __builtin___sprintf_chk (
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
     cname
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     , 0, __builtin_object_size (
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
     cname
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     , 2 > 1 ? 1 : 0), 
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
     "%s%s", name, ext.y
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     )
# 377 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                         ;
      init_scalar (v.y, cname);
    }
    else
      init_scalar (v.y, 
# 381 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                       ((void *)0)
# 381 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                           );
    _attribute[v.y.i].v = v;
  }}

  for (int d = 0; d < nboundary; d++)
    _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] =
      d < 2*2 ? default_vector_bc[d] : antisymmetry;
  return v;
}

vector cartesian_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_vector (v, name);
  {
# 394 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    _attribute[v.x.i].d.x = -1;
    _attribute[v.x.i].face = 
# 396 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                            1
# 396 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                ;
  }
# 394 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    _attribute[v.y.i].d.y = -1;
    _attribute[v.y.i].face = 
# 396 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                            1
# 396 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                ;
  }}
  for (int d = 0; d < nboundary; d++)
    _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] = 
# 399 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                                                                               ((void *)0)
# 399 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                                                                   ;
  return v;
}

tensor cartesian_init_tensor (tensor t, const char * name)
{
  struct { char * x, * y, * z; } ext = {".x", ".y", ".z"};
  {
# 406 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    if (name) {
      char cname[strlen(name) + 3];
      
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     __builtin___sprintf_chk (
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
     cname
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     , 0, __builtin_object_size (
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
     cname
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     , 2 > 1 ? 1 : 0), 
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
     "%s%s", name, ext.x
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     )
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                         ;
      init_vector (t.x, cname);
    }
    else
      init_vector (t.x, 
# 413 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                       ((void *)0)
# 413 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                           );
  }
# 406 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    if (name) {
      char cname[strlen(name) + 3];
      
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     __builtin___sprintf_chk (
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
     cname
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     , 0, __builtin_object_size (
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
     cname
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     , 2 > 1 ? 1 : 0), 
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
     "%s%s", name, ext.y
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
     )
# 409 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                         ;
      init_vector (t.y, cname);
    }
    else
      init_vector (t.y, 
# 413 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                       ((void *)0)
# 413 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                           );
  }}






    for (int b = 0; b < nboundary; b++) {
      _attribute[t.x.x.i].boundary[b] = _attribute[t.y.x.i].boundary[b] =
 _attribute[t.x.x.i].boundary_homogeneous[b] = _attribute[t.y.y.i].boundary_homogeneous[b] =
 b < 2*2 ? default_scalar_bc[b] : symmetry;
      _attribute[t.x.y.i].boundary[b] = _attribute[t.y.y.i].boundary[b] =
 _attribute[t.x.y.i].boundary_homogeneous[b] = _attribute[t.y.x.i].boundary_homogeneous[b] =
 b < 2*2 ? default_vector_bc[b] : antisymmetry;
    }



  return t;
}

struct OutputCells {
  FILE * fp;
  coord c;
  double size;
};

void output_cells (struct OutputCells p)
{
  if (!p.fp) p.fp = 
# 443 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                   __stdoutp
# 443 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                            ;
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 444 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 {
    
# 445 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   _Bool 
# 445 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
        inside = 
# 445 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                 1
# 445 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                     ;
    coord o = {x,y,z};
    {
# 447 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      if (inside && p.size > 0. &&
   (o.x > p.c.x + p.size || o.x < p.c.x - p.size))
 inside = 
# 450 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
         0
# 450 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
              ;
# 447 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

      if (inside && p.size > 0. &&
   (o.y > p.c.y + p.size || o.y < p.c.y - p.size))
 inside = 
# 450 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
         0
# 450 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
              ;}
    if (inside) {
      Delta /= 2.;



      fprintf (p.fp, "%g %g\n%g %g\n%g %g\n%g %g\n%g %g\n\n",
        x - Delta, y - Delta,
        x - Delta, y + Delta,
        x + Delta, y + Delta,
        x + Delta, y - Delta,
        x - Delta, y - Delta);
# 476 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
    }
  } } } } }; }
  fflush (p.fp);
}
# 488 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
static char * replace_ (const char * vname)
{
  char * name = strdup(vname), * c = name;
  while (*c != '\0') {
    if (*c == '.')
      *c = '_';
    c++;
  }
  return name;
}

static void debug_plot (FILE * fp, const char * name, const char * cells,
   const char * stencil)
{
  char * vname = replace_ (name);
  fprintf (fp,
    "  load 'debug.plot'\n"
    "  v=%s\n"




    "  plot '%s' w l lc 0, "
    "'%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 1 title columnhead(3+3*v)",





    vname, cells, stencil);
  free(vname);
}

void cartesian_debug (Point point)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 522 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

  char name[80] = "cells";
  if (0 > 0)
    
# 525 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   __builtin___sprintf_chk (
# 525 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   name
# 525 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 0, __builtin_object_size (
# 525 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   name
# 525 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 2 > 1 ? 1 : 0), 
# 525 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   "cells-%d", 0
# 525 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   )
# 525 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                    ;
  FILE * fp = fopen (name, "w");
  output_cells ((struct OutputCells){fp, (coord){x,y,z}, 4.*Delta});
  fclose (fp);

  char stencil[80] = "stencil";
  if (0 > 0)
    
# 532 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   __builtin___sprintf_chk (
# 532 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   stencil
# 532 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 0, __builtin_object_size (
# 532 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   stencil
# 532 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   , 2 > 1 ? 1 : 0), 
# 532 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   "stencil-%d", 0
# 532 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   )
# 532 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                         ;
  fp = fopen (stencil, "w");
  if (all) for (scalar v = *all, *_i30 = all; ((scalar *)&v)->i >= 0; v = *++_i30)



    fprintf (fp, "x y %s ", _attribute[v.i].name);



  fputc ('\n', fp);
# 555 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
    for (int k = -2; k <= 2; k++)
      for (int l = -2; l <= 2; l++) {
 if (all) for (scalar v = *all, *_i31 = all; ((scalar *)&v)->i >= 0; v = *++_i31) {
   fprintf (fp, "%g %g ",
     x + k*Delta + _attribute[v.i].d.x*Delta/2.,
     y + l*Delta + _attribute[v.i].d.y*Delta/2.);
   if ((point.i+k >= 0 && point.i+k < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+k] && point.j+l >= 0 && point.j+l < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+k][point.j+l]))
     fprintf (fp, "%g ", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+k][point.j+l]) + sizeof(Cell)))[v.i]);
   else
     fputs ("n/a ", fp);
 }
 fputc ('\n', fp);
      }
# 585 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
  fclose (fp);

  fp = fopen ("debug.plot", "w");
  fprintf (fp,
    "set term x11\n"
    "set size ratio -1\n"
    "set key outside\n");
  if (all) for (scalar s = *all, *_i32 = all; ((scalar *)&s)->i >= 0; s = *++_i32) {
    char * name = replace_ (_attribute[s.i].name);
    fprintf (fp, "%s = %d\n", name, s.i);
    free(name);
  }
  fclose (fp);

  fprintf (
# 599 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
          __stderrp
# 599 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                   , "Last point stencils can be displayed using (in gnuplot)\n");
  debug_plot (
# 600 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
             __stderrp
# 600 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                      , _attribute[0].name, name, stencil);
  fflush (
# 601 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
         __stderrp
# 601 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                  );

  fp = fopen ("plot", "w");
  debug_plot (fp, _attribute[0].name, name, stencil);
  fclose (fp);
}

void cartesian_methods()
{
  init_scalar = cartesian_init_scalar;
  init_vertex_scalar = cartesian_init_vertex_scalar;
  init_vector = cartesian_init_vector;
  init_tensor = cartesian_init_tensor;
  init_face_vector = cartesian_init_face_vector;
  boundary_level = cartesian_boundary_level;
  boundary_flux = cartesian_boundary_flux;
  debug = cartesian_debug;
}

struct _interpolate {
  scalar v;
  double x, y, z;
};

static double interpolate_linear (Point point, struct _interpolate p)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 626 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

  scalar v = p.v;







  x = (p.x - x)/Delta - _attribute[v.i].d.x/2.;
  y = (p.y - y)/Delta - _attribute[v.i].d.y/2.;
  int i = ((x) > 0 ? 1 : -1), j = ((y) > 0 ? 1 : -1);
  x = fabs(x); y = fabs(y);

  return ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.i]*(1. - x) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[v.i]*x)*(1. - y) +
   (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+j]) + sizeof(Cell)))[v.i]*(1. - x) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j]) + sizeof(Cell)))[v.i]*x)*y);
# 654 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
}


double interpolate (struct _interpolate p)
{ ;
  Point point = locate ((struct _locate){p.x, p.y, p.z}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 659 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

  if (point.level < 0)
    { double _ret = ((double)1e30); ; return _ret; }
  { double _ret = interpolate_linear (point, p); ; return _ret; }
 ; }


void interpolate_array (scalar * list, coord * a, int n, double * v, 
# 666 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                                                                    _Bool 
# 666 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                                                         linear)
{ ;
  int j = 0;
  for (int i = 0; i < n; i++) {
    Point point = locate ((struct _locate){a[i].x, a[i].y, a[i].z}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 670 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

    if (point.level >= 0) {
      if (list) for (scalar s = *list, *_i33 = list; ((scalar *)&s)->i >= 0; s = *++_i33)
 v[j++] = !linear ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] :
   interpolate_linear (point,
         (struct _interpolate){s, a[i].x, a[i].y, a[i].z});
    }
    else
      if (list) for (scalar s = *list, *_i34 = list; ((scalar *)&s)->i >= 0; s = *++_i34)
 v[j++] = ((double)1e30);
  }
# 689 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
 ; }



typedef int bid;

bid new_bid()
{
  int b = nboundary++;
  if (all) for (scalar s = *all, *_i35 = all; ((scalar *)&s)->i >= 0; s = *++_i35) {
    _attribute[s.i].boundary = (double (**)(Point, Point, scalar, void *))
      realloc(_attribute[s.i].boundary,nboundary*sizeof (void (*)()));
    _attribute[s.i].boundary_homogeneous = (double (**)(Point, Point, scalar, void *))
      realloc(_attribute[s.i].boundary_homogeneous,nboundary*sizeof (void (*)()));
  }
  if (all) for (scalar s = *all, *_i36 = all; ((scalar *)&s)->i >= 0; s = *++_i36) {
    if (_attribute[s.i].v.x.i < 0)
      _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b] = symmetry;
    else if (_attribute[s.i].v.x.i == s.i) {
      vector v = _attribute[s.i].v;
      {
# 709 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

 _attribute[v.y.i].boundary[b] = _attribute[v.y.i].boundary_homogeneous[b] = symmetry;
# 709 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

 _attribute[v.x.i].boundary[b] = _attribute[v.x.i].boundary_homogeneous[b] = symmetry;}
      _attribute[v.x.i].boundary[b] = _attribute[v.x.i].boundary_homogeneous[b] =
 _attribute[v.x.i].face ? 
# 712 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                         ((void *)0) 
# 712 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                              : antisymmetry;
    }
  }
  return b;
}



static double periodic_bc (Point point, Point neighbor, scalar s, void * data)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 721 "/Users/weugene/basilisk/src/grid/cartesian-common.h"

  return ((double)1e30);
}

static void periodic_boundary (int d)
{

  if (all) for (scalar s = *all, *_i37 = all; ((scalar *)&s)->i >= 0; s = *++_i37)
    _attribute[s.i].boundary[d] = _attribute[s.i].boundary_homogeneous[d] = periodic_bc;

  if (all) for (scalar s = *all, *_i38 = all; ((scalar *)&s)->i >= 0; s = *++_i38)
    if (_attribute[s.i].face) {
      vector v = _attribute[s.i].v;
      _attribute[v.x.i].boundary[d] = _attribute[v.x.i].boundary_homogeneous[d] = 
# 734 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                                                                                 ((void *)0)
# 734 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                                                                                     ;
    }

  default_scalar_bc[d] = periodic_bc;
  default_vector_bc[d] = periodic_bc;
}

void periodic (int dir)
{



    
# 746 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   (__builtin_expect(!(
# 746 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   dir <= bottom
# 746 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/cartesian-common.h", 746, 
# 746 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
   "dir <= bottom"
# 746 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
   ) : (void)0)
# 746 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                         ;




  int c = dir/2;
  periodic_boundary (2*c);
  periodic_boundary (2*c + 1);
  (&Period.x)[c] = 
# 754 "/Users/weugene/basilisk/src/grid/cartesian-common.h" 3 4
                  1
# 754 "/Users/weugene/basilisk/src/grid/cartesian-common.h"
                      ;
}
# 4 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
# 24 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
void (* restriction) (scalar *);

static inline void restriction_average (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 27 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  double sum = 0.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i]; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = sum/(1 << 2);
}

static inline void restriction_volume_average (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 35 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

if (!((cm).i >= 65536)) {
# 35 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  double sum = 0.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i]; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = sum/(1 << 2)/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i] + 1e-30);
 }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 35 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  double sum = 0.;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    sum += _const_cm*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i]; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
  ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = sum/(1 << 2)/(_const_cm + 1e-30);
 }}

static inline void face_average (Point point, vector v)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 43 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  {
# 44 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 {




      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0]) + sizeof(Cell)))[v.x.i] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1]) + sizeof(Cell)))[v.x.i])/2.;
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[v.x.i] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +0]) + sizeof(Cell)))[v.x.i] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +1]) + sizeof(Cell)))[v.x.i])/2.;






  }
# 44 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 {




      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0]) + sizeof(Cell)))[v.y.i] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0]) + sizeof(Cell)))[v.y.i])/2.;
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[v.y.i] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +2]) + sizeof(Cell)))[v.y.i] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +2]) + sizeof(Cell)))[v.y.i])/2.;






  }}
}

static inline void restriction_face (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 61 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  face_average (point, _attribute[s.i].v);
}

static inline void restriction_vertex (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 66 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  for (int i = 0; i <= 1; i++) {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[s.i] = ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] [2*point.j-2 +0]) + sizeof(Cell)))[s.i];

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[s.i] = ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] [2*point.j-2 +2]) + sizeof(Cell)))[s.i];





  }
}

static inline void no_restriction (Point point, scalar s) { int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 78 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
}

static inline void no_data (Point point, scalar s) { int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 81 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = ((double)1e30); } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
}

void wavelet (scalar s, scalar w)
{
  restriction (((scalar []){s,{-1}}));
  for (int l = (grid->depth) - 1; l >= 0; l--) {
     { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 90 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 {
       { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i]; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
      _attribute[s.i].prolongation (point, s);
       { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
        double sp = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i];
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.i];

        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.i] -= sp;
      } } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
    } } } } } }; }}; }
    boundary_level (((scalar []){w,{-1}}), l + 1);
  }

   { { if (0 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[0]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = 0; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 104 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i]; } } } }; }}; }
  boundary_level (((scalar []){w,{-1}}), 0);
}

void inverse_wavelet (scalar s, scalar w)
{
   { { if (0 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[0]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = 0; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 111 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.i]; } } } }; }}; }
  boundary_level (((scalar []){s,{-1}}), 0);
  for (int l = 0; l <= (grid->depth) - 1; l++) {
     { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 115 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 {
      _attribute[s.i].prolongation (point, s);
       { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.i]; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
    } } } } } }; }}; }
    boundary_level (((scalar []){s,{-1}}), l + 1);
  }
}

static inline double bilinear (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 125 "/Users/weugene/basilisk/src/grid/multigrid-common.h"




    return (9.*((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0]) + sizeof(Cell)))[s.i] +
     3.*(((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+child.x] [(point.j+2)/2+0]) + sizeof(Cell)))[s.i] + ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+child.y]) + sizeof(Cell)))[s.i]) +
     ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+child.x] [(point.j+2)/2+child.y]) + sizeof(Cell)))[s.i])/16.;
# 140 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
}

static inline void refine_bilinear (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 143 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = bilinear (point, s); } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
}

static inline double quadratic (double a, double b, double c)
{
  return (30.*a + 5.*b - 3.*c)/32.;
}

static inline double biquadratic (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 154 "/Users/weugene/basilisk/src/grid/multigrid-common.h"




  return
    quadratic (quadratic (((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0]) + sizeof(Cell)))[s.i],
     ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+child.x] [(point.j+2)/2+0]) + sizeof(Cell)))[s.i],
     ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+-child.x] [(point.j+2)/2+0]) + sizeof(Cell)))[s.i]),
        quadratic (((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+child.y]) + sizeof(Cell)))[s.i],
     ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+child.x] [(point.j+2)/2+child.y]) + sizeof(Cell)))[s.i],
     ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+-child.x] [(point.j+2)/2+child.y]) + sizeof(Cell)))[s.i]),
        quadratic (((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+-child.y]) + sizeof(Cell)))[s.i],
     ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+child.x] [(point.j+2)/2+-child.y]) + sizeof(Cell)))[s.i],
     ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+-child.x] [(point.j+2)/2+-child.y]) + sizeof(Cell)))[s.i]));




}

static inline double biquadratic_vertex (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 175 "/Users/weugene/basilisk/src/grid/multigrid-common.h"




  return (36.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] + 18.*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[s.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[s.i]) - 6.*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[s.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[s.i]) +
   9.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[s.i] - 3.*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[s.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[s.i]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[s.i])/64.;




}

static inline void refine_biquadratic (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 188 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = biquadratic (point, s); } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
}

static inline void refine_linear (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 194 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

if (!((cm).i >= 65536)) {
# 194 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  coord g;
  if (_attribute[s.i].gradient)
    {
# 197 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.x = _attribute[s.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[s.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[s.i]);
# 197 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.y = _attribute[s.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[s.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[s.i]);}
  else
    {
# 200 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.x = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[s.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[s.i])/2.;
# 200 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.y = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[s.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[s.i])/2.;}

  double sc = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i], cmc = 4.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i], sum = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i]*(1 << 2);
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = sc;
    {
# 206 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] += child.x*g.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-child.x][point.j+0]) + sizeof(Cell)))[cm.i]/cmc;
# 206 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] += child.y*g.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-child.y]) + sizeof(Cell)))[cm.i]/cmc;}
    sum -= ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i];
  } } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
  
# 210 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
 (__builtin_expect(!(
# 210 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 fabs(sum) < 1e-10
# 210 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/multigrid-common.h", 210, 
# 210 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 "fabs(sum) < 1e-10"
# 210 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
 ) : (void)0)
# 210 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
                           ;
 }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 194 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  coord g;
  if (_attribute[s.i].gradient)
    {
# 197 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.x = _attribute[s.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[s.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[s.i]);
# 197 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.y = _attribute[s.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[s.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[s.i]);}
  else
    {
# 200 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.x = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[s.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[s.i])/2.;
# 200 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      g.y = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[s.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[s.i])/2.;}

  double sc = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i], cmc = 4.*_const_cm, sum = _const_cm*(1 << 2);
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = sc;
    {
# 206 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] += child.x*g.x*_const_cm/cmc;
# 206 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] += child.y*g.y*_const_cm/cmc;}
    sum -= _const_cm;
  } } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
  
# 210 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
 (__builtin_expect(!(
# 210 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 fabs(sum) < 1e-10
# 210 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/multigrid-common.h", 210, 
# 210 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 "fabs(sum) < 1e-10"
# 210 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
 ) : (void)0)
# 210 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
                           ;
 }}

static inline void refine_reset (Point point, scalar v)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 214 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.i] = 0.; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
}

static inline void refine_injection (Point point, scalar v)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 220 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  double val = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.i];
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.i] = val; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
}

static scalar multigrid_init_scalar (scalar s, const char * name)
{
  s = cartesian_init_scalar (s, name);
  _attribute[s.i].prolongation = refine_bilinear;
  _attribute[s.i].restriction = restriction_average;
  return s;
}

static scalar multigrid_init_vertex_scalar (scalar s, const char * name)
{
  s = cartesian_init_vertex_scalar (s, name);
  _attribute[s.i].restriction = restriction_vertex;
  return s;
}

static vector multigrid_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_face_vector (v, name);
  {
# 244 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

    _attribute[v.y.i].restriction = no_restriction;
# 244 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

    _attribute[v.x.i].restriction = no_restriction;}
  _attribute[v.x.i].restriction = restriction_face;
  return v;
}

void multigrid_debug (Point point)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 251 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

  cartesian_debug (point);

  FILE * plot = fopen ("plot", "a");
  if (point.level > 0) {
    char name[80] = "coarse";
    if (0 > 0)
      
# 258 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
     __builtin___sprintf_chk (
# 258 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
     name
# 258 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
     , 0, __builtin_object_size (
# 258 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
     name
# 258 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
     , 2 > 1 ? 1 : 0), 
# 258 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
     "coarse-%d", 0
# 258 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
     )
# 258 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
                                       ;
    FILE * fp = fopen (name, "w");
# 271 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
      double xc = x - child.x*Delta/2., yc = y - child.y*Delta/2.;
      for (int k = 0; k <= 1; k++)
 for (int l = 0; l <= 1; l++) {
   if (all) for (scalar v = *all, *_i39 = all; ((scalar *)&v)->i >= 0; v = *++_i39)
     fprintf (fp, "%g %g %g ",
       xc + k*child.x*Delta*2. + _attribute[v.i].d.x*Delta,
       yc + l*child.y*Delta*2. + _attribute[v.i].d.y*Delta,
       ((double *) ((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+k*child.x] [(point.j+2)/2+l*child.y]) + sizeof(Cell)))[v.i]);
   fputc ('\n', fp);
 }
      fprintf (
# 281 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
              __stderrp
# 281 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
                       , ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 3 t ''", name);
      fprintf (plot, ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 3 t ''", name);
# 302 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
    fclose (fp);
  }

  if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).neighbors > 0)) {
    char name[80] = "fine";
    if (0 > 0)
      
# 308 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
     __builtin___sprintf_chk (
# 308 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
     name
# 308 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
     , 0, __builtin_object_size (
# 308 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
     name
# 308 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
     , 2 > 1 ? 1 : 0), 
# 308 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
     "fine-%d", 0
# 308 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
     )
# 308 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
                                     ;
    FILE * fp = fopen (name, "w");
# 324 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
      double xf = x - Delta/4., yf = y - Delta/4.;
      for (int k = -2; k <= 3; k++)
 for (int l = -2; l <= 3; l++) {
   if (all) for (scalar v = *all, *_i40 = all; ((scalar *)&v)->i >= 0; v = *++_i40) {
     fprintf (fp, "%g %g ",
       xf + k*Delta/2. + _attribute[v.i].d.x*Delta/4.,
       yf + l*Delta/2. + _attribute[v.i].d.y*Delta/4.);
     if ((level < (grid->depth) && point.i > 0 && point.i <= (1 << level) + 2 && point.j > 0 && point.j <= (1 << level) + 2 && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +k] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +k][2*point.j-2 +l]))
       fprintf (fp, "%g ", ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +k] [2*point.j-2 +l]) + sizeof(Cell)))[v.i]);
     else
       fputs ("n/a ", fp);
   }
   fputc ('\n', fp);
 }
      fprintf (
# 338 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
              __stderrp
# 338 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
                       , ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 2 t ''", name);
      fprintf (plot, ", '%s' u 1+3*v:2+3*v:3+3*v w labels tc lt 2 t ''", name);
# 362 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
    fclose (fp);
  }
  fflush (
# 364 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
         __stderrp
# 364 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
                  );
  fclose (plot);
}

static void multigrid_restriction (scalar * list)
{
  scalar * listdef = 
# 370 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
                    ((void *)0)
# 370 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
                        , * listc = 
# 370 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
                                    ((void *)0)
# 370 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
                                        , * list2 = 
# 370 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
                                                    ((void *)0)
# 370 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
                                                        ;
  if (list) for (scalar s = *list, *_i41 = list; ((scalar *)&s)->i >= 0; s = *++_i41)
    if (!((s).i >= 65536)) {
      if (_attribute[s.i].restriction == restriction_average) {
 listdef = list_add (listdef, s);
 list2 = list_add (list2, s);
      }
      else if (_attribute[s.i].restriction != no_restriction) {
 listc = list_add (listc, s);
 if (_attribute[s.i].face)
   {
# 380 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

     list2 = list_add (list2, _attribute[s.i].v.x);
# 380 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

     list2 = list_add (list2, _attribute[s.i].v.y);}
 else
   list2 = list_add (list2, s);
      }
    }

  if (listdef || listc) {
    for (int l = (grid->depth) - 1; l >= 0; l--) {
       { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 389 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 {
 if (listdef) for (scalar s = *listdef, *_i42 = listdef; ((scalar *)&s)->i >= 0; s = *++_i42)
   restriction_average (point, s);
 if (listc) for (scalar s = *listc, *_i43 = listc; ((scalar *)&s)->i >= 0; s = *++_i43)
   _attribute[s.i].restriction (point, s);
      } } } } } }; }}; }
      { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list2, l); };
    }
    free(listdef);
    free(listc);
    free(list2);
  }
}

void multigrid_methods()
{
  cartesian_methods();
  debug = multigrid_debug;
  init_scalar = multigrid_init_scalar;
  init_vertex_scalar = multigrid_init_vertex_scalar;
  init_face_vector = multigrid_init_face_vector;
  restriction = multigrid_restriction;
}







void subtree_size (scalar size, 
# 419 "/Users/weugene/basilisk/src/grid/multigrid-common.h" 3 4
                               _Bool 
# 419 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
                                    leaves)
{




   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 425 "/Users/weugene/basilisk/src/grid/multigrid-common.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[size.i] = 1; } } } }; }





  { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, ((scalar []){size,{-1}}), (grid->depth)); };
  for (int l = (grid->depth) - 1; l >= 0; l--) {
     { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 434 "/Users/weugene/basilisk/src/grid/multigrid-common.h"
 {
      double sum = !leaves;
       { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[size.i]; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[size.i] = sum;
    } } } } } }; }}; }
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, ((scalar []){size,{-1}}), l); };
  }
}
# 5 "/Users/weugene/basilisk/src/grid/tree-common.h"
# 21 "/Users/weugene/basilisk/src/grid/tree-common.h"
int refine_cell (Point point, scalar * list, int flag, Cache * refined)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 22 "/Users/weugene/basilisk/src/grid/tree-common.h"

  int nr = 0;


  if (level > 0)
    for (int k = 0; k != 2*child.x; k += child.x)

      for (int l = 0; l != 2*child.y; l += child.y)




   if ((*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+k] [(point.j+2)/2+l])))).pid >= 0 && (((*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+k] [(point.j+2)/2+l]))))).flags & leaf)) {
     Point p = point;


     p.level = point.level - 1;
     p.i = (point.i + 2)/2 + k;
     do { if (p.i < 2) p.i += 1 << p.level; else if (p.i >= 2 + (1 << p.level)) p.i -= 1 << p.level; } while(0);

       p.j = (point.j + 2)/2 + l;
       do { if (p.j < 2) p.j += 1 << p.level; else if (p.j >= 2 + (1 << p.level)) p.j -= 1 << p.level; } while(0);





     nr += refine_cell (p, list, flag, refined);
     (*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+k] [(point.j+2)/2+l])))).flags |= flag;
   }



  increment_neighbors (point);

  int cflag = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & active) ? (active|leaf) : leaf;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags |= cflag; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }


  if (list) for (scalar s = *list, *_i44 = list; ((scalar *)&s)->i >= 0; s = *++_i44)
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0) || _attribute[s.i].face)
      _attribute[s.i].refine (point, s);


  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags &= ~leaf;
# 91 "/Users/weugene/basilisk/src/grid/tree-common.h"
  return nr;
}






# 98 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
_Bool 
# 98 "/Users/weugene/basilisk/src/grid/tree-common.h"
    coarsen_cell (Point point, scalar * list)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 99 "/Users/weugene/basilisk/src/grid/tree-common.h"




  int pid = (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid;
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors || ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid < 0 && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid != pid))
      return 
# 106 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
            0
# 106 "/Users/weugene/basilisk/src/grid/tree-common.h"
                 ; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }



  if (list) for (scalar s = *list, *_i45 = list; ((scalar *)&s)->i >= 0; s = *++_i45) {
    _attribute[s.i].restriction (point, s);
    if (_attribute[s.i].coarsen)
      _attribute[s.i].coarsen (point, s);
  }


  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags |= leaf;


  decrement_neighbors (point);
# 133 "/Users/weugene/basilisk/src/grid/tree-common.h"
  return 
# 133 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
        1
# 133 "/Users/weugene/basilisk/src/grid/tree-common.h"
            ;
}

void coarsen_cell_recursive (Point point, scalar * list)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 137 "/Users/weugene/basilisk/src/grid/tree-common.h"



   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
    if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors)
       { { int _nn = 1 + 0 ? 1 + 0 : 2; int _i = point.i, _j = point.j; for (int _k = - _nn; _k <= _nn; _k++) { point.i = _i + _k; for (int _l = - _nn; _l <= _nn; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid >= 0))
   coarsen_cell_recursive (point, list); } } point.i = _i; point.j = _j;}; } } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }

  
# 146 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
 (__builtin_expect(!(
# 146 "/Users/weugene/basilisk/src/grid/tree-common.h"
 coarsen_cell (point, list)
# 146 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree-common.h", 146, 
# 146 "/Users/weugene/basilisk/src/grid/tree-common.h"
 "coarsen_cell (point, list)"
# 146 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
 ) : (void)0)
# 146 "/Users/weugene/basilisk/src/grid/tree-common.h"
                                    ;
}

void mpi_boundary_refine (scalar *);
void mpi_boundary_coarsen (int, int);
void mpi_boundary_update (scalar *);

typedef struct {
  int nc, nf;
} astats;

struct Adapt {
  scalar * slist;
  double * max;
  int maxlevel;
  int minlevel;
  scalar * list;
};


astats adapt_wavelet (struct Adapt p)
{ ;
  if (p.list == 
# 168 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
               ((void *)0)
# 168 "/Users/weugene/basilisk/src/grid/tree-common.h"
                   )
    p.list = all;
  if (((cm).i >= 65536))
    restriction (p.slist);
  else {
    scalar * listr = list_concat (((scalar []){cm,{-1}}), p.slist);
    restriction (listr);
    free(listr);
  }

  astats st = {0, 0};
  scalar * listc = 
# 179 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
                  ((void *)0)
# 179 "/Users/weugene/basilisk/src/grid/tree-common.h"
                      ;
  if (p.list) for (scalar s = *p.list, *_i46 = p.list; ((scalar *)&s)->i >= 0; s = *++_i46)
    if (!((s).i >= 65536) && _attribute[s.i].restriction != no_restriction)
      listc = list_add (listc, s);


  if (p.minlevel < 1)
    p.minlevel = 1;
  ((Tree *)grid)->refined.n = 0;
  static const int refined = 1 << user, too_fine = 1 << (user + 1);
   { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 189 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & active)) {
      static const int too_coarse = 1 << (user + 2);
      if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {
 if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags & too_coarse) {
   (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags &= ~too_coarse;
   refine_cell (point, listc, refined, &((Tree *)grid)->refined);
   st.nf++;
 }
 continue;
      }
      else {
 if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags & refined) {

   (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags &= ~too_coarse;
   continue;
 }

 
# 207 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
_Bool 
# 207 "/Users/weugene/basilisk/src/grid/tree-common.h"
     local = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0);
 if (!local)
    { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
     if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0))
       local = 
# 211 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
              1
# 211 "/Users/weugene/basilisk/src/grid/tree-common.h"
                  , _k = _l = 2; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
 if (local) {
   int i = 0;
   static const int just_fine = 1 << (user + 3);
   if (p.slist) for (scalar s = *p.slist, *_i47 = p.slist; ((scalar *)&s)->i >= 0; s = *++_i47) {
     double max = p.max[i++], sc[1 << 2];
     int c = 0;
      { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
       sc[c++] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i]; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
     _attribute[s.i].prolongation (point, s);
     c = 0;
      { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
       double e = fabs(sc[c] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i]);
       if (e > max && level < p.maxlevel) {
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags &= ~too_fine;
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags |= too_coarse;
       }
       else if ((e <= max/1.5 || level > p.maxlevel) &&
         !((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags & (too_coarse|just_fine))) {
  if (level >= p.minlevel)
    (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags |= too_fine;
       }
       else if (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags & too_coarse)) {
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags &= ~too_fine;
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags |= just_fine;
       }
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = sc[c++];
     } } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
   }
    { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
     (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags &= ~just_fine;
     if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {
       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags &= ~too_coarse;
       if (level >= p.maxlevel)
  (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags |= too_fine;
     }
     else if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & active))
       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags &= ~too_coarse;
   } } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
 }
      }
    }
    else
      continue;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
  mpi_boundary_refine (listc);



  for (int l = (grid->depth); l >= 0; l--) {
     { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 261 "/Users/weugene/basilisk/src/grid/tree-common.h"

      if (!((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid < 0)) {
 if (level == l) {
   if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {
     if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags & refined)

       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags &= ~(refined|too_fine);
     else if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags & too_fine) {
       if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0) && coarsen_cell (point, listc))
  st.nc++;
       (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags &= ~too_fine;
     }
   }
   if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags & too_fine)
     (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags &= ~too_fine;
   else if (level > 0 && ((*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0])))).flags & too_fine))
     (*((Cell *)((((Tree *)grid)->L[point.level-1]->m[(point.i+2)/2+0] [(point.j+2)/2+0])))).flags &= ~too_fine;
   continue;
 }
 else if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf))
   continue;
      } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
    mpi_boundary_coarsen (l, too_fine);
  }
  free(listc);

  ;
  ;
  if (st.nc || st.nf)
    mpi_boundary_update (p.list);

  { astats _ret = st; ; return _ret; }
 ; }
# 314 "/Users/weugene/basilisk/src/grid/tree-common.h"
static void refine_level (int depth)
{
  int refined;
  do {
    refined = 0;
    ((Tree *)grid)->refined.n = 0;
     { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) { if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & active) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0)) {{
# 320 "/Users/weugene/basilisk/src/grid/tree-common.h"

      if (level < depth) {
 refine_cell (point, 
# 322 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
                    ((void *)0)
# 322 "/Users/weugene/basilisk/src/grid/tree-common.h"
                        , 0, &((Tree *)grid)->refined);
 refined++;
 continue;
      } } } continue; } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
    ;
    if (refined) {
      mpi_boundary_refine (
# 328 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
                          ((void *)0)
# 328 "/Users/weugene/basilisk/src/grid/tree-common.h"
                              );
      mpi_boundary_update (
# 329 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
                          ((void *)0)
# 329 "/Users/weugene/basilisk/src/grid/tree-common.h"
                              );
    }
  } while (refined);
}
# 359 "/Users/weugene/basilisk/src/grid/tree-common.h"
static void halo_flux (vector * list)
{
  vector * listv = 
# 361 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
                  ((void *)0)
# 361 "/Users/weugene/basilisk/src/grid/tree-common.h"
                      ;
  if (list) for (vector v = *list, *_i48 = list; ((scalar *)&v)->i >= 0; v = *++_i48)
    if (!((v.x).i >= 65536))
      listv = vectors_add (listv, v);

  if (listv) {
    for (int l = (grid->depth) - 1; l >= 0; l--)
       { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _cache = ((Tree *)grid)->prolongation[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = l; int _k; for (_k = 0; _k < _cache.n; _k++) { point.i = _cache.p[_k].i; point.j = _cache.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 368 "/Users/weugene/basilisk/src/grid/tree-common.h"

 {
# 369 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
# 378 "/Users/weugene/basilisk/src/grid/tree-common.h"
   if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0])))).pid >= 0))
     if (listv) for (vector f = *listv, *_i49 = listv; ((scalar *)&f)->i >= 0; f = *++_i49)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.x.i] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0]) + sizeof(Cell)))[f.x.i] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1]) + sizeof(Cell)))[f.x.i])/2.;
   if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0])))).pid >= 0))
     if (listv) for (vector f = *listv, *_i50 = listv; ((scalar *)&f)->i >= 0; f = *++_i50)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[f.x.i] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +0]) + sizeof(Cell)))[f.x.i] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +1]) + sizeof(Cell)))[f.x.i])/2.;
# 394 "/Users/weugene/basilisk/src/grid/tree-common.h"
      }
# 369 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
# 378 "/Users/weugene/basilisk/src/grid/tree-common.h"
   if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1])))).pid >= 0))
     if (listv) for (vector f = *listv, *_i49 = listv; ((scalar *)&f)->i >= 0; f = *++_i49)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.y.i] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0]) + sizeof(Cell)))[f.y.i] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0]) + sizeof(Cell)))[f.y.i])/2.;
   if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1])))).pid >= 0))
     if (listv) for (vector f = *listv, *_i50 = listv; ((scalar *)&f)->i >= 0; f = *++_i50)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[f.y.i] = (((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +2]) + sizeof(Cell)))[f.y.i] + ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +2]) + sizeof(Cell)))[f.y.i])/2.;
# 394 "/Users/weugene/basilisk/src/grid/tree-common.h"
      }} } } } }; }}; }
    free(listv);
  }
}



static scalar tree_init_scalar (scalar s, const char * name)
{
  s = multigrid_init_scalar (s, name);
  _attribute[s.i].refine = _attribute[s.i].prolongation;
  return s;
}

static void prolongation_vertex (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 409 "/Users/weugene/basilisk/src/grid/tree-common.h"


  ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +1]) + sizeof(Cell)))[s.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[s.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[s.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[s.i])/4.;





  for (int i = 0; i <= 1; i++) {
    for (int j = 0; j <= 1; j++)



 if ((level < (grid->depth) && point.i > 0 && point.i <= (1 << level) + 2 && point.j > 0 && point.j <= (1 << level) + 2 && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i][2*point.j-2 +2*j]))
   ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] [2*point.j-2 +2*j]) + sizeof(Cell)))[s.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+j]) + sizeof(Cell)))[s.i];

    {
# 425 "/Users/weugene/basilisk/src/grid/tree-common.h"

      if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0])))).neighbors) {

 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2*i] [2*point.j-2 +1]) + sizeof(Cell)))[s.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[s.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[s.i])/2.;
# 438 "/Users/weugene/basilisk/src/grid/tree-common.h"
      }
# 425 "/Users/weugene/basilisk/src/grid/tree-common.h"

      if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i])))).neighbors) {

 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +2*i]) + sizeof(Cell)))[s.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[s.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[s.i])/2.;
# 438 "/Users/weugene/basilisk/src/grid/tree-common.h"
      }}
  }
}

static scalar tree_init_vertex_scalar (scalar s, const char * name)
{
  s = multigrid_init_vertex_scalar (s, name);
  _attribute[s.i].refine = _attribute[s.i].prolongation = prolongation_vertex;
  return s;
}
# 449 "/Users/weugene/basilisk/src/grid/tree-common.h"

static void refine_face_x (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 451 "/Users/weugene/basilisk/src/grid/tree-common.h"

  vector v = _attribute[s.i].v;
  if (!(!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0])))).pid >= 0) &&
      ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0) || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]))))).pid == 0))) {
    double g1 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+ +1]) + sizeof(Cell)))[v.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[v.x.i])/8.;
    double g2 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i])/8.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +j]) + sizeof(Cell)))[v.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i] + (2*j - 1)*g1 + (2*k - 1)*g2;
  }
  if (!(!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0])))).pid >= 0) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0])))).neighbors &&
      ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0) || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]))))).pid == 0))) {
    double g1 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+ +1]) + sizeof(Cell)))[v.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[v.x.i])/8.;
    double g2 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[v.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[v.x.i])/8.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +2] [2*point.j-2 +j]) + sizeof(Cell)))[v.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[v.x.i] + (2*j - 1)*g1 + (2*k - 1)*g2;
  }
  if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0)) {
    double g1 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+ +1]) + sizeof(Cell)))[v.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+ +1]) + sizeof(Cell)))[v.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[v.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[v.x.i])/16.;
    double g2 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[v.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[v.x.i])/16.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +j]) + sizeof(Cell)))[v.x.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[v.x.i])/2. + (2*j - 1)*g1 + (2*k - 1)*g2;
  }
}
# 449 "/Users/weugene/basilisk/src/grid/tree-common.h"

static void refine_face_y (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 451 "/Users/weugene/basilisk/src/grid/tree-common.h"

  vector v = _attribute[s.i].v;
  if (!(!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1])))).pid >= 0) &&
      ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0) || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]))))).pid == 0))) {
    double g1 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+0]) + sizeof(Cell)))[v.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[v.y.i])/8.;
    double g2 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i])/8.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +j] [2*point.j-2 +0]) + sizeof(Cell)))[v.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i] + (2*j - 1)*g1 + (2*k - 1)*g2;
  }
  if (!(!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1])))).pid >= 0) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1])))).neighbors &&
      ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0) || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]))))).pid == 0))) {
    double g1 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+1]) + sizeof(Cell)))[v.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[v.y.i])/8.;
    double g2 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[v.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[v.y.i])/8.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +j] [2*point.j-2 +2]) + sizeof(Cell)))[v.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[v.y.i] + (2*j - 1)*g1 + (2*k - 1)*g2;
  }
  if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0)) {
    double g1 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+0]) + sizeof(Cell)))[v.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+1]) + sizeof(Cell)))[v.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[v.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[v.y.i])/16.;
    double g2 = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[v.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[v.y.i])/16.;
    for (int j = 0; j <= 1; j++)
      for (int k = 0; k <= 1; k++)
 ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +j] [2*point.j-2 +1]) + sizeof(Cell)))[v.y.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[v.y.i])/2. + (2*j - 1)*g1 + (2*k - 1)*g2;
  }
}

void refine_face (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 479 "/Users/weugene/basilisk/src/grid/tree-common.h"

  vector v = _attribute[s.i].v;
  {
# 481 "/Users/weugene/basilisk/src/grid/tree-common.h"

    _attribute[v.x.i].prolongation (point, v.x);
# 481 "/Users/weugene/basilisk/src/grid/tree-common.h"

    _attribute[v.y.i].prolongation (point, v.y);}
}

void refine_face_solenoidal (Point point, scalar s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 486 "/Users/weugene/basilisk/src/grid/tree-common.h"

  refine_face (point, s);

  if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0)) {

    vector v = _attribute[s.i].v;
    double d[1 << 2], p[1 << 2];
    int i = 0;
     { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
      d[i] = 0.;
      {
# 496 "/Users/weugene/basilisk/src/grid/tree-common.h"

 d[i] += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[v.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i];
# 496 "/Users/weugene/basilisk/src/grid/tree-common.h"

 d[i] += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[v.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i];}
      i++;
    } } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }

    p[0] = 0.;
    p[1] = (3.*d[3] + d[0])/4. + d[2]/2.;
    p[2] = (d[3] + 3.*d[0])/4. + d[2]/2.;
    p[3] = (d[3] + d[0])/2. + d[2];
    ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +1]) + sizeof(Cell)))[v.x.i] += p[1] - p[0];
    ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +0]) + sizeof(Cell)))[v.x.i] += p[3] - p[2];
    ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +1]) + sizeof(Cell)))[v.y.i] += p[0] - p[2];
    ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +1] [2*point.j-2 +1]) + sizeof(Cell)))[v.y.i] += p[1] - p[3];
# 536 "/Users/weugene/basilisk/src/grid/tree-common.h"
  }

}

vector tree_init_face_vector (vector v, const char * name)
{
  v = cartesian_init_face_vector (v, name);
  {
# 543 "/Users/weugene/basilisk/src/grid/tree-common.h"

    _attribute[v.x.i].restriction = _attribute[v.x.i].refine = no_restriction;
# 543 "/Users/weugene/basilisk/src/grid/tree-common.h"

    _attribute[v.y.i].restriction = _attribute[v.y.i].refine = no_restriction;}
  _attribute[v.x.i].restriction = restriction_face;
  _attribute[v.x.i].refine = refine_face;
  {
# 547 "/Users/weugene/basilisk/src/grid/tree-common.h"

    _attribute[v.x.i].prolongation = refine_face_x;
# 547 "/Users/weugene/basilisk/src/grid/tree-common.h"

    _attribute[v.y.i].prolongation = refine_face_y;}
  return v;
}

static void tree_boundary_level (scalar * list, int l)
{
  int depth = l < 0 ? (grid->depth) : l;

  if (tree_is_full()) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, depth); };
    return;
  }

  scalar * listdef = 
# 561 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
                    ((void *)0)
# 561 "/Users/weugene/basilisk/src/grid/tree-common.h"
                        , * listc = 
# 561 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
                                    ((void *)0)
# 561 "/Users/weugene/basilisk/src/grid/tree-common.h"
                                        , * list2 = 
# 561 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
                                                    ((void *)0)
# 561 "/Users/weugene/basilisk/src/grid/tree-common.h"
                                                        , * vlist = 
# 561 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
                                                                    ((void *)0)
# 561 "/Users/weugene/basilisk/src/grid/tree-common.h"
                                                                        ;
  if (list) for (scalar s = *list, *_i51 = list; ((scalar *)&s)->i >= 0; s = *++_i51)
    if (!((s).i >= 65536)) {
      if (_attribute[s.i].restriction == restriction_average) {
 listdef = list_add (listdef, s);
 list2 = list_add (list2, s);
      }
      else if (_attribute[s.i].restriction != no_restriction) {
 listc = list_add (listc, s);
 if (_attribute[s.i].face)
   {
# 571 "/Users/weugene/basilisk/src/grid/tree-common.h"

     list2 = list_add (list2, _attribute[s.i].v.x);
# 571 "/Users/weugene/basilisk/src/grid/tree-common.h"

     list2 = list_add (list2, _attribute[s.i].v.y);}
 else {
   list2 = list_add (list2, s);
   if (_attribute[s.i].restriction == restriction_vertex)
     vlist = list_add (vlist, s);
 }
      }
    }

  if (vlist)






     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { x -= Delta/2.; y -= Delta/2.;{
# 588 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
      if ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid >= 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0])))).pid >= 0) ||
   (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1])))).pid >= 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1])))).pid >= 0)) {

 if (vlist) for (scalar s = *vlist, *_i52 = vlist; ((scalar *)&s)->i >= 0; s = *++_i52)
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = (((*((Cell *)((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0]))))).flags & vertex) ? ((double *) ((((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] [2*point.j-2 +0]) + sizeof(Cell)))[s.i] : ((double)1e30);
      }
      else
 {
# 596 "/Users/weugene/basilisk/src/grid/tree-common.h"

   if (child.y == 1 &&
       ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid >= 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0])))).pid >= 0))) {

     if (vlist) for (scalar s = *vlist, *_i53 = vlist; ((scalar *)&s)->i >= 0; s = *++_i53)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]))))).flags & vertex) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]))))).flags & vertex) ?
  (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[s.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[s.i])/2. : ((double)1e30);
   }
# 596 "/Users/weugene/basilisk/src/grid/tree-common.h"

   if (child.x == 1 &&
       ((!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid >= 0) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1])))).pid >= 0))) {

     if (vlist) for (scalar s = *vlist, *_i53 = vlist; ((scalar *)&s)->i >= 0; s = *++_i53)
       ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]))))).flags & vertex) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]))))).flags & vertex) ?
  (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[s.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[s.i])/2. : ((double)1e30);
   }}
    } } } } } }; }
# 637 "/Users/weugene/basilisk/src/grid/tree-common.h"
  free(vlist);

  if (listdef || listc) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, list2, depth); };
    for (int l = depth - 1; l >= 0; l--) {
       { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 642 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
 if (listdef) for (scalar s = *listdef, *_i54 = listdef; ((scalar *)&s)->i >= 0; s = *++_i54)
   restriction_average (point, s);
 if (listc) for (scalar s = *listc, *_i55 = listc; ((scalar *)&s)->i >= 0; s = *++_i55)
   _attribute[s.i].restriction (point, s);
      } } } } } }; }}; }
      { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->restriction) _b->restriction (_b, list2, l); };
    }
    free(listdef);
    free(listc);
    free(list2);
  }

  scalar * listr = 
# 655 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
                  ((void *)0)
# 655 "/Users/weugene/basilisk/src/grid/tree-common.h"
                      ;
  vector * listf = 
# 656 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
                  ((void *)0)
# 656 "/Users/weugene/basilisk/src/grid/tree-common.h"
                      ;
  if (list) for (scalar s = *list, *_i56 = list; ((scalar *)&s)->i >= 0; s = *++_i56)
    if (!((s).i >= 65536) && _attribute[s.i].refine != no_restriction) {
      if (_attribute[s.i].face)
 listf = vectors_add (listf, _attribute[s.i].v);
      else
 listr = list_add (listr, s);
    }

  if (listr || listf) {
    { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, 0); };
    for (int i = 0; i < depth; i++) {
       { { if (i <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _cache = ((Tree *)grid)->prolongation[i]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = i; int _k; for (_k = 0; _k < _cache.n; _k++) { point.i = _cache.p[_k].i; point.j = _cache.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 668 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
 if (listr) for (scalar s = *listr, *_i57 = listr; ((scalar *)&s)->i >= 0; s = *++_i57)
          _attribute[s.i].prolongation (point, s);
 if (listf) for (vector v = *listf, *_i58 = listf; ((scalar *)&v)->i >= 0; v = *++_i58)
   {
# 672 "/Users/weugene/basilisk/src/grid/tree-common.h"

     _attribute[v.x.i].prolongation (point, v.x);
# 672 "/Users/weugene/basilisk/src/grid/tree-common.h"

     _attribute[v.y.i].prolongation (point, v.y);}
      } } } } }; }}; }
      { Boundary ** _i = boundaries, * _b; while (_i && (_b = *_i++)) if (_b->level) _b->level (_b, list, i + 1); };
    }
    free(listr);
    free(listf);
  }
}

double treex (Point point) { int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 682 "/Users/weugene/basilisk/src/grid/tree-common.h"

  if (level == 0)
    return 0;

  double i = 2*child.x - child.y;
  if (i <= 1 && i >= -1) i = -i;




  return treex(parent) + i/(1 << 2*(level - 1));
}

double treey (Point point) { int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 695 "/Users/weugene/basilisk/src/grid/tree-common.h"

  if (level == 0)
    return 0;
  return treey(parent) + 4./(1 << 2*(level - 1));
}

void output_tree (FILE * fp)
{
   { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 703 "/Users/weugene/basilisk/src/grid/tree-common.h"

    if ((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors)
       { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
 if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0))
   fprintf (fp, "%g %g\n%g %g\n\n",
     treex(parent), treey(parent), treex(point), treey(point)); } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }; } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
}

void tree_check()
{


  long nleaves = 0, nactive = 0;
   { { Point root = { .level = 0 }; for (root.i = 2*Period.x; root.i <= 2*(2 - Period.x); root.i++) for (root.j = 2*Period.y; root.j <= 2*(2 - Period.y); root.j++) { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 716 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {
      
# 718 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
     (__builtin_expect(!(
# 718 "/Users/weugene/basilisk/src/grid/tree-common.h"
     (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid >= 0
# 718 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
     ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree-common.h", 718, 
# 718 "/Users/weugene/basilisk/src/grid/tree-common.h"
     "cell.pid >= 0"
# 718 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
     ) : (void)0)
# 718 "/Users/weugene/basilisk/src/grid/tree-common.h"
                           ;
      nleaves++;
    }
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0))
      
# 722 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
     (__builtin_expect(!(
# 722 "/Users/weugene/basilisk/src/grid/tree-common.h"
     (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & active) || (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf) && !(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid >= 0)
# 722 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
     ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree-common.h", 722, 
# 722 "/Users/weugene/basilisk/src/grid/tree-common.h"
     "is_active(cell) || (!is_leaf(cell) && !cell.neighbors && cell.pid >= 0)"
# 722 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
     ) : (void)0)
# 722 "/Users/weugene/basilisk/src/grid/tree-common.h"
                                                                                     ;
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & active))
      nactive++;

    int neighbors = 0;
     { { int _nn = 1 + 0 ? 1 + 0 : 2; int _i = point.i, _j = point.j; for (int _k = - _nn; _k <= _nn; _k++) { point.i = _i + _k; for (int _l = - _nn; _l <= _nn; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
      if ((point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) && (!(((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf) && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors && (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid >= 0))
 neighbors++; } } point.i = _i; point.j = _j;}; }
    
# 730 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
   (__builtin_expect(!(
# 730 "/Users/weugene/basilisk/src/grid/tree-common.h"
   (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors == neighbors
# 730 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
   ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree-common.h", 730, 
# 730 "/Users/weugene/basilisk/src/grid/tree-common.h"
   "cell.neighbors == neighbors"
# 730 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
   ) : (void)0)
# 730 "/Users/weugene/basilisk/src/grid/tree-common.h"
                                       ;


    if (!(*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).neighbors)
      
# 734 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
     (__builtin_expect(!(
# 734 "/Users/weugene/basilisk/src/grid/tree-common.h"
     !(level < (grid->depth) && point.i > 0 && point.i <= (1 << level) + 2 && point.j > 0 && point.j <= (1 << level) + 2 && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0] && ((Tree *)grid)->L[point.level+1]->m[2*point.i-2 +0][2*point.j-2 +0])
# 734 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
     ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree-common.h", 734, 
# 734 "/Users/weugene/basilisk/src/grid/tree-common.h"
     "!allocated_child(0,0,0)"
# 734 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
     ) : (void)0)
# 734 "/Users/weugene/basilisk/src/grid/tree-common.h"
                                     ;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }


  long reachable = 0;
   { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 739 "/Users/weugene/basilisk/src/grid/tree-common.h"
 {
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & active))
      reachable++;
    else
      continue;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
  
# 745 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
 (__builtin_expect(!(
# 745 "/Users/weugene/basilisk/src/grid/tree-common.h"
 nactive == reachable
# 745 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree-common.h", 745, 
# 745 "/Users/weugene/basilisk/src/grid/tree-common.h"
 "nactive == reachable"
# 745 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
 ) : (void)0)
# 745 "/Users/weugene/basilisk/src/grid/tree-common.h"
                              ;


  reachable = 0;
   { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 749 "/Users/weugene/basilisk/src/grid/tree-common.h"

    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {
      reachable++;
      continue;
    } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
  
# 754 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
 (__builtin_expect(!(
# 754 "/Users/weugene/basilisk/src/grid/tree-common.h"
 nleaves == reachable
# 754 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/grid/tree-common.h", 754, 
# 754 "/Users/weugene/basilisk/src/grid/tree-common.h"
 "nleaves == reachable"
# 754 "/Users/weugene/basilisk/src/grid/tree-common.h" 3 4
 ) : (void)0)
# 754 "/Users/weugene/basilisk/src/grid/tree-common.h"
                              ;
}

static void tree_restriction (scalar * list) {
  if (tree_is_full())
    multigrid_restriction (list);

}

void tree_methods()
{
  multigrid_methods();
  init_scalar = tree_init_scalar;
  init_vertex_scalar = tree_init_vertex_scalar;
  init_face_vector = tree_init_face_vector;
  boundary_level = tree_boundary_level;
  boundary_flux = halo_flux;
  restriction = tree_restriction;
}
# 1770 "/Users/weugene/basilisk/src/grid/tree.h"


void tree_periodic (int dir)
{
  int depth = grid ? (grid->depth) : -1;
  if (grid)
    free_grid();
  periodic (dir);
  if (depth >= 0)
    init_grid (1 << depth);
}
# 3641 "/Users/weugene/basilisk/src/grid/tree.h"
void mpi_boundary_refine (scalar * list){}
void mpi_boundary_coarsen (int a, int b){}
void mpi_boundary_update (scalar * list) {
  boundary (list);
}
# 4 "/Users/weugene/basilisk/src/grid/quadtree.h"

void quadtree_methods() {
  tree_methods();
}
# 14 "karman_GI-cpp.c"
static double _boundary0 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary0_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary1 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary1_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary2 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary2_homogeneous (Point point, Point neighbor, scalar _s, void * data);
static double _boundary3 (Point point, Point neighbor, scalar _s, void * data);
static double _boundary3_homogeneous (Point point, Point neighbor, scalar _s, void * data);
# 1 "karman_GI.c"
# 1 "../src_local/centered-weugene.h"
# 1 "./../src_local/centered-weugene.h"
# 35 "./../src_local/centered-weugene.h"
# 1 "./run.h"
# 1 "/Users/weugene/basilisk/src/run.h"
# 9 "/Users/weugene/basilisk/src/run.h"
double dt = 1.;
# 1 "./utils.h"
# 1 "/Users/weugene/basilisk/src/utils.h"







double DT = 1e10, CFL = 0.5;




struct {

  long nc;

  long tnc;

  double t;

  double speed;

  timer gt;
} perf;





void update_perf() {
  perf.nc += grid->n;
  perf.tnc += grid->tn;
  perf.t = timer_elapsed (perf.gt);
  perf.speed = perf.tnc/perf.t;
}






typedef struct {
  double cpu;
  double real;
  double speed;
  double min;
  double avg;
  double max;
  size_t tnc;
  long mem;
} timing;






timing timer_timing (timer t, int i, size_t tnc, double * mpi)
{
  timing s;



  clock_t end = clock();
  s.cpu = ((double) (end - t.c))/
# 65 "/Users/weugene/basilisk/src/utils.h" 3 4
                                1000000
# 65 "/Users/weugene/basilisk/src/utils.h"
                                              ;
  s.real = timer_elapsed (t);
  if (tnc == 0) {
    double n = 0;
     {


 {
double _n = n;
# 69 "/Users/weugene/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 69 "/Users/weugene/basilisk/src/utils.h"
 _n++; } } } }; n += _n;
;



}
# 69 "/Users/weugene/basilisk/src/utils.h"
 }
    s.tnc = n;
    tnc = n*i;
  }
  else
    s.tnc = tnc;





  s.mem = 0;
# 95 "/Users/weugene/basilisk/src/utils.h"
  s.min = s.max = s.avg = 0.;

  s.speed = s.real > 0. ? tnc/s.real : -1.;
  return s;
}




void timer_print (timer t, int i, size_t tnc)
{
  timing s = timer_timing (t, i, tnc, 
# 106 "/Users/weugene/basilisk/src/utils.h" 3 4
                                     ((void *)0)
# 106 "/Users/weugene/basilisk/src/utils.h"
                                         );
  fprintf (
# 107 "/Users/weugene/basilisk/src/utils.h" 3 4
          __stdoutp
# 107 "/Users/weugene/basilisk/src/utils.h"
              ,
    "\n# " "Quadtree"
    ", %d steps, %g CPU, %.4g real, %.3g points.step/s, %d var\n",
    i, s.cpu, s.real, s.speed, (int) (datasize/sizeof(double)));
# 120 "/Users/weugene/basilisk/src/utils.h"
}







typedef struct {
  double avg, rms, max, volume;
} norm;

norm normf (scalar f)
{
  double avg = 0., rms = 0., max = 0., volume = 0.;
   {


 {
double _max = max; double _avg = avg; double _rms = rms; double _volume = volume;
# 135 "/Users/weugene/basilisk/src/utils.h"

if (!((cm).i >= 65536)) {
# 135 "/Users/weugene/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 136 "/Users/weugene/basilisk/src/utils.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] != ((double)1e30) && (((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i]) > 0.) {
      double v = fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i]);
      if (v > _max) _max = v;
      _volume += (((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i]);
      _avg += (((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i])*v;
      _rms += (((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i])*((v)*(v));
    } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 135 "/Users/weugene/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 136 "/Users/weugene/basilisk/src/utils.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] != ((double)1e30) && (((Delta)*(Delta))*_const_cm) > 0.) {
      double v = fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i]);
      if (v > _max) _max = v;
      _volume += (((Delta)*(Delta))*_const_cm);
      _avg += (((Delta)*(Delta))*_const_cm)*v;
      _rms += (((Delta)*(Delta))*_const_cm)*((v)*(v));
    } } } } }; } if (_max > max) max = _max;
;
 avg += _avg;
;
 rms += _rms;
;
 volume += _volume;
;



}
# 143 "/Users/weugene/basilisk/src/utils.h"
 }
  norm n;
  n.avg = volume ? avg/volume : 0.;
  n.rms = volume ? sqrt(rms/volume) : 0.;
  n.max = max;
  n.volume = volume;
  return n;
}





typedef struct {
  double min, max, sum, stddev, volume;
} stats;

stats statsf (scalar f)
{
  double min = 1e100, max = -1e100, sum = 0., sum2 = 0., volume = 0.;
   {


 {
double _sum = sum; double _sum2 = sum2; double _volume = volume; double _max = max; double _min = min;
# 163 "/Users/weugene/basilisk/src/utils.h"

if (!((cm).i >= 65536)) {
# 163 "/Users/weugene/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 164 "/Users/weugene/basilisk/src/utils.h"

    if ((((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i]) > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] != ((double)1e30)) {
      _volume += (((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i]);
      _sum += (((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
      _sum2 += (((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i])*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i]));
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] > _max) _max = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] < _min) _min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
    } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 163 "/Users/weugene/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 164 "/Users/weugene/basilisk/src/utils.h"

    if ((((Delta)*(Delta))*_const_cm) > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] != ((double)1e30)) {
      _volume += (((Delta)*(Delta))*_const_cm);
      _sum += (((Delta)*(Delta))*_const_cm)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
      _sum2 += (((Delta)*(Delta))*_const_cm)*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i]));
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] > _max) _max = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] < _min) _min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
    } } } } }; } sum += _sum;
;
 sum2 += _sum2;
;
 volume += _volume;
;
 if (_max > max) max = _max;
;
 if (_min < min) min = _min;
;



}
# 171 "/Users/weugene/basilisk/src/utils.h"
 }
  stats s;
  s.min = min, s.max = max, s.sum = sum, s.volume = volume;
  if (volume > 0.)
    sum2 -= sum*sum/volume;
  s.stddev = sum2 > 0. ? sqrt(sum2/volume) : 0.;
  return s;
}
# 187 "/Users/weugene/basilisk/src/utils.h"
static double generic_limiter (double r, double beta)
{
  double v1 = ((r) < (beta) ? (r) : (beta)), v2 = ((beta*r) < (1.) ? (beta*r) : (1.));
  v1 = ((0.) > (v1) ? (0.) : (v1));
  return ((v1) > (v2) ? (v1) : (v2));
}

double minmod (double s0, double s1, double s2) {
  return generic_limiter ((s2 - s1)/(s1 - s0), 1.)*(s1 - s0);
}

double superbee (double s0, double s1, double s2) {
  return generic_limiter ((s2 - s1)/(s1 - s0), 2.)*(s1 - s0);
}

double sweby (double s0, double s1, double s2) {
  return generic_limiter ((s2 - s1)/(s1 - s0), 1.5)*(s1 - s0);
}
# 213 "/Users/weugene/basilisk/src/utils.h"
double theta = 1.3;

double minmod2 (double s0, double s1, double s2)
{
  if (s0 < s1 && s1 < s2) {
    double d1 = theta*(s1 - s0), d2 = (s2 - s0)/2., d3 = theta*(s2 - s1);
    if (d2 < d1) d1 = d2;
    return ((d1) < (d3) ? (d1) : (d3));
  }
  if (s0 > s1 && s1 > s2) {
    double d1 = theta*(s1 - s0), d2 = (s2 - s0)/2., d3 = theta*(s2 - s1);
    if (d2 > d1) d1 = d2;
    return ((d1) > (d3) ? (d1) : (d3));
  }
  return 0.;
}
# 237 "/Users/weugene/basilisk/src/utils.h"
void gradients (scalar * f, vector * g)
{
  
# 239 "/Users/weugene/basilisk/src/utils.h" 3 4
 (__builtin_expect(!(
# 239 "/Users/weugene/basilisk/src/utils.h"
 list_len(f) == vectors_len(g)
# 239 "/Users/weugene/basilisk/src/utils.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/utils.h", 239, 
# 239 "/Users/weugene/basilisk/src/utils.h"
 "list_len(f) == vectors_len(g)"
# 239 "/Users/weugene/basilisk/src/utils.h" 3 4
 ) : (void)0)
# 239 "/Users/weugene/basilisk/src/utils.h"
                                       ;
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 240 "/Users/weugene/basilisk/src/utils.h"
 {
    scalar s; vector v;
    scalar * _i0 = f; vector * _i1 = g; if (f) for (s = *f, v = *g; ((scalar *)&s)->i >= 0; s = *++_i0, v = *++_i1) {
      if (_attribute[s.i].gradient)
 {
# 244 "/Users/weugene/basilisk/src/utils.h"
 {





     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i] = _attribute[s.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[s.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[s.i])/Delta;
 }
# 244 "/Users/weugene/basilisk/src/utils.h"
 {





     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i] = _attribute[s.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[s.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[s.i])/Delta;
 }}
      else
 {
# 253 "/Users/weugene/basilisk/src/utils.h"
 {





     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[s.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[s.i])/(2.*Delta);
 }
# 253 "/Users/weugene/basilisk/src/utils.h"
 {





     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[s.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[s.i])/(2.*Delta);
 }}
    }
  } } } } }; }
  boundary ((scalar *) g);
}
# 275 "/Users/weugene/basilisk/src/utils.h"
void vorticity (const vector u, scalar omega)
{
  struct { double x, y; } a = {1., -1.};
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 278 "/Users/weugene/basilisk/src/utils.h"
 {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[omega.i] = 0.;
    {
# 280 "/Users/weugene/basilisk/src/utils.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[omega.i] += a.x*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/(2.*Delta));
# 280 "/Users/weugene/basilisk/src/utils.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[omega.i] += a.y*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/(2.*Delta));}
  } } } } }; }
  boundary (((scalar []){omega,{-1}}));
}





double change (scalar s, scalar sn)
{
  double max = 0.;
   {


 {
double _max = max;
# 293 "/Users/weugene/basilisk/src/utils.h"

if (!((cm).i >= 65536)) {
# 293 "/Users/weugene/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 293 "/Users/weugene/basilisk/src/utils.h"
 {
    if ((((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i]) > 0.) {
      double ds = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[sn.i]);
      if (ds > _max)
 _max = ds;
    }
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[sn.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i];
  } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 293 "/Users/weugene/basilisk/src/utils.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 293 "/Users/weugene/basilisk/src/utils.h"
 {
    if ((((Delta)*(Delta))*_const_cm) > 0.) {
      double ds = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[sn.i]);
      if (ds > _max)
 _max = ds;
    }
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[sn.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i];
  } } } } }; } if (_max > max) max = _max;
;



}
# 300 "/Users/weugene/basilisk/src/utils.h"
 }
  return max;
}





scalar lookup_field (const char * name)
{
  if (name)
    if (all) for (scalar s = *all, *_i68 = all; ((scalar *)&s)->i >= 0; s = *++_i68)
      if (!strcmp (_attribute[s.i].name, name))
 return s;
  return (scalar){-1};
}

vector lookup_vector (const char * name)
{
  if (name) {
    char component[strlen(name) + 3];
    
# 321 "/Users/weugene/basilisk/src/utils.h" 3 4
   __builtin___strcpy_chk (
# 321 "/Users/weugene/basilisk/src/utils.h"
   component
# 321 "/Users/weugene/basilisk/src/utils.h" 3 4
   , 
# 321 "/Users/weugene/basilisk/src/utils.h"
   name
# 321 "/Users/weugene/basilisk/src/utils.h" 3 4
   , __builtin_object_size (
# 321 "/Users/weugene/basilisk/src/utils.h"
   component
# 321 "/Users/weugene/basilisk/src/utils.h" 3 4
   , 2 > 1 ? 1 : 0))
# 321 "/Users/weugene/basilisk/src/utils.h"
                           ;
    
# 322 "/Users/weugene/basilisk/src/utils.h" 3 4
   __builtin___strcat_chk (
# 322 "/Users/weugene/basilisk/src/utils.h"
   component
# 322 "/Users/weugene/basilisk/src/utils.h" 3 4
   , 
# 322 "/Users/weugene/basilisk/src/utils.h"
   ".x"
# 322 "/Users/weugene/basilisk/src/utils.h" 3 4
   , __builtin_object_size (
# 322 "/Users/weugene/basilisk/src/utils.h"
   component
# 322 "/Users/weugene/basilisk/src/utils.h" 3 4
   , 2 > 1 ? 1 : 0))
# 322 "/Users/weugene/basilisk/src/utils.h"
                           ;
    if (all) for (scalar s = *all, *_i69 = all; ((scalar *)&s)->i >= 0; s = *++_i69)
      if (!strcmp (_attribute[s.i].name, component))
 return _attribute[s.i].v;
  }
  return (vector){{-1}};
}
# 1 "./output.h"
# 1 "/Users/weugene/basilisk/src/output.h"
# 37 "/Users/weugene/basilisk/src/output.h"
struct OutputField {
  scalar * list;
  FILE * fp;
  int n;
  
# 41 "/Users/weugene/basilisk/src/output.h" 3 4
 _Bool 
# 41 "/Users/weugene/basilisk/src/output.h"
      linear;
  double box[2][2];
};


void output_field (struct OutputField p)
{ ;
  if (!p.list) p.list = all;
  if (p.n == 0) p.n = N;
  if (!p.fp) p.fp = 
# 50 "/Users/weugene/basilisk/src/output.h" 3 4
                   __stdoutp
# 50 "/Users/weugene/basilisk/src/output.h"
                            ;
  p.n++;
  if (p.box[0][0] == 0. && p.box[0][1] == 0. &&
      p.box[1][0] == 0. && p.box[1][1] == 0.) {
    p.box[0][0] = X0; p.box[0][1] = Y0;
    p.box[1][0] = X0 + L0; p.box[1][1] = Y0 + L0;
  }

  int len = list_len(p.list);
  double Delta = 0.999999*(p.box[1][0] - p.box[0][0])/(p.n - 1);
  int ny = (p.box[1][1] - p.box[0][1])/Delta + 1;
  double ** field = (double **) matrix_new (p.n, ny, len*sizeof(double));
  for (int i = 0; i < p.n; i++) {
    double x = Delta*i + p.box[0][0];
    for (int j = 0; j < ny; j++) {
      double y = Delta*j + p.box[0][1];
      if (p.linear) {
 int k = 0;
 if (p.list) for (scalar s = *p.list, *_i70 = p.list; ((scalar *)&s)->i >= 0; s = *++_i70)
   field[i][len*j + k++] = interpolate ((struct _interpolate){s, x, y});
      }
      else {
 Point point = locate ((struct _locate){x, y}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 72 "/Users/weugene/basilisk/src/output.h"

 int k = 0;
 if (p.list) for (scalar s = *p.list, *_i71 = p.list; ((scalar *)&s)->i >= 0; s = *++_i71)
   field[i][len*j + k++] = point.level >= 0 ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] : ((double)1e30);
      }
    }
  }

  if (0 == 0) {




    fprintf (p.fp, "# 1:x 2:y");
    int i = 3;
    if (p.list) for (scalar s = *p.list, *_i72 = p.list; ((scalar *)&s)->i >= 0; s = *++_i72)
      fprintf (p.fp, " %d:%s", i++, _attribute[s.i].name);
    fputc('\n', p.fp);
    for (int i = 0; i < p.n; i++) {
      double x = Delta*i + p.box[0][0];
      for (int j = 0; j < ny; j++) {
 double y = Delta*j + p.box[0][1];

 fprintf (p.fp, "%g %g", x, y);
 int k = 0;
 if (p.list) for (scalar s = *p.list, *_i73 = p.list; ((scalar *)&s)->i >= 0; s = *++_i73)
   fprintf (p.fp, " %g", field[i][len*j + k++]);
 fputc ('\n', p.fp);
      }
      fputc ('\n', p.fp);
    }
    fflush (p.fp);
  }






  matrix_free (field);
 ; }
# 140 "/Users/weugene/basilisk/src/output.h"
struct OutputMatrix {
  scalar f;
  FILE * fp;
  int n;
  
# 144 "/Users/weugene/basilisk/src/output.h" 3 4
 _Bool 
# 144 "/Users/weugene/basilisk/src/output.h"
      linear;
};


void output_matrix (struct OutputMatrix p)
{ ;
  if (p.n == 0) p.n = N;
  if (!p.fp) p.fp = 
# 151 "/Users/weugene/basilisk/src/output.h" 3 4
                   __stdoutp
# 151 "/Users/weugene/basilisk/src/output.h"
                            ;
  float fn = p.n;
  float Delta = (float) L0/fn;
  fwrite (&fn, sizeof(float), 1, p.fp);
  for (int j = 0; j < p.n; j++) {
    float yp = (float) (Delta*j + X0 + Delta/2.);
    fwrite (&yp, sizeof(float), 1, p.fp);
  }
  for (int i = 0; i < p.n; i++) {
    float xp = (float) (Delta*i + X0 + Delta/2.);
    fwrite (&xp, sizeof(float), 1, p.fp);
    for (int j = 0; j < p.n; j++) {
      float yp = (float)(Delta*j + Y0 + Delta/2.), v;
      if (p.linear)
 v = interpolate ((struct _interpolate){p.f, xp, yp});
      else {
 Point point = locate ((struct _locate){xp, yp}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 167 "/Users/weugene/basilisk/src/output.h"

 
# 168 "/Users/weugene/basilisk/src/output.h" 3 4
(__builtin_expect(!(
# 168 "/Users/weugene/basilisk/src/output.h"
point.level >= 0
# 168 "/Users/weugene/basilisk/src/output.h" 3 4
), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/output.h", 168, 
# 168 "/Users/weugene/basilisk/src/output.h"
"point.level >= 0"
# 168 "/Users/weugene/basilisk/src/output.h" 3 4
) : (void)0)
# 168 "/Users/weugene/basilisk/src/output.h"
                         ;
 v = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.f.i];
      }
      fwrite (&v, sizeof(float), 1, p.fp);
    }
  }
  fflush (p.fp);
 ; }
# 184 "/Users/weugene/basilisk/src/output.h"
typedef void (* colormap) (double cmap[127][3]);

void jet (double cmap[127][3])
{
  for (int i = 0; i < 127; i++) {
    cmap[i][0] =
      i <= 46 ? 0. :
      i >= 111 ? -0.03125*(i - 111) + 1. :
      i >= 78 ? 1. :
      0.03125*(i - 46);
    cmap[i][1] =
      i <= 14 || i >= 111 ? 0. :
      i >= 79 ? -0.03125*(i - 111) :
      i <= 46 ? 0.03125*(i - 14) :
      1.;
    cmap[i][2] =
      i >= 79 ? 0. :
      i >= 47 ? -0.03125*(i - 79) :
      i <= 14 ? 0.03125*(i - 14) + 1.:
      1.;
  }
}

void cool_warm (double cmap[127][3])
{






  static double basemap[33][3] = {
    {0.2298057, 0.298717966, 0.753683153},
    {0.26623388, 0.353094838, 0.801466763},
    {0.30386891, 0.406535296, 0.84495867},
    {0.342804478, 0.458757618, 0.883725899},
    {0.38301334, 0.50941904, 0.917387822},
    {0.424369608, 0.558148092, 0.945619588},
    {0.46666708, 0.604562568, 0.968154911},
    {0.509635204, 0.648280772, 0.98478814},
    {0.552953156, 0.688929332, 0.995375608},
    {0.596262162, 0.726149107, 0.999836203},
    {0.639176211, 0.759599947, 0.998151185},
    {0.681291281, 0.788964712, 0.990363227},
    {0.722193294, 0.813952739, 0.976574709},
    {0.761464949, 0.834302879, 0.956945269},
    {0.798691636, 0.849786142, 0.931688648},
    {0.833466556, 0.860207984, 0.901068838},
    {0.865395197, 0.86541021, 0.865395561},
    {0.897787179, 0.848937047, 0.820880546},
    {0.924127593, 0.827384882, 0.774508472},
    {0.944468518, 0.800927443, 0.726736146},
    {0.958852946, 0.769767752, 0.678007945},
    {0.96732803, 0.734132809, 0.628751763},
    {0.969954137, 0.694266682, 0.579375448},
    {0.966811177, 0.650421156, 0.530263762},
    {0.958003065, 0.602842431, 0.481775914},
    {0.943660866, 0.551750968, 0.434243684},
    {0.923944917, 0.49730856, 0.387970225},
    {0.89904617, 0.439559467, 0.343229596},
    {0.869186849, 0.378313092, 0.300267182},
    {0.834620542, 0.312874446, 0.259301199},
    {0.795631745, 0.24128379, 0.220525627},
    {0.752534934, 0.157246067, 0.184115123},
    {0.705673158, 0.01555616, 0.150232812}
  };

  for (int i = 0; i < 127; i++) {
    double x = i*(32 - 1e-10)/(127 - 1);
    int j = x; x -= j;
    for (int k = 0; k < 3; k++)
      cmap[i][k] = (1. - x)*basemap[j][k] + x*basemap[j+1][k];
  }
}

void gray (double cmap[127][3])
{
  for (int i = 0; i < 127; i++)
    for (int k = 0; k < 3; k++)
      cmap[i][k] = i/(127 - 1.);
}

void randomap (double cmap[127][3])
{
  srand(0);
  for (int i = 0; i < 127; i++)
    for (int k = 0; k < 3; k++)
      cmap[i][k] = ((1. - 2.*rand()/(double)
# 271 "/Users/weugene/basilisk/src/output.h" 3 4
                   0x7fffffff
# 271 "/Users/weugene/basilisk/src/output.h"
                   ) + 1.)/2.;
}





typedef struct {
  unsigned char r, g, b;
} color;

color colormap_color (double cmap[127][3],
        double val, double min, double max)
{
  color c;
  if (val == ((double)1e30)) {
    c.r = c.g = c.b = 0;
    return c;
  }
  int i;
  double coef;
  if (max != min)
    val = (val - min)/(max - min);
  else
    val = 0.;
  if (val <= 0.) i = 0, coef = 0.;
  else if (val >= 1.) i = 127 - 2, coef = 1.;
  else {
    i = val*(127 - 1);
    coef = val*(127 - 1) - i;
  }
  
# 302 "/Users/weugene/basilisk/src/output.h" 3 4
 (__builtin_expect(!(
# 302 "/Users/weugene/basilisk/src/output.h"
 i < 127 - 1
# 302 "/Users/weugene/basilisk/src/output.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/output.h", 302, 
# 302 "/Users/weugene/basilisk/src/output.h"
 "i < 127 - 1"
# 302 "/Users/weugene/basilisk/src/output.h" 3 4
 ) : (void)0)
# 302 "/Users/weugene/basilisk/src/output.h"
                     ;
  unsigned char * c1 = (unsigned char *) &c;
  for (int j = 0; j < 3; j++)
    c1[j] = 255*(cmap[i][j]*(1. - coef) + cmap[i + 1][j]*coef);
  return c;
}
# 321 "/Users/weugene/basilisk/src/output.h"
static const char * extension (const char * file, const char * ext) {
  int len = strlen(file);
  return len > 4 && !strcmp (file + len - 4, ext) ? file + len - 4 : 
# 323 "/Users/weugene/basilisk/src/output.h" 3 4
                                                                    ((void *)0)
# 323 "/Users/weugene/basilisk/src/output.h"
                                                                        ;
}

static const char * is_animation (const char * file) {
  const char * ext;
  if ((ext = extension (file, ".mp4")) ||
      (ext = extension (file, ".ogv")) ||
      (ext = extension (file, ".gif")))
    return ext;
  return 
# 332 "/Users/weugene/basilisk/src/output.h" 3 4
        ((void *)0)
# 332 "/Users/weugene/basilisk/src/output.h"
            ;
}

static struct {
  FILE ** fp;
  char ** names;
  int n;
} open_image_data = {
# 339 "/Users/weugene/basilisk/src/output.h" 3 4
                    ((void *)0)
# 339 "/Users/weugene/basilisk/src/output.h"
                        , 
# 339 "/Users/weugene/basilisk/src/output.h" 3 4
                          ((void *)0)
# 339 "/Users/weugene/basilisk/src/output.h"
                              , 0};

static void open_image_cleanup()
{
  for (int i = 0; i < open_image_data.n; i++) {
    qpclose (open_image_data.fp[i]);
    free(open_image_data.names[i]);
  }
  free(open_image_data.fp);
  free(open_image_data.names);
  open_image_data.fp = 
# 349 "/Users/weugene/basilisk/src/output.h" 3 4
                      ((void *)0)
# 349 "/Users/weugene/basilisk/src/output.h"
                          ;
  open_image_data.names = 
# 350 "/Users/weugene/basilisk/src/output.h" 3 4
                         ((void *)0)
# 350 "/Users/weugene/basilisk/src/output.h"
                             ;
  open_image_data.n = 0;
}

static FILE * open_image_lookup (const char * file)
{
  for (int i = 0; i < open_image_data.n; i++)
    if (!strcmp (file, open_image_data.names[i]))
      return open_image_data.fp[i];
  return 
# 359 "/Users/weugene/basilisk/src/output.h" 3 4
        ((void *)0)
# 359 "/Users/weugene/basilisk/src/output.h"
            ;
}

static 
# 362 "/Users/weugene/basilisk/src/output.h" 3 4
      _Bool 
# 362 "/Users/weugene/basilisk/src/output.h"
           which (const char * command)
{
  char * s = getenv ("PATH");
  if (!s)
    return 
# 366 "/Users/weugene/basilisk/src/output.h" 3 4
          0
# 366 "/Users/weugene/basilisk/src/output.h"
               ;
  char path[strlen(s) + 1];
  
# 368 "/Users/weugene/basilisk/src/output.h" 3 4
 __builtin___strcpy_chk (
# 368 "/Users/weugene/basilisk/src/output.h"
 path
# 368 "/Users/weugene/basilisk/src/output.h" 3 4
 , 
# 368 "/Users/weugene/basilisk/src/output.h"
 s
# 368 "/Users/weugene/basilisk/src/output.h" 3 4
 , __builtin_object_size (
# 368 "/Users/weugene/basilisk/src/output.h"
 path
# 368 "/Users/weugene/basilisk/src/output.h" 3 4
 , 2 > 1 ? 1 : 0))
# 368 "/Users/weugene/basilisk/src/output.h"
                 ;
  s = strtok (path, ":");
  while (s) {
    char f[strlen(s) + strlen(command) + 2];
    
# 372 "/Users/weugene/basilisk/src/output.h" 3 4
   __builtin___strcpy_chk (
# 372 "/Users/weugene/basilisk/src/output.h"
   f
# 372 "/Users/weugene/basilisk/src/output.h" 3 4
   , 
# 372 "/Users/weugene/basilisk/src/output.h"
   s
# 372 "/Users/weugene/basilisk/src/output.h" 3 4
   , __builtin_object_size (
# 372 "/Users/weugene/basilisk/src/output.h"
   f
# 372 "/Users/weugene/basilisk/src/output.h" 3 4
   , 2 > 1 ? 1 : 0))
# 372 "/Users/weugene/basilisk/src/output.h"
                ;
    
# 373 "/Users/weugene/basilisk/src/output.h" 3 4
   __builtin___strcat_chk (
# 373 "/Users/weugene/basilisk/src/output.h"
   f
# 373 "/Users/weugene/basilisk/src/output.h" 3 4
   , 
# 373 "/Users/weugene/basilisk/src/output.h"
   "/"
# 373 "/Users/weugene/basilisk/src/output.h" 3 4
   , __builtin_object_size (
# 373 "/Users/weugene/basilisk/src/output.h"
   f
# 373 "/Users/weugene/basilisk/src/output.h" 3 4
   , 2 > 1 ? 1 : 0))
# 373 "/Users/weugene/basilisk/src/output.h"
                  ;
    
# 374 "/Users/weugene/basilisk/src/output.h" 3 4
   __builtin___strcat_chk (
# 374 "/Users/weugene/basilisk/src/output.h"
   f
# 374 "/Users/weugene/basilisk/src/output.h" 3 4
   , 
# 374 "/Users/weugene/basilisk/src/output.h"
   command
# 374 "/Users/weugene/basilisk/src/output.h" 3 4
   , __builtin_object_size (
# 374 "/Users/weugene/basilisk/src/output.h"
   f
# 374 "/Users/weugene/basilisk/src/output.h" 3 4
   , 2 > 1 ? 1 : 0))
# 374 "/Users/weugene/basilisk/src/output.h"
                      ;
    FILE * fp = fopen (f, "r");
    if (fp) {
      fclose (fp);
      return 
# 378 "/Users/weugene/basilisk/src/output.h" 3 4
            1
# 378 "/Users/weugene/basilisk/src/output.h"
                ;
    }
    s = strtok (
# 380 "/Users/weugene/basilisk/src/output.h" 3 4
               ((void *)0)
# 380 "/Users/weugene/basilisk/src/output.h"
                   , ":");
  }
  return 
# 382 "/Users/weugene/basilisk/src/output.h" 3 4
        0
# 382 "/Users/weugene/basilisk/src/output.h"
             ;
}

static FILE * ppm_fallback (const char * file, const char * mode)
{
  char filename[strlen(file) + 5];
  
# 388 "/Users/weugene/basilisk/src/output.h" 3 4
 __builtin___strcpy_chk (
# 388 "/Users/weugene/basilisk/src/output.h"
 filename
# 388 "/Users/weugene/basilisk/src/output.h" 3 4
 , 
# 388 "/Users/weugene/basilisk/src/output.h"
 file
# 388 "/Users/weugene/basilisk/src/output.h" 3 4
 , __builtin_object_size (
# 388 "/Users/weugene/basilisk/src/output.h"
 filename
# 388 "/Users/weugene/basilisk/src/output.h" 3 4
 , 2 > 1 ? 1 : 0))
# 388 "/Users/weugene/basilisk/src/output.h"
                        ;
  
# 389 "/Users/weugene/basilisk/src/output.h" 3 4
 __builtin___strcat_chk (
# 389 "/Users/weugene/basilisk/src/output.h"
 filename
# 389 "/Users/weugene/basilisk/src/output.h" 3 4
 , 
# 389 "/Users/weugene/basilisk/src/output.h"
 ".ppm"
# 389 "/Users/weugene/basilisk/src/output.h" 3 4
 , __builtin_object_size (
# 389 "/Users/weugene/basilisk/src/output.h"
 filename
# 389 "/Users/weugene/basilisk/src/output.h" 3 4
 , 2 > 1 ? 1 : 0))
# 389 "/Users/weugene/basilisk/src/output.h"
                          ;
  FILE * fp = fopen (filename, mode);
  if (!fp) {
    perror (file);



    exit (1);
  }
  return fp;
}

FILE * open_image (const char * file, const char * options)
{
  
# 403 "/Users/weugene/basilisk/src/output.h" 3 4
 (__builtin_expect(!(
# 403 "/Users/weugene/basilisk/src/output.h"
 0 == 0
# 403 "/Users/weugene/basilisk/src/output.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/output.h", 403, 
# 403 "/Users/weugene/basilisk/src/output.h"
 "pid() == 0"
# 403 "/Users/weugene/basilisk/src/output.h" 3 4
 ) : (void)0)
# 403 "/Users/weugene/basilisk/src/output.h"
                    ;
  const char * ext;
  if ((ext = is_animation (file))) {
    FILE * fp = open_image_lookup (file);
    if (fp)
      return fp;

    int len = strlen ("ppm2???    ") + strlen (file) +
      (options ? strlen (options) : 0);
    char command[len];
    
# 413 "/Users/weugene/basilisk/src/output.h" 3 4
   __builtin___strcpy_chk (
# 413 "/Users/weugene/basilisk/src/output.h"
   command
# 413 "/Users/weugene/basilisk/src/output.h" 3 4
   , 
# 413 "/Users/weugene/basilisk/src/output.h"
   "ppm2"
# 413 "/Users/weugene/basilisk/src/output.h" 3 4
   , __builtin_object_size (
# 413 "/Users/weugene/basilisk/src/output.h"
   command
# 413 "/Users/weugene/basilisk/src/output.h" 3 4
   , 2 > 1 ? 1 : 0))
# 413 "/Users/weugene/basilisk/src/output.h"
                           ; 
# 413 "/Users/weugene/basilisk/src/output.h" 3 4
                             __builtin___strcat_chk (
# 413 "/Users/weugene/basilisk/src/output.h"
                             command
# 413 "/Users/weugene/basilisk/src/output.h" 3 4
                             , 
# 413 "/Users/weugene/basilisk/src/output.h"
                             ext + 1
# 413 "/Users/weugene/basilisk/src/output.h" 3 4
                             , __builtin_object_size (
# 413 "/Users/weugene/basilisk/src/output.h"
                             command
# 413 "/Users/weugene/basilisk/src/output.h" 3 4
                             , 2 > 1 ? 1 : 0))
# 413 "/Users/weugene/basilisk/src/output.h"
                                                      ;

    static int has_ffmpeg = -1;
    if (has_ffmpeg < 0) {
      if (which (command) && (which ("ffmpeg") || which ("avconv")))
 has_ffmpeg = 
# 418 "/Users/weugene/basilisk/src/output.h" 3 4
             1
# 418 "/Users/weugene/basilisk/src/output.h"
                 ;
      else {
 fprintf (
# 420 "/Users/weugene/basilisk/src/output.h" 3 4
         __stderrp
# 420 "/Users/weugene/basilisk/src/output.h"
             ,
   "open_image(): cannot find '%s' or 'ffmpeg'/'avconv'\n"
   "  falling back to raw PPM outputs\n", command);
 has_ffmpeg = 
# 423 "/Users/weugene/basilisk/src/output.h" 3 4
             0
# 423 "/Users/weugene/basilisk/src/output.h"
                  ;
      }
    }
    if (!has_ffmpeg)
      return ppm_fallback (file, "a");

    static 
# 429 "/Users/weugene/basilisk/src/output.h" 3 4
          _Bool 
# 429 "/Users/weugene/basilisk/src/output.h"
               added = 
# 429 "/Users/weugene/basilisk/src/output.h" 3 4
                       0
# 429 "/Users/weugene/basilisk/src/output.h"
                            ;
    if (!added) {
      free_solver_func_add (open_image_cleanup);
      added = 
# 432 "/Users/weugene/basilisk/src/output.h" 3 4
             1
# 432 "/Users/weugene/basilisk/src/output.h"
                 ;
    }
    open_image_data.n++;
    open_image_data.names = (char * *) realloc(open_image_data.names,(open_image_data.n)*sizeof(char *));
    open_image_data.names[open_image_data.n - 1] = strdup(file);

    if (options) {
      
# 439 "/Users/weugene/basilisk/src/output.h" 3 4
     __builtin___strcat_chk (
# 439 "/Users/weugene/basilisk/src/output.h"
     command
# 439 "/Users/weugene/basilisk/src/output.h" 3 4
     , 
# 439 "/Users/weugene/basilisk/src/output.h"
     " "
# 439 "/Users/weugene/basilisk/src/output.h" 3 4
     , __builtin_object_size (
# 439 "/Users/weugene/basilisk/src/output.h"
     command
# 439 "/Users/weugene/basilisk/src/output.h" 3 4
     , 2 > 1 ? 1 : 0))
# 439 "/Users/weugene/basilisk/src/output.h"
                          ;
      
# 440 "/Users/weugene/basilisk/src/output.h" 3 4
     __builtin___strcat_chk (
# 440 "/Users/weugene/basilisk/src/output.h"
     command
# 440 "/Users/weugene/basilisk/src/output.h" 3 4
     , 
# 440 "/Users/weugene/basilisk/src/output.h"
     options
# 440 "/Users/weugene/basilisk/src/output.h" 3 4
     , __builtin_object_size (
# 440 "/Users/weugene/basilisk/src/output.h"
     command
# 440 "/Users/weugene/basilisk/src/output.h" 3 4
     , 2 > 1 ? 1 : 0))
# 440 "/Users/weugene/basilisk/src/output.h"
                              ;
    }
    
# 442 "/Users/weugene/basilisk/src/output.h" 3 4
   __builtin___strcat_chk (
# 442 "/Users/weugene/basilisk/src/output.h"
   command
# 442 "/Users/weugene/basilisk/src/output.h" 3 4
   , 
# 442 "/Users/weugene/basilisk/src/output.h"
   !strcmp (ext, ".mp4") ? " " : " > "
# 442 "/Users/weugene/basilisk/src/output.h" 3 4
   , __builtin_object_size (
# 442 "/Users/weugene/basilisk/src/output.h"
   command
# 442 "/Users/weugene/basilisk/src/output.h" 3 4
   , 2 > 1 ? 1 : 0))
# 442 "/Users/weugene/basilisk/src/output.h"
                                                        ;
    
# 443 "/Users/weugene/basilisk/src/output.h" 3 4
   __builtin___strcat_chk (
# 443 "/Users/weugene/basilisk/src/output.h"
   command
# 443 "/Users/weugene/basilisk/src/output.h" 3 4
   , 
# 443 "/Users/weugene/basilisk/src/output.h"
   file
# 443 "/Users/weugene/basilisk/src/output.h" 3 4
   , __builtin_object_size (
# 443 "/Users/weugene/basilisk/src/output.h"
   command
# 443 "/Users/weugene/basilisk/src/output.h" 3 4
   , 2 > 1 ? 1 : 0))
# 443 "/Users/weugene/basilisk/src/output.h"
                         ;
    open_image_data.fp = (FILE * *) realloc(open_image_data.fp,(open_image_data.n)*sizeof(FILE *));
    return open_image_data.fp[open_image_data.n - 1] = qpopen (command, "w");
  }
  else {
    static int has_convert = -1;
    if (has_convert < 0) {
      if (which ("convert"))
 has_convert = 
# 451 "/Users/weugene/basilisk/src/output.h" 3 4
              1
# 451 "/Users/weugene/basilisk/src/output.h"
                  ;
      else {
 fprintf (
# 453 "/Users/weugene/basilisk/src/output.h" 3 4
         __stderrp
# 453 "/Users/weugene/basilisk/src/output.h"
             ,
   "open_image(): cannot find 'convert'\n"
   "  falling back to raw PPM outputs\n");
 has_convert = 
# 456 "/Users/weugene/basilisk/src/output.h" 3 4
              0
# 456 "/Users/weugene/basilisk/src/output.h"
                   ;
      }
    }
    if (!has_convert)
      return ppm_fallback (file, "w");

    int len = strlen ("convert ppm:-   ") + strlen (file) +
      (options ? strlen (options) : 0);
    char command[len];
    
# 465 "/Users/weugene/basilisk/src/output.h" 3 4
   __builtin___strcpy_chk (
# 465 "/Users/weugene/basilisk/src/output.h"
   command
# 465 "/Users/weugene/basilisk/src/output.h" 3 4
   , 
# 465 "/Users/weugene/basilisk/src/output.h"
   "convert ppm:- "
# 465 "/Users/weugene/basilisk/src/output.h" 3 4
   , __builtin_object_size (
# 465 "/Users/weugene/basilisk/src/output.h"
   command
# 465 "/Users/weugene/basilisk/src/output.h" 3 4
   , 2 > 1 ? 1 : 0))
# 465 "/Users/weugene/basilisk/src/output.h"
                                     ;
    if (options) {
      
# 467 "/Users/weugene/basilisk/src/output.h" 3 4
     __builtin___strcat_chk (
# 467 "/Users/weugene/basilisk/src/output.h"
     command
# 467 "/Users/weugene/basilisk/src/output.h" 3 4
     , 
# 467 "/Users/weugene/basilisk/src/output.h"
     options
# 467 "/Users/weugene/basilisk/src/output.h" 3 4
     , __builtin_object_size (
# 467 "/Users/weugene/basilisk/src/output.h"
     command
# 467 "/Users/weugene/basilisk/src/output.h" 3 4
     , 2 > 1 ? 1 : 0))
# 467 "/Users/weugene/basilisk/src/output.h"
                              ;
      
# 468 "/Users/weugene/basilisk/src/output.h" 3 4
     __builtin___strcat_chk (
# 468 "/Users/weugene/basilisk/src/output.h"
     command
# 468 "/Users/weugene/basilisk/src/output.h" 3 4
     , 
# 468 "/Users/weugene/basilisk/src/output.h"
     " "
# 468 "/Users/weugene/basilisk/src/output.h" 3 4
     , __builtin_object_size (
# 468 "/Users/weugene/basilisk/src/output.h"
     command
# 468 "/Users/weugene/basilisk/src/output.h" 3 4
     , 2 > 1 ? 1 : 0))
# 468 "/Users/weugene/basilisk/src/output.h"
                          ;
    }
    
# 470 "/Users/weugene/basilisk/src/output.h" 3 4
   __builtin___strcat_chk (
# 470 "/Users/weugene/basilisk/src/output.h"
   command
# 470 "/Users/weugene/basilisk/src/output.h" 3 4
   , 
# 470 "/Users/weugene/basilisk/src/output.h"
   file
# 470 "/Users/weugene/basilisk/src/output.h" 3 4
   , __builtin_object_size (
# 470 "/Users/weugene/basilisk/src/output.h"
   command
# 470 "/Users/weugene/basilisk/src/output.h" 3 4
   , 2 > 1 ? 1 : 0))
# 470 "/Users/weugene/basilisk/src/output.h"
                         ;
    return qpopen (command, "w");
  }
}

void close_image (const char * file, FILE * fp)
{
  
# 477 "/Users/weugene/basilisk/src/output.h" 3 4
 (__builtin_expect(!(
# 477 "/Users/weugene/basilisk/src/output.h"
 0 == 0
# 477 "/Users/weugene/basilisk/src/output.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/output.h", 477, 
# 477 "/Users/weugene/basilisk/src/output.h"
 "pid() == 0"
# 477 "/Users/weugene/basilisk/src/output.h" 3 4
 ) : (void)0)
# 477 "/Users/weugene/basilisk/src/output.h"
                    ;
  if (is_animation (file)) {
    if (!open_image_lookup (file))
      fclose (fp);
  }
  else if (which ("convert"))
    qpclose (fp);
  else
    fclose (fp);
}
# 552 "/Users/weugene/basilisk/src/output.h"
struct OutputPPM {
  scalar f;
  FILE * fp;
  int n;
  char * file;
  double min, max, spread, z;
  
# 558 "/Users/weugene/basilisk/src/output.h" 3 4
 _Bool 
# 558 "/Users/weugene/basilisk/src/output.h"
      linear;
  double box[2][2];
  scalar mask;
  colormap map;
  char * opt;
};


void output_ppm (struct OutputPPM p)
{ ;

  if (p.n == 0) p.n = N;
  if (p.min == 0 && p.max == 0) {
    stats s = statsf (p.f);
    if (p.spread < 0.)
      p.min = s.min, p.max = s.max;
    else {
      double avg = s.sum/s.volume, spread = (p.spread ? p.spread : 5.)*s.stddev;
      p.min = avg - spread; p.max = avg + spread;
    }
  }
  if (p.box[0][0] == 0. && p.box[0][1] == 0. &&
      p.box[1][0] == 0. && p.box[1][1] == 0.) {
    p.box[0][0] = X0; p.box[0][1] = Y0;
    p.box[1][0] = X0 + L0; p.box[1][1] = Y0 + L0;
  }
  if (!p.map)
    p.map = jet;

  double fn = p.n;
  double Delta = (p.box[1][0] - p.box[0][0])/fn;
  int ny = (p.box[1][1] - p.box[0][1])/Delta;
  if (ny % 2) ny++;

  color ** ppm = (color **) matrix_new (ny, p.n, sizeof(color));
  double cmap[127][3];
  p.map (cmap);
  {
   
      for (int j = 0; j < ny; j++) {
 double yp = Delta*j + p.box[0][1] + Delta/2.;
 for (int i = 0; i < p.n; i++) {
   double xp = Delta*i + p.box[0][0] + Delta/2., v;
   if (p.mask.i) {
     if (p.linear) {
       double m = interpolate ((struct _interpolate){p.mask, xp, yp, p.z});
       if (m < 0.)
  v = ((double)1e30);
       else
  v = interpolate ((struct _interpolate){p.f, xp, yp, p.z});
     }
     else {
       Point point = locate ((struct _locate){xp, yp, p.z}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 610 "/Users/weugene/basilisk/src/output.h"

       if (point.level < 0 || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.mask.i] < 0.)
  v = ((double)1e30);
       else
  v = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.f.i];
     }
   }
   else if (p.linear)
     v = interpolate ((struct _interpolate){p.f, xp, yp, p.z});
   else {
     Point point = locate ((struct _locate){xp, yp, p.z}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 620 "/Users/weugene/basilisk/src/output.h"

     v = point.level >= 0 ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.f.i] : ((double)1e30);
   }
   ppm[ny - 1 - j][i] = colormap_color (cmap, v, p.min, p.max);
 }
      }
  }

  if (0 == 0) {




    if (!p.fp) p.fp = 
# 633 "/Users/weugene/basilisk/src/output.h" 3 4
                     __stdoutp
# 633 "/Users/weugene/basilisk/src/output.h"
                              ;
    if (p.file)
      p.fp = open_image (p.file, p.opt);

    fprintf (p.fp, "P6\n%u %u 255\n", p.n, ny);
    fwrite (((void **) ppm)[0], sizeof(color), ny*p.n, p.fp);

    if (p.file)
      close_image (p.file, p.fp);
    else
      fflush (p.fp);
  }






  matrix_free (ppm);
 ; }
# 684 "/Users/weugene/basilisk/src/output.h"
struct OutputGRD {
  scalar f;
  FILE * fp;
  double Delta;
  
# 688 "/Users/weugene/basilisk/src/output.h" 3 4
 _Bool 
# 688 "/Users/weugene/basilisk/src/output.h"
      linear;
  double box[2][2];
  scalar mask;
};


void output_grd (struct OutputGRD p)
{ ;

  if (!p.fp) p.fp = 
# 697 "/Users/weugene/basilisk/src/output.h" 3 4
                   __stdoutp
# 697 "/Users/weugene/basilisk/src/output.h"
                            ;
  if (p.box[0][0] == 0. && p.box[0][1] == 0. &&
      p.box[1][0] == 0. && p.box[1][1] == 0.) {
    p.box[0][0] = X0; p.box[0][1] = Y0;
    p.box[1][0] = X0 + L0; p.box[1][1] = Y0 + L0;
    if (p.Delta == 0) p.Delta = L0/N;
  }

  double Delta = p.Delta;
  int nx = (p.box[1][0] - p.box[0][0])/Delta;
  int ny = (p.box[1][1] - p.box[0][1])/Delta;


  fprintf (p.fp, "ncols          %d\n", nx);
  fprintf (p.fp, "nrows          %d\n", ny);
  fprintf (p.fp, "xllcorner      %g\n", p.box[0][0]);
  fprintf (p.fp, "yllcorner      %g\n", p.box[0][1]);
  fprintf (p.fp, "cellsize       %g\n", Delta);
  fprintf (p.fp, "nodata_value   -9999\n");


  for (int j = ny-1; j >= 0; j--) {
    double yp = Delta*j + p.box[0][1] + Delta/2.;
    for (int i = 0; i < nx; i++) {
      double xp = Delta*i + p.box[0][0] + Delta/2., v;
      if (p.mask.i) {
 if (p.linear) {
   double m = interpolate ((struct _interpolate){p.mask, xp, yp});
   if (m < 0.)
     v = ((double)1e30);
   else
     v = interpolate ((struct _interpolate){p.f, xp, yp});
 }
 else {
   Point point = locate ((struct _locate){xp, yp}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 731 "/Users/weugene/basilisk/src/output.h"

   if (point.level < 0 || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.mask.i] < 0.)
     v = ((double)1e30);
   else
     v = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.f.i];
 }
      }
      else if (p.linear)
 v = interpolate ((struct _interpolate){p.f, xp, yp});
      else {
 Point point = locate ((struct _locate){xp, yp}); int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 741 "/Users/weugene/basilisk/src/output.h"

 v = point.level >= 0 ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.f.i] : ((double)1e30);
      }
      if (v == ((double)1e30))
 fprintf (p.fp, "-9999 ");
      else
 fprintf (p.fp, "%f ", v);
    }
    fprintf (p.fp, "\n");
  }

  fflush (p.fp);
 ; }
# 780 "/Users/weugene/basilisk/src/output.h"
struct OutputGfs {
  FILE * fp;
  scalar * list;
  double t;
  char * file;
  
# 785 "/Users/weugene/basilisk/src/output.h" 3 4
 _Bool 
# 785 "/Users/weugene/basilisk/src/output.h"
      translate;
};

static char * replace (const char * input, int target, int with,
         
# 789 "/Users/weugene/basilisk/src/output.h" 3 4
        _Bool 
# 789 "/Users/weugene/basilisk/src/output.h"
             translate)
{
  if (translate) {
    if (!strcmp (input, "u.x"))
      return strdup("U");
    if (!strcmp (input, "u.y"))
      return strdup("V");
    if (!strcmp (input, "u.z"))
      return strdup("W");
  }
  char * name = strdup(input), * i = name;
  while (*i != '\0') {
    if (*i == target)
      *i = with;
    i++;
  }
  return name;
}


void output_gfs (struct OutputGfs p)
{ ;
  char * fname = p.file;
# 827 "/Users/weugene/basilisk/src/output.h"
  
# 827 "/Users/weugene/basilisk/src/output.h" 3 4
 _Bool 
# 827 "/Users/weugene/basilisk/src/output.h"
      opened = 
# 827 "/Users/weugene/basilisk/src/output.h" 3 4
               0
# 827 "/Users/weugene/basilisk/src/output.h"
                    ;
  if (p.fp == 
# 828 "/Users/weugene/basilisk/src/output.h" 3 4
             ((void *)0)
# 828 "/Users/weugene/basilisk/src/output.h"
                 ) {
    if (fname == 
# 829 "/Users/weugene/basilisk/src/output.h" 3 4
                ((void *)0)
# 829 "/Users/weugene/basilisk/src/output.h"
                    )
      p.fp = 
# 830 "/Users/weugene/basilisk/src/output.h" 3 4
            __stdoutp
# 830 "/Users/weugene/basilisk/src/output.h"
                     ;
    else if (!(p.fp = fopen (fname, "w"))) {
      perror (fname);
      exit (1);
    }
    else
      opened = 
# 836 "/Users/weugene/basilisk/src/output.h" 3 4
              1
# 836 "/Users/weugene/basilisk/src/output.h"
                  ;
  }

  scalar * list = p.list ? p.list : list_copy (all);

  restriction (list);
  fprintf (p.fp,
    "1 0 GfsSimulation GfsBox GfsGEdge { binary = 1"
    " x = %g y = %g ",
    0.5 + X0/L0, 0.5 + Y0/L0);




  if (list != 
# 850 "/Users/weugene/basilisk/src/output.h" 3 4
             ((void *)0) 
# 850 "/Users/weugene/basilisk/src/output.h"
                  && list[0].i != -1) {
    scalar s = list[0];
    char * name = replace (_attribute[s.i].name, '.', '_', p.translate);
    fprintf (p.fp, "variables = %s", name);
    free(name);
    for (int i = 1; i < list_len(list); i++) {
      scalar s = list[i];
      if (_attribute[s.i].name) {
 char * name = replace (_attribute[s.i].name, '.', '_', p.translate);
 fprintf (p.fp, ",%s", name);
 free(name);
      }
    }
    fprintf (p.fp, " ");
  }
  fprintf (p.fp, "} {\n");
  fprintf (p.fp, "  Time { t = %g }\n", t);
  if (L0 != 1.)
    fprintf (p.fp, "  PhysicalParams { L = %g }\n", L0);
  fprintf (p.fp, "  VariableTracerVOF f\n");
  fprintf (p.fp, "}\nGfsBox { x = 0 y = 0 z = 0 } {\n");
# 888 "/Users/weugene/basilisk/src/output.h"
   { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 888 "/Users/weugene/basilisk/src/output.h"
 {



    {






      unsigned flags =
 level == 0 ? 0 :



      child.x == -1 && child.y == -1 ? 0 :
 child.x == -1 && child.y == 1 ? 1 :
 child.x == 1 && child.y == -1 ? 2 :
 3;
# 918 "/Users/weugene/basilisk/src/output.h"
      if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf))
 flags |= (1 << 4);
      fwrite (&flags, sizeof (unsigned), 1, p.fp);
      double a = -1;
      fwrite (&a, sizeof (double), 1, p.fp);
      if (list) for (scalar s = *list, *_i75 = list; ((scalar *)&s)->i >= 0; s = *++_i75)
 if (_attribute[s.i].name) {
   if (_attribute[s.i].v.x.i >= 0) {




     if (_attribute[s.i].v.x.i == s.i) {
       s = _attribute[s.i].v.y;
       a = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] != ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] : (double) ((double)1.79769313486231570814527423731704357e+308L);
     }
     else if (_attribute[s.i].v.y.i == s.i) {
       s = _attribute[s.i].v.x;
       a = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] != ((double)1e30) ? - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] : (double) ((double)1.79769313486231570814527423731704357e+308L);
     }





   }
   else
     a = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0) && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] != ((double)1e30) ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] : (double) ((double)1.79769313486231570814527423731704357e+308L);
   fwrite (&a, sizeof (double), 1, p.fp);
 }
    }
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf))
      continue;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
# 961 "/Users/weugene/basilisk/src/output.h"
    fputs ("}\n", p.fp);
  fflush (p.fp);

  if (!p.list)
    free(list);
  if (opened)
    fclose (p.fp);
# 986 "/Users/weugene/basilisk/src/output.h"
 ; }
# 1010 "/Users/weugene/basilisk/src/output.h"
struct Dump {
  char * file;
  scalar * list;
  FILE * fp;
  
# 1014 "/Users/weugene/basilisk/src/output.h" 3 4
 _Bool 
# 1014 "/Users/weugene/basilisk/src/output.h"
      unbuffered;
};

struct DumpHeader {
  double t;
  long len;
  int i, depth, npe, version;
  coord n;
};

static const int dump_version =

  170901;

static scalar * dump_list (scalar * lista)
{
  scalar * list = ((cm).i >= 65536) ? 
# 1030 "/Users/weugene/basilisk/src/output.h" 3 4
                                   ((void *)0) 
# 1030 "/Users/weugene/basilisk/src/output.h"
                                        : list_concat (((scalar []){cm,{-1}}), 
# 1030 "/Users/weugene/basilisk/src/output.h" 3 4
                                                                               ((void *)0)
# 1030 "/Users/weugene/basilisk/src/output.h"
                                                                                   );
  if (lista) for (scalar s = *lista, *_i76 = lista; ((scalar *)&s)->i >= 0; s = *++_i76)
    if (!_attribute[s.i].face && !_attribute[s.i].nodump && s.i != cm.i)
      list = list_add (list, s);
  return list;
}

static void dump_header (FILE * fp, struct DumpHeader * header, scalar * list)
{
  if (fwrite (header, sizeof(struct DumpHeader), 1, fp) < 1) {
    perror ("dump(): error while writing header");
    exit (1);
  }
  if (list) for (scalar s = *list, *_i77 = list; ((scalar *)&s)->i >= 0; s = *++_i77) {
    unsigned len = strlen(_attribute[s.i].name);
    if (fwrite (&len, sizeof(unsigned), 1, fp) < 1) {
      perror ("dump(): error while writing len");
      exit (1);
    }
    if (fwrite (_attribute[s.i].name, sizeof(char), len, fp) < len) {
      perror ("dump(): error while writing s.name");
      exit (1);
    }
  }
  double o[4] = {X0,Y0,Z0,L0};
  if (fwrite (o, sizeof(double), 4, fp) < 4) {
    perror ("dump(): error while writing coordinates");
    exit (1);
  }
}



void dump (struct Dump p)
{ ;
  FILE * fp = p.fp;
  char def[] = "dump", * file = p.file ? p.file : p.fp ? 
# 1066 "/Users/weugene/basilisk/src/output.h" 3 4
                                                        ((void *)0) 
# 1066 "/Users/weugene/basilisk/src/output.h"
                                                             : def;

  char * name = 
# 1068 "/Users/weugene/basilisk/src/output.h" 3 4
               ((void *)0)
# 1068 "/Users/weugene/basilisk/src/output.h"
                   ;
  if (file) {
    name = (char *) malloc(strlen(file) + 2);
    
# 1071 "/Users/weugene/basilisk/src/output.h" 3 4
   __builtin___strcpy_chk (
# 1071 "/Users/weugene/basilisk/src/output.h"
   name
# 1071 "/Users/weugene/basilisk/src/output.h" 3 4
   , 
# 1071 "/Users/weugene/basilisk/src/output.h"
   file
# 1071 "/Users/weugene/basilisk/src/output.h" 3 4
   , __builtin_object_size (
# 1071 "/Users/weugene/basilisk/src/output.h"
   name
# 1071 "/Users/weugene/basilisk/src/output.h" 3 4
   , 2 > 1 ? 1 : 0))
# 1071 "/Users/weugene/basilisk/src/output.h"
                      ;
    if (!p.unbuffered)
      
# 1073 "/Users/weugene/basilisk/src/output.h" 3 4
     __builtin___strcat_chk (
# 1073 "/Users/weugene/basilisk/src/output.h"
     name
# 1073 "/Users/weugene/basilisk/src/output.h" 3 4
     , 
# 1073 "/Users/weugene/basilisk/src/output.h"
     "~"
# 1073 "/Users/weugene/basilisk/src/output.h" 3 4
     , __builtin_object_size (
# 1073 "/Users/weugene/basilisk/src/output.h"
     name
# 1073 "/Users/weugene/basilisk/src/output.h" 3 4
     , 2 > 1 ? 1 : 0))
# 1073 "/Users/weugene/basilisk/src/output.h"
                       ;
    if ((fp = fopen (name, "w")) == 
# 1074 "/Users/weugene/basilisk/src/output.h" 3 4
                                   ((void *)0)
# 1074 "/Users/weugene/basilisk/src/output.h"
                                       ) {
      perror (name);
      exit (1);
    }
  }
  
# 1079 "/Users/weugene/basilisk/src/output.h" 3 4
 (__builtin_expect(!(
# 1079 "/Users/weugene/basilisk/src/output.h"
 fp
# 1079 "/Users/weugene/basilisk/src/output.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/output.h", 1079, 
# 1079 "/Users/weugene/basilisk/src/output.h"
 "fp"
# 1079 "/Users/weugene/basilisk/src/output.h" 3 4
 ) : (void)0)
# 1079 "/Users/weugene/basilisk/src/output.h"
            ;

  scalar * dlist = dump_list (p.list ? p.list : all);
  scalar size= new_scalar("size");
  scalar * list = list_concat (((scalar []){size,{-1}}), dlist); free(dlist);
  struct DumpHeader header = { t, list_len(list), iter, (grid->depth), 1,
          dump_version };
  dump_header (fp, &header, list);

  subtree_size (size, 
# 1088 "/Users/weugene/basilisk/src/output.h" 3 4
                     0
# 1088 "/Users/weugene/basilisk/src/output.h"
                          );

   { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 1090 "/Users/weugene/basilisk/src/output.h"
 {
    unsigned flags = (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf) ? leaf : 0;
    if (fwrite (&flags, sizeof(unsigned), 1, fp) < 1) {
      perror ("dump(): error while writing flags");
      exit (1);
    }
    if (list) for (scalar s = *list, *_i78 = list; ((scalar *)&s)->i >= 0; s = *++_i78)
      if (fwrite (&((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i], sizeof(double), 1, fp) < 1) {
 perror ("dump(): error while writing scalars");
 exit (1);
      }
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf))
      continue;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }

  free(list);
  if (file) {
    fclose (fp);
    if (!p.unbuffered)
      rename (name, file);
    free(name);
  }
 delete (((scalar []){size,{-1}})); ; }
# 1193 "/Users/weugene/basilisk/src/output.h"

# 1193 "/Users/weugene/basilisk/src/output.h" 3 4
_Bool 
# 1193 "/Users/weugene/basilisk/src/output.h"
    restore (struct Dump p)
{ ;
  FILE * fp = p.fp;
  char * file = p.file;
  if (file && (fp = fopen (file, "r")) == 
# 1197 "/Users/weugene/basilisk/src/output.h" 3 4
                                         ((void *)0)
# 1197 "/Users/weugene/basilisk/src/output.h"
                                             )
    { 
# 1198 "/Users/weugene/basilisk/src/output.h" 3 4
     _Bool 
# 1198 "/Users/weugene/basilisk/src/output.h"
          _ret = 
# 1198 "/Users/weugene/basilisk/src/output.h" 3 4
                  0
# 1198 "/Users/weugene/basilisk/src/output.h"
                       ; ; return _ret; }
  
# 1199 "/Users/weugene/basilisk/src/output.h" 3 4
 (__builtin_expect(!(
# 1199 "/Users/weugene/basilisk/src/output.h"
 fp
# 1199 "/Users/weugene/basilisk/src/output.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/output.h", 1199, 
# 1199 "/Users/weugene/basilisk/src/output.h"
 "fp"
# 1199 "/Users/weugene/basilisk/src/output.h" 3 4
 ) : (void)0)
# 1199 "/Users/weugene/basilisk/src/output.h"
            ;

  struct DumpHeader header;
  if (fread (&header, sizeof(header), 1, fp) < 1) {
    fprintf (
# 1203 "/Users/weugene/basilisk/src/output.h" 3 4
            __stderrp
# 1203 "/Users/weugene/basilisk/src/output.h"
                , "restore(): error: expecting header\n");
    exit (1);
  }


  init_grid (1);
   { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 1206 "/Users/weugene/basilisk/src/output.h"
 {
    (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).pid = 0;
    (*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])))).flags |= active;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
  ((Tree *)grid)->dirty = 
# 1210 "/Users/weugene/basilisk/src/output.h" 3 4
                         1
# 1210 "/Users/weugene/basilisk/src/output.h"
                             ;
# 1231 "/Users/weugene/basilisk/src/output.h"
  
# 1231 "/Users/weugene/basilisk/src/output.h" 3 4
 _Bool 
# 1231 "/Users/weugene/basilisk/src/output.h"
      restore_all = (p.list == all);
  scalar * list = dump_list (p.list ? p.list : all);
  if (header.version == 161020) {
    if (header.len - 1 != list_len (list)) {
      fprintf (
# 1235 "/Users/weugene/basilisk/src/output.h" 3 4
              __stderrp
# 1235 "/Users/weugene/basilisk/src/output.h"
                  ,
        "restore(): error: the list lengths don't match: "
        "%ld (file) != %d (code)\n",
        header.len - 1, list_len (list));
      exit (1);
    }
  }
  else {
    if (header.version != dump_version) {
      fprintf (
# 1244 "/Users/weugene/basilisk/src/output.h" 3 4
              __stderrp
# 1244 "/Users/weugene/basilisk/src/output.h"
                  ,
        "restore(): error: file version mismatch: "
        "%d (file) != %d (code)\n",
        header.version, dump_version);
      exit (1);
    }

    scalar * input = 
# 1251 "/Users/weugene/basilisk/src/output.h" 3 4
                    ((void *)0)
# 1251 "/Users/weugene/basilisk/src/output.h"
                        ;
    for (int i = 0; i < header.len; i++) {
      unsigned len;
      if (fread (&len, sizeof(unsigned), 1, fp) < 1) {
 fprintf (
# 1255 "/Users/weugene/basilisk/src/output.h" 3 4
         __stderrp
# 1255 "/Users/weugene/basilisk/src/output.h"
             , "restore(): error: expecting len\n");
 exit (1);
      }
      char name[len + 1];
      if (fread (name, sizeof(char), len, fp) < 1) {
 fprintf (
# 1260 "/Users/weugene/basilisk/src/output.h" 3 4
         __stderrp
# 1260 "/Users/weugene/basilisk/src/output.h"
             , "restore(): error: expecting s.name\n");
 exit (1);
      }
      name[len] = '\0';

      if (i > 0) {
 
# 1266 "/Users/weugene/basilisk/src/output.h" 3 4
_Bool 
# 1266 "/Users/weugene/basilisk/src/output.h"
     found = 
# 1266 "/Users/weugene/basilisk/src/output.h" 3 4
             0
# 1266 "/Users/weugene/basilisk/src/output.h"
                  ;
 if (list) for (scalar s = *list, *_i81 = list; ((scalar *)&s)->i >= 0; s = *++_i81)
   if (!strcmp (_attribute[s.i].name, name)) {
     input = list_append (input, s);
     found = 
# 1270 "/Users/weugene/basilisk/src/output.h" 3 4
            1
# 1270 "/Users/weugene/basilisk/src/output.h"
                ; break;
   }
 if (!found) {
   if (restore_all) {
     scalar s = new_scalar("s");
     free(_attribute[s.i].name);
     _attribute[s.i].name = strdup(name);
     input = list_append (input, s);
   }
   else
     input = list_append (input, (scalar){0x7fffffff});
 }
      }
    }
    free(list);
    list = input;

    double o[4];
    if (fread (o, sizeof(double), 4, fp) < 4) {
      fprintf (
# 1289 "/Users/weugene/basilisk/src/output.h" 3 4
              __stderrp
# 1289 "/Users/weugene/basilisk/src/output.h"
                  , "restore(): error: expecting coordinates\n");
      exit (1);
    }
    origin ((struct _origin){o[0], o[1], o[2]});
    size (o[3]);
  }
# 1306 "/Users/weugene/basilisk/src/output.h"
  scalar * listm = ((cm).i >= 65536) ? 
# 1306 "/Users/weugene/basilisk/src/output.h" 3 4
                                    ((void *)0) 
# 1306 "/Users/weugene/basilisk/src/output.h"
                                         : (scalar *)((vector []){{fm.x,fm.y},{{-1},{-1}}});



   { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 1310 "/Users/weugene/basilisk/src/output.h"
 {
    unsigned flags;
    if (fread (&flags, sizeof(unsigned), 1, fp) != 1) {
      fprintf (
# 1313 "/Users/weugene/basilisk/src/output.h" 3 4
              __stderrp
# 1313 "/Users/weugene/basilisk/src/output.h"
                  , "restore(): error: expecting 'flags'\n");
      exit (1);
    }

    fseek (fp, sizeof(double), 
# 1317 "/Users/weugene/basilisk/src/output.h" 3 4
                              1
# 1317 "/Users/weugene/basilisk/src/output.h"
                                      );
    if (list) for (scalar s = *list, *_i82 = list; ((scalar *)&s)->i >= 0; s = *++_i82) {
      double val;
      if (fread (&val, sizeof(double), 1, fp) != 1) {
 fprintf (
# 1321 "/Users/weugene/basilisk/src/output.h" 3 4
         __stderrp
# 1321 "/Users/weugene/basilisk/src/output.h"
             , "restore(): error: expecting a scalar\n");
 exit (1);
      }
      if (s.i != 0x7fffffff)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = val;
    }
    if (!(flags & leaf) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf))
      refine_cell (point, listm, 0, 
# 1328 "/Users/weugene/basilisk/src/output.h" 3 4
                                   ((void *)0)
# 1328 "/Users/weugene/basilisk/src/output.h"
                                       );
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf))
      continue;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
  boundary (list);

  boundary (listm);

  scalar * other = 
# 1336 "/Users/weugene/basilisk/src/output.h" 3 4
                  ((void *)0)
# 1336 "/Users/weugene/basilisk/src/output.h"
                      ;
  if (all) for (scalar s = *all, *_i83 = all; ((scalar *)&s)->i >= 0; s = *++_i83)
    if (!list_lookup (list, s) && !list_lookup (listm, s))
      other = list_append (other, s);
  reset (other, 0.);
  free(other);

  free(list);
  if (file)
    fclose (fp);


  while (iter < header.i && events (
# 1348 "/Users/weugene/basilisk/src/output.h" 3 4
                                   0
# 1348 "/Users/weugene/basilisk/src/output.h"
                                        ))
    iter = inext;
  events (
# 1350 "/Users/weugene/basilisk/src/output.h" 3 4
         0
# 1350 "/Users/weugene/basilisk/src/output.h"
              );
  while (t < header.t && events (
# 1351 "/Users/weugene/basilisk/src/output.h" 3 4
                                0
# 1351 "/Users/weugene/basilisk/src/output.h"
                                     ))
    t = tnext;
  t = header.t;
  events (
# 1354 "/Users/weugene/basilisk/src/output.h" 3 4
         0
# 1354 "/Users/weugene/basilisk/src/output.h"
              );

  { 
# 1356 "/Users/weugene/basilisk/src/output.h" 3 4
   _Bool 
# 1356 "/Users/weugene/basilisk/src/output.h"
        _ret = 
# 1356 "/Users/weugene/basilisk/src/output.h" 3 4
                1
# 1356 "/Users/weugene/basilisk/src/output.h"
                    ; ; return _ret; }
 ; }
# 331 "/Users/weugene/basilisk/src/utils.h"
# 12 "/Users/weugene/basilisk/src/run.h"


void run (void)
{ ;
  iter = 0, t = 0., dt = 1.;
  init_grid (N);

  perf.nc = perf.tnc = 0;
  perf.gt = timer_start();
  while (events (
# 21 "/Users/weugene/basilisk/src/run.h" 3 4
                1
# 21 "/Users/weugene/basilisk/src/run.h"
                    )) {





    update_perf();
    iter = inext, t = tnext;
  }




  timer_print (perf.gt, iter, perf.tnc);

  free_grid();
 ; }
# 36 "./../src_local/centered-weugene.h"
# 1 "./timestep.h"
# 1 "/Users/weugene/basilisk/src/timestep.h"

double timestep (const vector u, double dtmax)
{
  static double previous = 0.;
  dtmax /= CFL;
   {


 {
double _dtmax = dtmax;
# 6 "/Users/weugene/basilisk/src/timestep.h"

if (!((cm).i >= 65536)) {
# 6 "/Users/weugene/basilisk/src/timestep.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 6 "/Users/weugene/basilisk/src/timestep.h"
{
# 6 "/Users/weugene/basilisk/src/timestep.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] != 0.) {
      double dt = Delta/fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i]);




      dt *= ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i];

      if (dt < _dtmax) _dtmax = dt;
    } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 6 "/Users/weugene/basilisk/src/timestep.h"
{
# 6 "/Users/weugene/basilisk/src/timestep.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] != 0.) {
      double dt = Delta/fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i]);




      dt *= ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i];

      if (dt < _dtmax) _dtmax = dt;
    } } }} } } }
# 16 "/Users/weugene/basilisk/src/timestep.h"
 ; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 6 "/Users/weugene/basilisk/src/timestep.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 6 "/Users/weugene/basilisk/src/timestep.h"
{
# 6 "/Users/weugene/basilisk/src/timestep.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] != 0.) {
      double dt = Delta/fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i]);




      dt *= _const_cm;

      if (dt < _dtmax) _dtmax = dt;
    } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 6 "/Users/weugene/basilisk/src/timestep.h"
{
# 6 "/Users/weugene/basilisk/src/timestep.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] != 0.) {
      double dt = Delta/fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i]);




      dt *= _const_cm;

      if (dt < _dtmax) _dtmax = dt;
    } } }} } } }
# 16 "/Users/weugene/basilisk/src/timestep.h"
 ; } if (_dtmax < dtmax) dtmax = _dtmax;
;



}
# 16 "/Users/weugene/basilisk/src/timestep.h"
 }
  dtmax *= CFL;
  if (dtmax > previous)
    dtmax = (previous + 0.1*dtmax)/1.1;
  previous = dtmax;
  return dtmax;
}
# 37 "./../src_local/centered-weugene.h"
# 1 "./bcg.h"
# 1 "/Users/weugene/basilisk/src/bcg.h"
# 11 "/Users/weugene/basilisk/src/bcg.h"
void tracer_fluxes (scalar f,
      vector uf,
      vector flux,
      double dt,
       scalar src)
{





  vector g= new_vector("g");
  gradients (((scalar []){f,{-1}}), ((vector []){{g.x,g.y},{{-1},{-1}}}));




   {
if (!((fm.x).i >= 65536) && !((src).i >= 65536)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i]/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i]*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[f.i] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[src.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[src.i])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[g.x.i]*Delta/2.;





    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[fm.y.i] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[fm.y.i]) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[uf.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[uf.y.i])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[fm.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[fm.y.i]);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[f.i] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+-1]) + sizeof(Cell)))[f.i];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/Users/weugene/basilisk/src/bcg.h"
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[flux.x.i] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i];
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i]/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i]*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[f.i] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[src.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[src.i])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[g.y.i]*Delta/2.;





    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[fm.x.i] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[fm.x.i]) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[uf.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[uf.x.i])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[fm.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[fm.x.i]);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[f.i] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+i]) + sizeof(Cell)))[f.i];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/Users/weugene/basilisk/src/bcg.h"
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[flux.y.i] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i];
  } } }} } } }
# 59 "/Users/weugene/basilisk/src/bcg.h"
 ; }
if (((fm.x).i >= 65536) && !((src).i >= 65536)) {
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 28 "/Users/weugene/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i]/(_const_fm.x*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[f.i] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[src.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[src.i])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[g.x.i]*Delta/2.;





    if (_const_fm.y && _const_fm.y) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[uf.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[uf.y.i])/(_const_fm.y + _const_fm.y);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[f.i] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+-1]) + sizeof(Cell)))[f.i];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/Users/weugene/basilisk/src/bcg.h"
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[flux.x.i] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i];
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i]/(_const_fm.y*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[f.i] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[src.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[src.i])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[g.y.i]*Delta/2.;





    if (_const_fm.x && _const_fm.x) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[uf.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[uf.x.i])/(_const_fm.x + _const_fm.x);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[f.i] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+i]) + sizeof(Cell)))[f.i];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/Users/weugene/basilisk/src/bcg.h"
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[flux.y.i] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i];
  } } }} } } }
# 59 "/Users/weugene/basilisk/src/bcg.h"
 ; }
if (!((fm.x).i >= 65536) && ((src).i >= 65536)) {
# 73 "/Users/weugene/basilisk/src/bcg.h"
const double _const_src = _constant[src.i -65536];
(void)(_const_src);
# 28 "/Users/weugene/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i]/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i]*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[f.i] + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[g.x.i]*Delta/2.;





    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[fm.y.i] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[fm.y.i]) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[uf.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[uf.y.i])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[fm.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[fm.y.i]);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[f.i] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+-1]) + sizeof(Cell)))[f.i];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/Users/weugene/basilisk/src/bcg.h"
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[flux.x.i] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i];
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i]/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i]*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[f.i] + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[g.y.i]*Delta/2.;





    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[fm.x.i] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[fm.x.i]) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[uf.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[uf.x.i])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[fm.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[fm.x.i]);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[f.i] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+i]) + sizeof(Cell)))[f.i];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/Users/weugene/basilisk/src/bcg.h"
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[flux.y.i] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i];
  } } }} } } }
# 59 "/Users/weugene/basilisk/src/bcg.h"
 ; }
if (((fm.x).i >= 65536) && ((src).i >= 65536)) {
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 75 "/Users/weugene/basilisk/src/bcg.h"
const double _const_src = _constant[src.i -65536];
(void)(_const_src);
# 28 "/Users/weugene/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i]/(_const_fm.x*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[f.i] + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[g.x.i]*Delta/2.;





    if (_const_fm.y && _const_fm.y) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[uf.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[uf.y.i])/(_const_fm.y + _const_fm.y);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[f.i] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+-1]) + sizeof(Cell)))[f.i];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/Users/weugene/basilisk/src/bcg.h"
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[flux.x.i] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i];
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 28 "/Users/weugene/basilisk/src/bcg.h"
{
# 28 "/Users/weugene/basilisk/src/bcg.h"
 {







    double un = dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i]/(_const_fm.y*Delta + 0.), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    double f2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[f.i] + (_const_src + _const_src)*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[g.y.i]*Delta/2.;





    if (_const_fm.x && _const_fm.x) {
      double vn = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[uf.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[uf.x.i])/(_const_fm.x + _const_fm.x);
      double fyy = vn < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[f.i] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[f.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+i]) + sizeof(Cell)))[f.i];
      f2 -= dt*vn*fyy/(2.*Delta);
    }
# 58 "/Users/weugene/basilisk/src/bcg.h"
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[flux.y.i] = f2*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i];
  } } }} } } }
# 59 "/Users/weugene/basilisk/src/bcg.h"
 ; } }





  boundary_flux (((vector []){{flux.x,flux.y},{{-1},{-1}}}));
 delete (((scalar []){g.x,g.y,{-1}})); }






struct Advection {
  scalar * tracers;
  vector u;
  double dt;
  scalar * src;
};

void advection (struct Advection p)
{




  scalar * lsrc = p.src;
  if (!lsrc) {
    scalar zero= new_const_scalar("zero", 6, 0.);
    if (p.tracers) for (scalar s = *p.tracers, *_i84 = p.tracers; ((scalar *)&s)->i >= 0; s = *++_i84)
      lsrc = list_append (lsrc, zero);
  }

  
# 93 "/Users/weugene/basilisk/src/bcg.h" 3 4
 (__builtin_expect(!(
# 93 "/Users/weugene/basilisk/src/bcg.h"
 list_len(p.tracers) == list_len(lsrc)
# 93 "/Users/weugene/basilisk/src/bcg.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/bcg.h", 93, 
# 93 "/Users/weugene/basilisk/src/bcg.h"
 "list_len(p.tracers) == list_len(lsrc)"
# 93 "/Users/weugene/basilisk/src/bcg.h" 3 4
 ) : (void)0)
# 93 "/Users/weugene/basilisk/src/bcg.h"
                                               ;
  scalar f, src;
  vector uf = p.u;
  scalar * _i2 = p.tracers; scalar * _i3 = lsrc; if (p.tracers) for (f = *p.tracers, src = *lsrc; ((scalar *)&f)->i >= 0; f = *++_i2, src = *++_i3) {
    vector flux= new_face_vector("flux");
    tracer_fluxes (f, p.u, flux, p.dt, src);

     {
if (!((cm).i >= 65536)) {
# 100 "/Users/weugene/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 100 "/Users/weugene/basilisk/src/bcg.h"
{
      {
# 101 "/Users/weugene/basilisk/src/bcg.h"

      {
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] += p.dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[flux.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[flux.x.i])/(Delta*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i]);
      }
# 101 "/Users/weugene/basilisk/src/bcg.h"

      {
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] += p.dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[flux.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[flux.y.i])/(Delta*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i]);
      }}
    } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 100 "/Users/weugene/basilisk/src/bcg.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 100 "/Users/weugene/basilisk/src/bcg.h"
{
      {
# 101 "/Users/weugene/basilisk/src/bcg.h"

      {
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] += p.dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[flux.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[flux.x.i])/(Delta*_const_cm);
      }
# 101 "/Users/weugene/basilisk/src/bcg.h"

      {
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] += p.dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[flux.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[flux.y.i])/(Delta*_const_cm);
      }}
    } } } } }; } }



   delete (((scalar []){flux.x,flux.y,{-1}})); }
  boundary (p.tracers);

  if (!p.src)
    free(lsrc);
}
# 38 "./../src_local/centered-weugene.h"
# 1 "../src_local/./viscosity-weugene.h"
# 1 "./../src_local/./viscosity-weugene.h"
# 1 "./poisson.h"
# 1 "/Users/weugene/basilisk/src/poisson.h"
# 32 "/Users/weugene/basilisk/src/poisson.h"
void mg_cycle (scalar * a, scalar * res, scalar * da,
        void (* relax) (scalar * da, scalar * res,
          int depth, void * data),
        void * data,
        int nrelax, int minlevel, int maxlevel)
{




  restriction (res);





  minlevel = ((minlevel) < (maxlevel) ? (minlevel) : (maxlevel));
  for (int l = minlevel; l <= maxlevel; l++) {




    if (l == minlevel)
       { { for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 55 "/Users/weugene/basilisk/src/poisson.h"

 if (da) for (scalar s = *da, *_i85 = da; ((scalar *)&s)->i >= 0; s = *++_i85)
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = 0.; } } } } }; }}; }; }





    else
       { { if (l <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[l]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = l; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 64 "/Users/weugene/basilisk/src/poisson.h"

 if (da) for (scalar s = *da, *_i86 = da; ((scalar *)&s)->i >= 0; s = *++_i86)
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = bilinear (point, s); } } } }; }}; }





    boundary_level (da, l);
    for (int i = 0; i < nrelax; i++) {
      relax (da, res, l, data);
      boundary_level (da, l);
    }
  }




   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 82 "/Users/weugene/basilisk/src/poisson.h"
 {
    scalar s, ds;
    scalar * _i4 = a; scalar * _i5 = da; if (a) for (s = *a, ds = *da; ((scalar *)&s)->i >= 0; s = *++_i4, ds = *++_i5)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[ds.i];
  } } } } }; }
  boundary (a);
}
# 100 "/Users/weugene/basilisk/src/poisson.h"
int NITERMAX = 100, NITERMIN = 1;
double TOLERANCE = 1e-3;




typedef struct {
  int i;
  double resb, resa;
  double sum;
  int nrelax;
  int minlevel;
} mgstats;
# 123 "/Users/weugene/basilisk/src/poisson.h"
struct MGSolve {
  scalar * a, * b;
  double (* residual) (scalar * a, scalar * b, scalar * res,
         void * data);
  void (* relax) (scalar * da, scalar * res, int depth,
    void * data);
  void * data;

  int nrelax;
  scalar * res;
  int minlevel;
  double tolerance;
};

mgstats mg_solve (struct MGSolve p)
{





  scalar * da = list_clone (p.a), * res = p.res;
  if (!res)
    if (p.a) for (scalar s = *p.a, *_i87 = p.a; ((scalar *)&s)->i >= 0; s = *++_i87) {
      scalar r = new_scalar("r");
      res = list_append (res, r);
    }






  for (int b = 0; b < nboundary; b++)
    if (da) for (scalar s = *da, *_i88 = da; ((scalar *)&s)->i >= 0; s = *++_i88)
      _attribute[s.i].boundary[b] = _attribute[s.i].boundary_homogeneous[b];




  mgstats s = {0};
  double sum = 0.;
   {


 {
double _sum = sum;
# 165 "/Users/weugene/basilisk/src/poisson.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 165 "/Users/weugene/basilisk/src/poisson.h"

    if (p.b) for (scalar s = *p.b, *_i89 = p.b; ((scalar *)&s)->i >= 0; s = *++_i89)
      _sum += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i]; } } } }; sum += _sum;
;



}
# 167 "/Users/weugene/basilisk/src/poisson.h"
 }
  s.sum = sum;
  s.nrelax = p.nrelax > 0 ? p.nrelax : 4;




  double resb;
  resb = s.resb = s.resa = p.residual (p.a, p.b, res, p.data);






  if (p.tolerance == 0.)
    p.tolerance = TOLERANCE;
  for (s.i = 0;
       s.i < NITERMAX && (s.i < NITERMIN || s.resa > p.tolerance);
       s.i++) {
    mg_cycle (p.a, res, da, p.relax, p.data,
       s.nrelax,
       p.minlevel,
       grid->maxdepth);
    s.resa = p.residual (p.a, p.b, res, p.data);
# 200 "/Users/weugene/basilisk/src/poisson.h"
    if (s.resa > TOLERANCE) {
      if (resb/s.resa < 1.2 && s.nrelax < 100)
 s.nrelax++;
      else if (resb/s.resa > 10 && s.nrelax > 2)
 s.nrelax--;
    }







    resb = s.resa;
  }
  s.minlevel = p.minlevel;




  if (s.resa > p.tolerance) {
    scalar v = p.a[0];
    fprintf (
# 222 "/Users/weugene/basilisk/src/poisson.h" 3 4
            __stderrp
# 222 "/Users/weugene/basilisk/src/poisson.h"
                ,
      "WARNING: convergence for %s not reached after %d iterations\n"
      "  res: %g sum: %g nrelax: %d\n", _attribute[v.i].name,
      s.i, s.resa, s.sum, s.nrelax), fflush (
# 225 "/Users/weugene/basilisk/src/poisson.h" 3 4
                                            __stderrp
# 225 "/Users/weugene/basilisk/src/poisson.h"
                                                );
  }




  if (!p.res)
    delete (res), free(res);
  delete (da), free(da);

  return s;
}
# 263 "/Users/weugene/basilisk/src/poisson.h"
struct Poisson {
  scalar a, b;
   vector alpha;
   scalar lambda;
  double tolerance;
  int nrelax, minlevel;
  scalar * res;



};





static void relax (scalar * al, scalar * bl, int l, void * data)
{
  scalar a = al[0], b = bl[0];
  struct Poisson * p = (struct Poisson *) data;
   vector alpha = p->alpha;
   scalar lambda = p->lambda;
# 301 "/Users/weugene/basilisk/src/poisson.h"
  scalar c = a;






   {
if (!((lambda).i >= 65536) && !((alpha.x).i >= 65536)) {
# 308 "/Users/weugene/basilisk/src/poisson.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 308 "/Users/weugene/basilisk/src/poisson.h"
 {
    double n = - ((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[b.i], d = - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[lambda.i]*((Delta)*(Delta));
    {
# 310 "/Users/weugene/basilisk/src/poisson.h"
 {
      n += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[alpha.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[a.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[a.i];
      d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[alpha.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.x.i];
    }
# 310 "/Users/weugene/basilisk/src/poisson.h"
 {
      n += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[alpha.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[a.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[a.i];
      d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[alpha.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.y.i];
    }}
# 324 "/Users/weugene/basilisk/src/poisson.h"
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] = n/d;
  } } } } } }; }}; }; }
if (((lambda).i >= 65536) && !((alpha.x).i >= 65536)) {
const double _const_lambda = _constant[lambda.i -65536];
(void)(_const_lambda);
# 308 "/Users/weugene/basilisk/src/poisson.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 308 "/Users/weugene/basilisk/src/poisson.h"
 {
    double n = - ((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[b.i], d = - _const_lambda*((Delta)*(Delta));
    {
# 310 "/Users/weugene/basilisk/src/poisson.h"
 {
      n += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[alpha.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[a.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[a.i];
      d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[alpha.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.x.i];
    }
# 310 "/Users/weugene/basilisk/src/poisson.h"
 {
      n += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[alpha.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[a.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[a.i];
      d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[alpha.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.y.i];
    }}
# 324 "/Users/weugene/basilisk/src/poisson.h"
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] = n/d;
  } } } } } }; }}; }; }
if (!((lambda).i >= 65536) && ((alpha.x).i >= 65536)) {






const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 308 "/Users/weugene/basilisk/src/poisson.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 308 "/Users/weugene/basilisk/src/poisson.h"
 {
    double n = - ((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[b.i], d = - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[lambda.i]*((Delta)*(Delta));
    {
# 310 "/Users/weugene/basilisk/src/poisson.h"
 {
      n += _const_alpha.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[a.i] + _const_alpha.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[a.i];
      d += _const_alpha.x + _const_alpha.x;
    }
# 310 "/Users/weugene/basilisk/src/poisson.h"
 {
      n += _const_alpha.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[a.i] + _const_alpha.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[a.i];
      d += _const_alpha.y + _const_alpha.y;
    }}
# 324 "/Users/weugene/basilisk/src/poisson.h"
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] = n/d;
  } } } } } }; }}; }; }
if (((lambda).i >= 65536) && ((alpha.x).i >= 65536)) {
const double _const_lambda = _constant[lambda.i -65536];
(void)(_const_lambda);






const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 308 "/Users/weugene/basilisk/src/poisson.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 308 "/Users/weugene/basilisk/src/poisson.h"
 {
    double n = - ((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[b.i], d = - _const_lambda*((Delta)*(Delta));
    {
# 310 "/Users/weugene/basilisk/src/poisson.h"
 {
      n += _const_alpha.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[a.i] + _const_alpha.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[a.i];
      d += _const_alpha.x + _const_alpha.x;
    }
# 310 "/Users/weugene/basilisk/src/poisson.h"
 {
      n += _const_alpha.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[a.i] + _const_alpha.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[a.i];
      d += _const_alpha.y + _const_alpha.y;
    }}
# 324 "/Users/weugene/basilisk/src/poisson.h"
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] = n/d;
  } } } } } }; }}; }; } }
# 343 "/Users/weugene/basilisk/src/poisson.h"
}






static double residual (scalar * al, scalar * bl, scalar * resl, void * data)
{
  scalar a = al[0], b = bl[0], res = resl[0];
  struct Poisson * p = (struct Poisson *) data;
   vector alpha = p->alpha;
   scalar lambda = p->lambda;
  double maxres = 0.;


  vector g= new_face_vector("g");
   {
if (!((alpha.x).i >= 65536)) {
# 360 "/Users/weugene/basilisk/src/poisson.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 360 "/Users/weugene/basilisk/src/poisson.h"
{
# 360 "/Users/weugene/basilisk/src/poisson.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.x.i]*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0]) + sizeof(Cell)))[a.i])/Delta); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 360 "/Users/weugene/basilisk/src/poisson.h"
{
# 360 "/Users/weugene/basilisk/src/poisson.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.y.i]*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1]) + sizeof(Cell)))[a.i])/Delta); } }} } } }
# 361 "/Users/weugene/basilisk/src/poisson.h"
 ; }
if (((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 360 "/Users/weugene/basilisk/src/poisson.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 360 "/Users/weugene/basilisk/src/poisson.h"
{
# 360 "/Users/weugene/basilisk/src/poisson.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.x.i] = _const_alpha.x*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0]) + sizeof(Cell)))[a.i])/Delta); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 360 "/Users/weugene/basilisk/src/poisson.h"
{
# 360 "/Users/weugene/basilisk/src/poisson.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.y.i] = _const_alpha.y*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1]) + sizeof(Cell)))[a.i])/Delta); } }} } } }
# 361 "/Users/weugene/basilisk/src/poisson.h"
 ; } }
  boundary_flux (((vector []){{g.x,g.y},{{-1},{-1}}}));
   {


 {
double _maxres = maxres;
# 363 "/Users/weugene/basilisk/src/poisson.h"

if (!((lambda).i >= 65536)) {
# 363 "/Users/weugene/basilisk/src/poisson.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 363 "/Users/weugene/basilisk/src/poisson.h"
 {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[b.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[lambda.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.i];
    {
# 365 "/Users/weugene/basilisk/src/poisson.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.i] -= (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[g.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.x.i])/Delta;
# 365 "/Users/weugene/basilisk/src/poisson.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.i] -= (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[g.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.y.i])/Delta;}
# 381 "/Users/weugene/basilisk/src/poisson.h"
    if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.i]) > _maxres)
      _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.i]);
  } } } } }; }
if (((lambda).i >= 65536)) {
const double _const_lambda = _constant[lambda.i -65536];
(void)(_const_lambda);
# 363 "/Users/weugene/basilisk/src/poisson.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 363 "/Users/weugene/basilisk/src/poisson.h"
 {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[b.i] - _const_lambda*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.i];
    {
# 365 "/Users/weugene/basilisk/src/poisson.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.i] -= (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[g.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.x.i])/Delta;
# 365 "/Users/weugene/basilisk/src/poisson.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.i] -= (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[g.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.y.i])/Delta;}
# 381 "/Users/weugene/basilisk/src/poisson.h"
    if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.i]) > _maxres)
      _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.i]);
  } } } } }; } if (_maxres > maxres) maxres = _maxres;
;



}
# 383 "/Users/weugene/basilisk/src/poisson.h"
 }
  boundary (resl);
  { double _ret = maxres; delete (((scalar []){g.x,g.y,{-1}})); return _ret; }
 delete (((scalar []){g.x,g.y,{-1}})); }
# 397 "/Users/weugene/basilisk/src/poisson.h"
mgstats poisson (struct Poisson p)
{






  if (!p.alpha.x.i)
    p.alpha = unityf;
  if (!p.lambda.i)
    p.lambda = zeroc;




  vector alpha = p.alpha;
  scalar lambda = p.lambda;
  restriction (((scalar []){alpha.x,alpha.y,lambda,{-1}}));





  double defaultol = TOLERANCE;
  if (p.tolerance)
    TOLERANCE = p.tolerance;

  scalar a = p.a, b = p.b;




  mgstats s = mg_solve ((struct MGSolve){((scalar []){a,{-1}}), ((scalar []){b,{-1}}), residual, relax,
   &p, p.nrelax, p.res, .minlevel = ((1) > (p.minlevel) ? (1) : (p.minlevel))});




  if (p.tolerance)
    TOLERANCE = defaultol;

  return s;
}
# 459 "/Users/weugene/basilisk/src/poisson.h"
struct Project {
  vector uf;
  scalar p;
  vector alpha;
  double dt;
  int nrelax;
};


mgstats project (struct Project q)
{ ;
  vector uf = q.uf;
  scalar p = q.p;
   vector alpha = q.alpha.x.i ? q.alpha : unityf;
  double dt = q.dt ? q.dt : 1.;
  int nrelax = q.nrelax ? q.nrelax : 4;






  scalar div= new_scalar("div");
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 482 "/Users/weugene/basilisk/src/poisson.h"
 {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[div.i] = 0.;
    {
# 484 "/Users/weugene/basilisk/src/poisson.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[div.i] += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[uf.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i];
# 484 "/Users/weugene/basilisk/src/poisson.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[div.i] += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[uf.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i];}
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[div.i] /= dt*Delta;
  } } } } }; }
# 498 "/Users/weugene/basilisk/src/poisson.h"
  mgstats mgp = poisson ((struct Poisson){p, div, alpha,
    .tolerance = TOLERANCE/((dt)*(dt)), .nrelax = nrelax});




   {
if (!((alpha.x).i >= 65536)) {
# 504 "/Users/weugene/basilisk/src/poisson.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 504 "/Users/weugene/basilisk/src/poisson.h"
{
# 504 "/Users/weugene/basilisk/src/poisson.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.x.i]*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0]) + sizeof(Cell)))[p.i])/Delta); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 504 "/Users/weugene/basilisk/src/poisson.h"
{
# 504 "/Users/weugene/basilisk/src/poisson.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.y.i]*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1]) + sizeof(Cell)))[p.i])/Delta); } }} } } }
# 505 "/Users/weugene/basilisk/src/poisson.h"
 ; }
if (((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 504 "/Users/weugene/basilisk/src/poisson.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 504 "/Users/weugene/basilisk/src/poisson.h"
{
# 504 "/Users/weugene/basilisk/src/poisson.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i] -= dt*_const_alpha.x*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0]) + sizeof(Cell)))[p.i])/Delta); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 504 "/Users/weugene/basilisk/src/poisson.h"
{
# 504 "/Users/weugene/basilisk/src/poisson.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i] -= dt*_const_alpha.y*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1]) + sizeof(Cell)))[p.i])/Delta); } }} } } }
# 505 "/Users/weugene/basilisk/src/poisson.h"
 ; } }
  boundary ((scalar *)((vector []){{uf.x,uf.y},{{-1},{-1}}}));

  { mgstats _ret = mgp; delete (((scalar []){div,{-1}})); ; return _ret; }
 delete (((scalar []){div,{-1}})); ; }
# 2 "./../src_local/./viscosity-weugene.h"
# 1 "../src_local/./../src_local/penalization.h"
# 1 "./../src_local/./../src_local/penalization.h"
vector zerocf= {{65536 + 7},{65536 + 8}};



    extern scalar fs;
    double eta_s = 1e-15, nu_s = 0, lambda_slip = 0;
     scalar a_br = {(65536 + 4)}, b_br = {(65536 + 4)};
     vector U_solid = {{65536 + 7},{65536 + 8}};

         vector target_U = {{65536 + 7},{65536 + 8}}, n_sol = {{65536 + 7},{65536 + 8}};
# 46 "./../src_local/./../src_local/penalization.h"
        vector dbp= {{0},{1}}, total_rhs= {{2},{3}}, utau= {{4},{5}}, grad_utau_n= {{6},{7}};
# 61 "./../src_local/./../src_local/penalization.h"
struct Brinkman {
    vector u;
    vector uf;
    scalar rho;
    double dt;
};


void calc_target_U(const vector u, vector target_U, const vector normal){
    if (!((U_solid.x).i >= 65536)) {
if (!((U_solid.x).i >= 65536)) {
# 70 "./../src_local/./../src_local/penalization.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 70 "./../src_local/./../src_local/penalization.h"
 {
# 70 "./../src_local/./../src_local/penalization.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[U_solid.x.i];
# 70 "./../src_local/./../src_local/penalization.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[U_solid.y.i];}; } } } }; }
if (((U_solid.x).i >= 65536)) {
const struct { double x, y; } _const_U_solid = {_constant[U_solid.x.i -65536], _constant[U_solid.y.i - 65536]};
(void)(_const_U_solid);
# 70 "./../src_local/./../src_local/penalization.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 70 "./../src_local/./../src_local/penalization.h"
 {
# 70 "./../src_local/./../src_local/penalization.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i] = _const_U_solid.x;
# 70 "./../src_local/./../src_local/penalization.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i] = _const_U_solid.y;}; } } } }; } }
    if (fabs(lambda_slip) > 0.) {
        double ubyn;



        if (!((U_solid.x).i >= 65536)) {
if (!((U_solid.x).i >= 65536)) {
# 76 "./../src_local/./../src_local/penalization.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 76 "./../src_local/./../src_local/penalization.h"
 {
# 76 "./../src_local/./../src_local/penalization.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] -= ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[U_solid.x.i];
# 76 "./../src_local/./../src_local/penalization.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] -= ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[U_solid.y.i];}; } } } }; }
if (((U_solid.x).i >= 65536)) {
const struct { double x, y; } _const_U_solid = {_constant[U_solid.x.i -65536], _constant[U_solid.y.i - 65536]};
(void)(_const_U_solid);
# 76 "./../src_local/./../src_local/penalization.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 76 "./../src_local/./../src_local/penalization.h"
 {
# 76 "./../src_local/./../src_local/penalization.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] -= _const_U_solid.x;
# 76 "./../src_local/./../src_local/penalization.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] -= _const_U_solid.y;}; } } } }; } }

         { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 78 "./../src_local/./../src_local/penalization.h"
 {
            ubyn = 0;
            {
# 80 "./../src_local/./../src_local/penalization.h"
 ubyn += (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[normal.x.i];
# 80 "./../src_local/./../src_local/penalization.h"
 ubyn += (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[normal.y.i];}
            {
# 81 "./../src_local/./../src_local/penalization.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[utau.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - ubyn*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[normal.x.i];
# 81 "./../src_local/./../src_local/penalization.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[utau.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - ubyn*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[normal.y.i];}
        } } } } }; }
        if (!((U_solid.x).i >= 65536)) {
if (!((U_solid.x).i >= 65536)) {
# 83 "./../src_local/./../src_local/penalization.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 83 "./../src_local/./../src_local/penalization.h"
 {
# 83 "./../src_local/./../src_local/penalization.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[U_solid.x.i];
# 83 "./../src_local/./../src_local/penalization.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[U_solid.y.i];}; } } } }; }
if (((U_solid.x).i >= 65536)) {
const struct { double x, y; } _const_U_solid = {_constant[U_solid.x.i -65536], _constant[U_solid.y.i - 65536]};
(void)(_const_U_solid);
# 83 "./../src_local/./../src_local/penalization.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 83 "./../src_local/./../src_local/penalization.h"
 {
# 83 "./../src_local/./../src_local/penalization.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] += _const_U_solid.x;
# 83 "./../src_local/./../src_local/penalization.h"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] += _const_U_solid.y;}; } } } }; } }
         {
if (!((n_sol.x).i >= 65536)) {
# 84 "./../src_local/./../src_local/penalization.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 84 "./../src_local/./../src_local/penalization.h"
 {
            {
# 85 "./../src_local/./../src_local/penalization.h"
 {
                if (0 < ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i] ) {
                    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[grad_utau_n.x.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[utau.x.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-2][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-2][point.j+0]) + sizeof(Cell)))[utau.x.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+2][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+2][point.j+0]) + sizeof(Cell)))[utau.x.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[utau.x.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[n_sol.x.i] / Delta

                            + ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[utau.x.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-2]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-2]) + sizeof(Cell)))[utau.x.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+2]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+2]) + sizeof(Cell)))[utau.x.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[utau.x.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[n_sol.y.i]/Delta




                            ;
                } else {
                    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[grad_utau_n.x.i] = 0;
                }
                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i] += lambda_slip*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[grad_utau_n.x.i];

            }
# 85 "./../src_local/./../src_local/penalization.h"
 {
                if (0 < ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i] ) {
                    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[grad_utau_n.y.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[utau.y.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-2]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-2]) + sizeof(Cell)))[utau.y.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+2]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+2]) + sizeof(Cell)))[utau.y.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[utau.y.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[n_sol.y.i] / Delta

                            + ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[utau.y.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-2][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-2][point.j+0]) + sizeof(Cell)))[utau.y.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+2][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+2][point.j+0]) + sizeof(Cell)))[utau.y.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[utau.y.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[n_sol.x.i]/Delta




                            ;
                } else {
                    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[grad_utau_n.y.i] = 0;
                }
                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i] += lambda_slip*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[grad_utau_n.y.i];

            }}
        } } } } }; }
if (((n_sol.x).i >= 65536)) {
const struct { double x, y; } _const_n_sol = {_constant[n_sol.x.i -65536], _constant[n_sol.y.i - 65536]};
(void)(_const_n_sol);
# 84 "./../src_local/./../src_local/penalization.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 84 "./../src_local/./../src_local/penalization.h"
 {
            {
# 85 "./../src_local/./../src_local/penalization.h"
 {
                if (0 < ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i] ) {
                    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[grad_utau_n.x.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[utau.x.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-2][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-2][point.j+0]) + sizeof(Cell)))[utau.x.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+2][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+2][point.j+0]) + sizeof(Cell)))[utau.x.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[utau.x.i])*_const_n_sol.x / Delta

                            + ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[utau.x.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-2]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-2]) + sizeof(Cell)))[utau.x.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+2]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+2]) + sizeof(Cell)))[utau.x.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[utau.x.i])*_const_n_sol.y/Delta




                            ;
                } else {
                    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[grad_utau_n.x.i] = 0;
                }
                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i] += lambda_slip*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[grad_utau_n.x.i];

            }
# 85 "./../src_local/./../src_local/penalization.h"
 {
                if (0 < ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i] ) {
                    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[grad_utau_n.y.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[utau.y.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-2]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-2]) + sizeof(Cell)))[utau.y.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+2]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+2]) + sizeof(Cell)))[utau.y.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[utau.y.i])*_const_n_sol.y / Delta

                            + ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[utau.y.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-2][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-2][point.j+0]) + sizeof(Cell)))[utau.y.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+2][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+2][point.j+0]) + sizeof(Cell)))[utau.y.i] - (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[fs.i])*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[utau.y.i])*_const_n_sol.x/Delta




                            ;
                } else {
                    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[grad_utau_n.y.i] = 0;
                }
                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i] += lambda_slip*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[grad_utau_n.y.i];

            }}
        } } } } }; } }
    }
}

void brinkman_correction_u (vector u, double dt){

     {
if (!((target_U.x).i >= 65536)) {
# 107 "./../src_local/./../src_local/penalization.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 107 "./../src_local/./../src_local/penalization.h"
 {
        {
# 108 "./../src_local/./../src_local/penalization.h"
{
            fprintf(
# 109 "./../src_local/./../src_local/penalization.h" 3 4
                   __stderrp
# 109 "./../src_local/./../src_local/penalization.h"
                       , "tU: %g %g\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i]);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] + ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt/eta_s)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i])/(1. + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt/eta_s);

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.x.i] = (+ (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i])/eta_s))/dt;

        }
# 108 "./../src_local/./../src_local/penalization.h"
{
            fprintf(
# 109 "./../src_local/./../src_local/penalization.h" 3 4
                   __stderrp
# 109 "./../src_local/./../src_local/penalization.h"
                       , "tU: %g %g\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i]);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] + ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt/eta_s)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i])/(1. + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt/eta_s);

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.y.i] = (+ (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i])/eta_s))/dt;

        }}
    } } } } }; }
if (((target_U.x).i >= 65536)) {
const struct { double x, y; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536]};
(void)(_const_target_U);
# 107 "./../src_local/./../src_local/penalization.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 107 "./../src_local/./../src_local/penalization.h"
 {
        {
# 108 "./../src_local/./../src_local/penalization.h"
{
            fprintf(
# 109 "./../src_local/./../src_local/penalization.h" 3 4
                   __stderrp
# 109 "./../src_local/./../src_local/penalization.h"
                       , "tU: %g %g\n", _const_target_U.x, _const_target_U.y);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] + ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt/eta_s)*_const_target_U.x)/(1. + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt/eta_s);

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.x.i] = (+ (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - _const_target_U.x)/eta_s))/dt;

        }
# 108 "./../src_local/./../src_local/penalization.h"
{
            fprintf(
# 109 "./../src_local/./../src_local/penalization.h" 3 4
                   __stderrp
# 109 "./../src_local/./../src_local/penalization.h"
                       , "tU: %g %g\n", _const_target_U.y, _const_target_U.x);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] + ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt/eta_s)*_const_target_U.y)/(1. + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt/eta_s);

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.y.i] = (+ (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - _const_target_U.y)/eta_s))/dt;

        }}
    } } } } }; } }
    boundary ((scalar *)((vector []){{u.x,u.y},{{-1},{-1}}}));
}

void brinkman_correction (struct Brinkman p){
    vector u = p.u; double dt = p.dt;
    brinkman_correction_u (u, dt);
}
# 3 "./../src_local/./viscosity-weugene.h"
# 33 "./../src_local/./viscosity-weugene.h"
struct Viscosity {
    vector u;
    vector mu;
    scalar rho;
    double dt;
    int nrelax;
    scalar * res;
};

static void relax_viscosity (scalar*a, scalar*b, int l, void*data)
{
    struct Viscosity*p = (struct Viscosity *) data;
     vector mu = p->mu;
     scalar rho = p->rho;
    double dt = p->dt;
    vector u = (*((vector *)&(a[0]))), r = (*((vector *)&(b[0])));



        vector w = u;

    fprintf(
# 54 "./../src_local/./viscosity-weugene.h" 3 4
           __stderrp
# 54 "./../src_local/./viscosity-weugene.h"
               , "relax_viscosity\n");
     {
if (!((rho).i >= 65536) && !((mu.x).i >= 65536) && !((target_U.x).i >= 65536)) {
# 55 "./../src_local/./viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 55 "./../src_local/./viscosity-weugene.h"
 {
        {
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
                                  + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                                  - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i]/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i]/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).x
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.x.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i]/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]




                    ) );
        }
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
                                  + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                                  - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i]/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i]/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).y
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.y.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i]/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]




                    ) );
        }}
    } } } } } }; }}; }; }
if (((rho).i >= 65536) && !((mu.x).i >= 65536) && !((target_U.x).i >= 65536)) {
const double _const_rho = _constant[rho.i -65536];
(void)(_const_rho);
# 55 "./../src_local/./viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 55 "./../src_local/./viscosity-weugene.h"
 {
        {
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
                                  + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                                  - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i]/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i]/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).x
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.x.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i]/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]




                    ) );
        }
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
                                  + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                                  - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i]/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i]/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).y
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.y.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i]/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]




                    ) );
        }}
    } } } } } }; }}; }; }
if (!((rho).i >= 65536) && ((mu.x).i >= 65536) && !((target_U.x).i >= 65536)) {






const struct { double x, y; } _const_mu = {_constant[mu.x.i -65536], _constant[mu.y.i - 65536]};
(void)(_const_mu);
# 55 "./../src_local/./viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 55 "./../src_local/./viscosity-weugene.h"
 {
        {
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
                                  + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                                  - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i]/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
            + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i]/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).x
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.x + 2.*_const_mu.x
                    + _const_mu.y + _const_mu.y
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.x.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]

                    + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i]/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.x + 2.*_const_mu.x

                    + _const_mu.y + _const_mu.y




                    ) );
        }
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
                                  + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                                  - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i]/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
            + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i]/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).y
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.y + 2.*_const_mu.y
                    + _const_mu.x + _const_mu.x
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.y.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]

                    + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i]/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.y + 2.*_const_mu.y

                    + _const_mu.x + _const_mu.x




                    ) );
        }}
    } } } } } }; }}; }; }
if (((rho).i >= 65536) && ((mu.x).i >= 65536) && !((target_U.x).i >= 65536)) {
const double _const_rho = _constant[rho.i -65536];
(void)(_const_rho);






const struct { double x, y; } _const_mu = {_constant[mu.x.i -65536], _constant[mu.y.i - 65536]};
(void)(_const_mu);
# 55 "./../src_local/./viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 55 "./../src_local/./viscosity-weugene.h"
 {
        {
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
                                  + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                                  - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i]/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
            + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i]/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).x
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.x + 2.*_const_mu.x
                    + _const_mu.y + _const_mu.y
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.x.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]

                    + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i]/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.x + 2.*_const_mu.x

                    + _const_mu.y + _const_mu.y




                    ) );
        }
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
                                  + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                                  - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i]/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
            + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i]/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).y
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.y + 2.*_const_mu.y
                    + _const_mu.x + _const_mu.x
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.y.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]

                    + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i]/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.y + 2.*_const_mu.y

                    + _const_mu.x + _const_mu.x




                    ) );
        }}
    } } } } } }; }}; }; }
if (!((rho).i >= 65536) && !((mu.x).i >= 65536) && ((target_U.x).i >= 65536)) {
# 135 "./../src_local/./viscosity-weugene.h"
const struct { double x, y; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536]};
(void)(_const_target_U);
# 55 "./../src_local/./viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 55 "./../src_local/./viscosity-weugene.h"
 {
        {
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
                                  + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                                  - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.x/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.x/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).x
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.x.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.x/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]




                    ) );
        }
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
                                  + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                                  - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.y/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.y/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).y
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.y.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.y/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]




                    ) );
        }}
    } } } } } }; }}; }; }
if (((rho).i >= 65536) && !((mu.x).i >= 65536) && ((target_U.x).i >= 65536)) {
const double _const_rho = _constant[rho.i -65536];
(void)(_const_rho);
# 137 "./../src_local/./viscosity-weugene.h"
const struct { double x, y; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536]};
(void)(_const_target_U);
# 55 "./../src_local/./viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 55 "./../src_local/./viscosity-weugene.h"
 {
        {
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
                                  + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                                  - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.x/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.x/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).x
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.x.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.x/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]




                    ) );
        }
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
                                  + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                                  - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.y/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.y/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).y
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.y.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.y/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[mu.y.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]

                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[mu.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]




                    ) );
        }}
    } } } } } }; }}; }; }
if (!((rho).i >= 65536) && ((mu.x).i >= 65536) && ((target_U.x).i >= 65536)) {






const struct { double x, y; } _const_mu = {_constant[mu.x.i -65536], _constant[mu.y.i - 65536]};
(void)(_const_mu);
# 137 "./../src_local/./viscosity-weugene.h"
const struct { double x, y; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536]};
(void)(_const_target_U);
# 55 "./../src_local/./viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 55 "./../src_local/./viscosity-weugene.h"
 {
        {
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
                                  + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                                  - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.x/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
            + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.x/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).x
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.x + 2.*_const_mu.x
                    + _const_mu.y + _const_mu.y
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.x.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]

                    + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.x/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.x + 2.*_const_mu.x

                    + _const_mu.y + _const_mu.y




                    ) );
        }
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
                                  + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                                  - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.y/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
            + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.y/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).y
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.y + 2.*_const_mu.y
                    + _const_mu.x + _const_mu.x
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.y.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]

                    + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.y/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i])*(2.*_const_mu.y + 2.*_const_mu.y

                    + _const_mu.x + _const_mu.x




                    ) );
        }}
    } } } } } }; }}; }; }
if (((rho).i >= 65536) && ((mu.x).i >= 65536) && ((target_U.x).i >= 65536)) {
const double _const_rho = _constant[rho.i -65536];
(void)(_const_rho);






const struct { double x, y; } _const_mu = {_constant[mu.x.i -65536], _constant[mu.y.i - 65536]};
(void)(_const_mu);
# 139 "./../src_local/./viscosity-weugene.h"
const struct { double x, y; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536]};
(void)(_const_target_U);
# 55 "./../src_local/./viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 55 "./../src_local/./viscosity-weugene.h"
 {
        {
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
                                  + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                                  - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.x/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]
            + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.x/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).x
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.x + 2.*_const_mu.x
                    + _const_mu.y + _const_mu.y
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.x.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] + 2.*_const_mu.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i]

                    + _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.y.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.y.i])/4.)
                    - _const_mu.y*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.x/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).x
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.x + 2.*_const_mu.x

                    + _const_mu.y + _const_mu.y




                    ) );
        }
# 56 "./../src_local/./viscosity-weugene.h"
{
            double numm, denn, n1, n2, n3;
            n1 = (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
                                  + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                               (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                                  - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                                            (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            );
            n2 = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.y/eta_s);
            n3 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta));
            numm = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]
            + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
            )
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.y/eta_s)
            + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)));

            denn = (((Delta)*(Delta))*((coord){1.,1.}).y
            + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
            + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.y + 2.*_const_mu.y
                    + _const_mu.x + _const_mu.x
            ) );
            fprintf(
# 84 "./../src_local/./viscosity-weugene.h" 3 4
                   __stderrp
# 84 "./../src_local/./viscosity-weugene.h"
                       , "n1=%g n2=%g n3=%g numm=%g denn=%g \n", n1, n2, n3, numm, denn);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.y.i] = ((1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] + 2.*_const_mu.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i]

                    + _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                        (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
                    - _const_mu.x*(- ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                         (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)
# 102 "./../src_local/./viscosity-weugene.h"
                    )
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.y/eta_s)
                    + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]*((Delta)*(Delta)))/(((Delta)*(Delta))*((coord){1.,1.}).y
                    + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)
                    + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(dt/_const_rho)*(2.*_const_mu.y + 2.*_const_mu.y

                    + _const_mu.x + _const_mu.x




                    ) );
        }}
    } } } } } }; }}; }; } }







    fprintf(
# 123 "./../src_local/./viscosity-weugene.h" 3 4
           __stderrp
# 123 "./../src_local/./viscosity-weugene.h"
               , "norm(u)>0.001\n");
     {
if (!((target_U.x).i >= 65536)) {
# 124 "./../src_local/./viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 124 "./../src_local/./viscosity-weugene.h"
 if ((sqrt(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i])) + ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i]))))>0.001) fprintf(
# 124 "./../src_local/./viscosity-weugene.h" 3 4
                                                                   __stderrp
# 124 "./../src_local/./viscosity-weugene.h"
                                                                       , "+++tU: %g %g u: %15.10g %15.10g w: %15.10g %15.10g dbp: %15.10g %15.10g rhs: %g %g fs: %g dbpN: %15.10g %15.10g Num: %15.10g %15.10g Den: %15.10g\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i], (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i])/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i])/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i]/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i]/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)); } } } } }; }}; }; }
if (((target_U.x).i >= 65536)) {
const struct { double x, y; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536]};
(void)(_const_target_U);
# 124 "./../src_local/./viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 124 "./../src_local/./viscosity-weugene.h"
 if ((sqrt(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i])) + ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i]))))>0.001) fprintf(
# 124 "./../src_local/./viscosity-weugene.h" 3 4
                                                                   __stderrp
# 124 "./../src_local/./viscosity-weugene.h"
                                                                       , "+++tU: %g %g u: %15.10g %15.10g w: %15.10g %15.10g dbp: %15.10g %15.10g rhs: %g %g fs: %g dbpN: %15.10g %15.10g Num: %15.10g %15.10g Den: %15.10g\n", _const_target_U.x, _const_target_U.y, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i], (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - _const_target_U.x)/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - _const_target_U.y)/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.x/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.y/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)); } } } } }; }}; }; } }

    fprintf(
# 126 "./../src_local/./viscosity-weugene.h" 3 4
           __stderrp
# 126 "./../src_local/./viscosity-weugene.h"
               , "fs[]>0\n");
     {
if (!((target_U.x).i >= 65536)) {
# 127 "./../src_local/./viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 127 "./../src_local/./viscosity-weugene.h"
 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i]>0.1) fprintf(
# 127 "./../src_local/./viscosity-weugene.h" 3 4
                               __stderrp
# 127 "./../src_local/./viscosity-weugene.h"
                                   , "===tU: %g %g u: %15.10g %15.10g w: %15.10g %15.10g dbp: %15.10g %15.10g rhs: %g %g fs: %g dbpN: %15.10g %15.10g Num: %15.10g %15.10g Den: %15.10g\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i], (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i])/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i])/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i]/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i]/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)); } } } } }; }}; }; }
if (((target_U.x).i >= 65536)) {
const struct { double x, y; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536]};
(void)(_const_target_U);
# 127 "./../src_local/./viscosity-weugene.h"
{ for (int _l1 = l; _l1 >= 0; _l1--) { if (_l1 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[_l1]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = _l1; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; if (_l1 == l || (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf)) {{
# 127 "./../src_local/./viscosity-weugene.h"
 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i]>0.1) fprintf(
# 127 "./../src_local/./viscosity-weugene.h" 3 4
                               __stderrp
# 127 "./../src_local/./viscosity-weugene.h"
                                   , "===tU: %g %g u: %15.10g %15.10g w: %15.10g %15.10g dbp: %15.10g %15.10g rhs: %g %g fs: %g dbpN: %15.10g %15.10g Num: %15.10g %15.10g Den: %15.10g\n", _const_target_U.x, _const_target_U.y, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[w.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i], (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - _const_target_U.x)/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - _const_target_U.y)/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.x/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))*_const_target_U.y/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(((Delta)*(Delta))/eta_s)); } } } } }; }}; }; } }







}

static double residual_viscosity (scalar * a, scalar * b, scalar * resl, void * data) {
    struct Viscosity * p = (struct Viscosity *) data;
     vector mu = p->mu;
     scalar rho = p->rho;
    double dt = p->dt;
    vector u = (*((vector *)&(a[0]))), r = (*((vector *)&(b[0]))), res = (*((vector *)&(resl[0])));
    double maxres = 0, d = 0;
    fprintf(
# 144 "./../src_local/./viscosity-weugene.h" 3 4
           __stderrp
# 144 "./../src_local/./viscosity-weugene.h"
               , "residual_viscosity\n");






    vector delete_me= new_vector("delete_me");
    {
# 152 "./../src_local/./viscosity-weugene.h"
 {
        vector taux= new_face_vector("taux");
         {
if (!((mu.x).i >= 65536)) {
# 154 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 154 "./../src_local/./viscosity-weugene.h"
{
# 154 "./../src_local/./viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.x.i] = 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i])/Delta; } }} } } }
# 155 "./../src_local/./viscosity-weugene.h"
 ; }
if (((mu.x).i >= 65536)) {
const struct { double x, y; } _const_mu = {_constant[mu.x.i -65536], _constant[mu.y.i - 65536]};
(void)(_const_mu);
# 154 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 154 "./../src_local/./viscosity-weugene.h"
{
# 154 "./../src_local/./viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.x.i] = 2.*_const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i])/Delta; } }} } } }
# 155 "./../src_local/./viscosity-weugene.h"
 ; } }

         {
if (!((mu.x).i >= 65536)) {
# 157 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 157 "./../src_local/./viscosity-weugene.h"
{
# 157 "./../src_local/./viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)/Delta; } }} } } }
# 160 "./../src_local/./viscosity-weugene.h"
 ; }
if (((mu.x).i >= 65536)) {
const struct { double x, y; } _const_mu = {_constant[mu.x.i -65536], _constant[mu.y.i - 65536]};
(void)(_const_mu);
# 157 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 157 "./../src_local/./viscosity-weugene.h"
{
# 157 "./../src_local/./viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.y.i] = _const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.y.i])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i])/4.)/Delta; } }} } } }
# 160 "./../src_local/./viscosity-weugene.h"
 ; } }







        boundary_flux (((vector []){{taux.x,taux.y},{{-1},{-1}}}));
         {


 {
double _maxres = maxres;
# 169 "./../src_local/./viscosity-weugene.h"

if (!((target_U.x).i >= 65536) && !((rho).i >= 65536)) {
# 169 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 169 "./../src_local/./viscosity-weugene.h"
 {
            d = 0;
            {
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[taux.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.x.i];}
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[taux.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.y.i];}}
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]
                      + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i])/eta_s)
                      - ((coord){1.,1.}).x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*d/(Delta*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i]);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i];
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.x.i]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.x.i]);
        } } } } }; }
if (((target_U.x).i >= 65536) && !((rho).i >= 65536)) {
const struct { double x, y; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536]};
(void)(_const_target_U);
# 169 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 169 "./../src_local/./viscosity-weugene.h"
 {
            d = 0;
            {
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[taux.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.x.i];}
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[taux.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.y.i];}}
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]
                      + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - _const_target_U.x)/eta_s)
                      - ((coord){1.,1.}).x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*d/(Delta*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i]);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.x.i] = _const_target_U.x;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.x.i]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.x.i]);
        } } } } }; }
if (!((target_U.x).i >= 65536) && ((rho).i >= 65536)) {
# 191 "./../src_local/./viscosity-weugene.h"
const double _const_rho = _constant[rho.i -65536];
(void)(_const_rho);
# 169 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 169 "./../src_local/./viscosity-weugene.h"
 {
            d = 0;
            {
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[taux.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.x.i];}
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[taux.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.y.i];}}
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]
                      + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i])/eta_s)
                      - ((coord){1.,1.}).x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*d/(Delta*_const_rho);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i];
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.x.i]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.x.i]);
        } } } } }; }
if (((target_U.x).i >= 65536) && ((rho).i >= 65536)) {
const struct { double x, y; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536]};
(void)(_const_target_U);
# 193 "./../src_local/./viscosity-weugene.h"
const double _const_rho = _constant[rho.i -65536];
(void)(_const_rho);
# 169 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 169 "./../src_local/./viscosity-weugene.h"
 {
            d = 0;
            {
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[taux.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.x.i];}
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[taux.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.y.i];}}
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i]
                      + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - _const_target_U.x)/eta_s)
                      - ((coord){1.,1.}).x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*d/(Delta*_const_rho);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.x.i] = _const_target_U.x;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.x.i]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.x.i]);
        } } } } }; } if (_maxres > maxres) maxres = _maxres;
;



}
# 177 "./../src_local/./viscosity-weugene.h"
 }
     delete (((scalar []){taux.x,taux.y,{-1}})); }
# 152 "./../src_local/./viscosity-weugene.h"
 {
        vector taux= new_face_vector("taux");
         {
if (!((mu.y).i >= 65536)) {
# 154 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 154 "./../src_local/./viscosity-weugene.h"
{
# 154 "./../src_local/./viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.y.i] = 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i])/Delta; } }} } } }
# 155 "./../src_local/./viscosity-weugene.h"
 ; }
if (((mu.y).i >= 65536)) {
const struct { double x, y; } _const_mu = {_constant[mu.y.i -65536], _constant[mu.x.i - 65536]};
(void)(_const_mu);
# 154 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 154 "./../src_local/./viscosity-weugene.h"
{
# 154 "./../src_local/./viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.y.i] = 2.*_const_mu.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i])/Delta; } }} } } }
# 155 "./../src_local/./viscosity-weugene.h"
 ; } }

         {
if (!((mu.y).i >= 65536)) {
# 157 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 157 "./../src_local/./viscosity-weugene.h"
{
# 157 "./../src_local/./viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mu.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)/Delta; } }} } } }
# 160 "./../src_local/./viscosity-weugene.h"
 ; }
if (((mu.y).i >= 65536)) {
const struct { double x, y; } _const_mu = {_constant[mu.y.i -65536], _constant[mu.x.i - 65536]};
(void)(_const_mu);
# 157 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 157 "./../src_local/./viscosity-weugene.h"
{
# 157 "./../src_local/./viscosity-weugene.h"

            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.x.i] = _const_mu.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.y.i] +
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.x.i])/4. -
                     (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.x.i])/4.)/Delta; } }} } } }
# 160 "./../src_local/./viscosity-weugene.h"
 ; } }







        boundary_flux (((vector []){{taux.x,taux.y},{{-1},{-1}}}));
         {


 {
double _maxres = maxres;
# 169 "./../src_local/./viscosity-weugene.h"

if (!((target_U.y).i >= 65536) && !((rho).i >= 65536)) {
# 169 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 169 "./../src_local/./viscosity-weugene.h"
 {
            d = 0;
            {
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[taux.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.y.i];}
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[taux.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.x.i];}}
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]
                      + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i])/eta_s)
                      - ((coord){1.,1.}).y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*d/(Delta*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i]);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i];
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.y.i]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.y.i]);
        } } } } }; }
if (((target_U.y).i >= 65536) && !((rho).i >= 65536)) {
const struct { double x, y; } _const_target_U = {_constant[target_U.y.i -65536], _constant[target_U.x.i - 65536]};
(void)(_const_target_U);
# 169 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 169 "./../src_local/./viscosity-weugene.h"
 {
            d = 0;
            {
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[taux.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.y.i];}
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[taux.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.x.i];}}
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]
                      + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - _const_target_U.y)/eta_s)
                      - ((coord){1.,1.}).y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*d/(Delta*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[rho.i]);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.y.i] = _const_target_U.y;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.y.i]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.y.i]);
        } } } } }; }
if (!((target_U.y).i >= 65536) && ((rho).i >= 65536)) {
# 191 "./../src_local/./viscosity-weugene.h"
const double _const_rho = _constant[rho.i -65536];
(void)(_const_rho);
# 169 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 169 "./../src_local/./viscosity-weugene.h"
 {
            d = 0;
            {
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[taux.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.y.i];}
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[taux.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.x.i];}}
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]
                      + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i])/eta_s)
                      - ((coord){1.,1.}).y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*d/(Delta*_const_rho);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i];
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.y.i]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.y.i]);
        } } } } }; }
if (((target_U.y).i >= 65536) && ((rho).i >= 65536)) {
const struct { double x, y; } _const_target_U = {_constant[target_U.y.i -65536], _constant[target_U.x.i - 65536]};
(void)(_const_target_U);
# 193 "./../src_local/./viscosity-weugene.h"
const double _const_rho = _constant[rho.i -65536];
(void)(_const_rho);
# 169 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 169 "./../src_local/./viscosity-weugene.h"
 {
            d = 0;
            {
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[taux.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.y.i];}
# 171 "./../src_local/./viscosity-weugene.h"
 {d += ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[taux.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[taux.x.i];}}
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i]
                      + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - _const_target_U.y)/eta_s)
                      - ((coord){1.,1.}).y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] + (1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*d/(Delta*_const_rho);
            ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.y.i] = _const_target_U.y;
            if (fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.y.i]) > _maxres) _maxres = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.y.i]);
        } } } } }; } if (_maxres > maxres) maxres = _maxres;
;



}
# 177 "./../src_local/./viscosity-weugene.h"
 }
     delete (((scalar []){taux.x,taux.y,{-1}})); }}
    boundary (resl);

         {
if (!((target_U.x).i >= 65536)) {
# 181 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 181 "./../src_local/./viscosity-weugene.h"
{
            {
# 182 "./../src_local/./viscosity-weugene.h"
 {
                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.x.i] = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i])/eta_s)/dt;
                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.x.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i] + ((coord){1.,1.}).x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i])/dt;
            }
# 182 "./../src_local/./viscosity-weugene.h"
 {
                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.y.i] = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i])/eta_s)/dt;
                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.y.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i] + ((coord){1.,1.}).y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i])/dt;
            }}
        } } } } }; }
if (((target_U.x).i >= 65536)) {
const struct { double x, y; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536]};
(void)(_const_target_U);
# 181 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 181 "./../src_local/./viscosity-weugene.h"
{
            {
# 182 "./../src_local/./viscosity-weugene.h"
 {
                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.x.i] = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - _const_target_U.x)/eta_s)/dt;
                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.x.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i] + ((coord){1.,1.}).x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i])/dt;
            }
# 182 "./../src_local/./viscosity-weugene.h"
 {
                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.y.i] = + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*dt*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - _const_target_U.y)/eta_s)/dt;
                ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.y.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[res.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i] + ((coord){1.,1.}).y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i])/dt;
            }}
        } } } } }; } }

        fprintf(
# 188 "./../src_local/./viscosity-weugene.h" 3 4
               __stderrp
# 188 "./../src_local/./viscosity-weugene.h"
                   , "norm(u)>0.001\n");
         {
if (!((target_U.x).i >= 65536)) {
# 189 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 189 "./../src_local/./viscosity-weugene.h"
 if ((sqrt(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i])) + ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i]))))>0.001) fprintf(
# 189 "./../src_local/./viscosity-weugene.h" 3 4
                                                                   __stderrp
# 189 "./../src_local/./viscosity-weugene.h"
                                                                       , "***tU: %g %g u: %g %g dbp: %g %g rhs: %g %g fs: %g dbpN: %g %g r: %g %g Nrhs: %g %g\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i], (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i])/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i])/eta_s), ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.x.i],((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.y.i]); } } } }; }
if (((target_U.x).i >= 65536)) {
const struct { double x, y; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536]};
(void)(_const_target_U);
# 189 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 189 "./../src_local/./viscosity-weugene.h"
 if ((sqrt(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i])) + ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i]))))>0.001) fprintf(
# 189 "./../src_local/./viscosity-weugene.h" 3 4
                                                                   __stderrp
# 189 "./../src_local/./viscosity-weugene.h"
                                                                       , "***tU: %g %g u: %g %g dbp: %g %g rhs: %g %g fs: %g dbpN: %g %g r: %g %g Nrhs: %g %g\n", _const_target_U.x, _const_target_U.y, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i], (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - _const_target_U.x)/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - _const_target_U.y)/eta_s), ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.x.i],((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.y.i]); } } } }; } }
        fprintf(
# 190 "./../src_local/./viscosity-weugene.h" 3 4
               __stderrp
# 190 "./../src_local/./viscosity-weugene.h"
                   , "fs[]>0\n");
         {
if (!((target_U.x).i >= 65536)) {
# 191 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 191 "./../src_local/./viscosity-weugene.h"
 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i]>0.1) fprintf(
# 191 "./../src_local/./viscosity-weugene.h" 3 4
                               __stderrp
# 191 "./../src_local/./viscosity-weugene.h"
                                   , "---tU: %g %g u: %g %g dbp: %g %g rhs: %g %g fs: %g dbpN: %g %g r: %g %g Nrhs: %g %g\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i], (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i])/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i])/eta_s), ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.x.i],((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.y.i]); } } } }; }
if (((target_U.x).i >= 65536)) {
const struct { double x, y; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536]};
(void)(_const_target_U);
# 191 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 191 "./../src_local/./viscosity-weugene.h"
 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i]>0.1) fprintf(
# 191 "./../src_local/./viscosity-weugene.h" 3 4
                               __stderrp
# 191 "./../src_local/./viscosity-weugene.h"
                                   , "---tU: %g %g u: %g %g dbp: %g %g rhs: %g %g fs: %g dbpN: %g %g r: %g %g Nrhs: %g %g\n", _const_target_U.x, _const_target_U.y, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i], (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - _const_target_U.x)/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - _const_target_U.y)/eta_s), ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.x.i],((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[delete_me.y.i]); } } } }; } }




    { double _ret = maxres; delete (((scalar []){delete_me.x,delete_me.y,{-1}})); return _ret; }
 delete (((scalar []){delete_me.x,delete_me.y,{-1}})); }




mgstats viscosity (struct Viscosity p){ ;
# 211 "./../src_local/./viscosity-weugene.h"
    vector u = p.u, r= new_vector("r");
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 212 "./../src_local/./viscosity-weugene.h"
 {
# 212 "./../src_local/./viscosity-weugene.h"
{ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i];}
# 212 "./../src_local/./viscosity-weugene.h"
{ ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[r.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i];}} } } } }; }
    vector mu = p.mu;
    scalar rho = p.rho;
    restriction (((scalar []){mu.x,mu.y,rho,{-1}}));
     {
if (!((target_U.x).i >= 65536)) {
# 216 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 216 "./../src_local/./viscosity-weugene.h"
 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i]>0.1) fprintf(
# 216 "./../src_local/./viscosity-weugene.h" 3 4
                               __stderrp
# 216 "./../src_local/./viscosity-weugene.h"
                                   , "!!!tU: %g %g u: %g %g dbp: %g %g rhs: %g %g fs: %g dbpN: %g %g\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i], (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.x.i])/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[target_U.y.i])/eta_s)); } } } }; }
if (((target_U.x).i >= 65536)) {
const struct { double x, y; } _const_target_U = {_constant[target_U.x.i -65536], _constant[target_U.y.i - 65536]};
(void)(_const_target_U);
# 216 "./../src_local/./viscosity-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 216 "./../src_local/./viscosity-weugene.h"
 if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i]>0.1) fprintf(
# 216 "./../src_local/./viscosity-weugene.h" 3 4
                               __stderrp
# 216 "./../src_local/./viscosity-weugene.h"
                                   , "!!!tU: %g %g u: %g %g dbp: %g %g rhs: %g %g fs: %g dbpN: %g %g\n", _const_target_U.x, _const_target_U.y, ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[dbp.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[total_rhs.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i], (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] - _const_target_U.x)/eta_s), (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i])*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] - _const_target_U.y)/eta_s)); } } } }; } }


    { mgstats _ret = mg_solve ((struct MGSolve){(scalar *)((vector []){{u.x,u.y},{{-1},{-1}}}), (scalar *)((vector []){{r.x,r.y},{{-1},{-1}}}), residual_viscosity, relax_viscosity, &p, p.nrelax, p.res}); delete (((scalar []){r.x,r.y,{-1}})); ; return _ret; }
 delete (((scalar []){r.x,r.y,{-1}})); ; }
# 45 "./../src_local/centered-weugene.h"
# 56 "./../src_local/centered-weugene.h"
scalar p= {8};
vector u= {{9},{10}}, g= {{11},{12}};
scalar pf= {13};
vector uf= {{14},{15}};
# 82 "./../src_local/centered-weugene.h"
 vector mu = {{65536 + 0},{65536 + 1}}, a = {{65536 + 0},{65536 + 1}}, alpha = {{65536 + 2},{65536 + 3}}, kappa = {{65536 + 0},{65536 + 1}};
 scalar rho = {(65536 + 4)};
mgstats mgp, mgpf, mgu;

# 85 "./../src_local/centered-weugene.h" 3 4
_Bool 
# 85 "./../src_local/centered-weugene.h"
    stokes = 
# 85 "./../src_local/centered-weugene.h" 3 4
             0
# 85 "./../src_local/centered-weugene.h"
                  ;
# 103 "./../src_local/centered-weugene.h"
static void _set_boundary0 (void) { _attribute[p.i].boundary[right] = _boundary0; _attribute[p.i].boundary_homogeneous[right] = _boundary0_homogeneous; }
static void _set_boundary1 (void) { _attribute[p.i].boundary[left] = _boundary1; _attribute[p.i].boundary_homogeneous[left] = _boundary1_homogeneous; }
# 113 "./../src_local/centered-weugene.h"
static void _set_boundary2 (void) { _attribute[p.i].boundary[top] = _boundary2; _attribute[p.i].boundary_homogeneous[top] = _boundary2_homogeneous; }
static void _set_boundary3 (void) { _attribute[p.i].boundary[bottom] = _boundary3; _attribute[p.i].boundary_homogeneous[bottom] = _boundary3_homogeneous; }
# 138 "./../src_local/centered-weugene.h"
static int defaults_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i = 0); *ip = i; *tp = t; return ret; } static int defaults (const int i, const double t, Event * _ev) { ;
{

  CFL = 0.8;




  _attribute[p.i].nodump = _attribute[pf.i].nodump = 
# 146 "./../src_local/centered-weugene.h" 3 4
                                                    1
# 146 "./../src_local/centered-weugene.h"
                                                        ;




  if (alpha.x.i == unityf.x.i) {
    alpha = fm;
    rho = cm;
  }
  else if (!((alpha.x).i >= 65536)) {
    vector alphav = alpha;
     {
if (!((fm.x).i >= 65536)) {
# 157 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 157 "./../src_local/centered-weugene.h"
{
# 157 "./../src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alphav.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i]; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 157 "./../src_local/centered-weugene.h"
{
# 157 "./../src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alphav.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i]; } }} } } }
# 158 "./../src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536)) {
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 157 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 157 "./../src_local/centered-weugene.h"
{
# 157 "./../src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alphav.x.i] = _const_fm.x; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 157 "./../src_local/centered-weugene.h"
{
# 157 "./../src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alphav.y.i] = _const_fm.y; } }} } } }
# 158 "./../src_local/centered-weugene.h"
 ; } }
    boundary ((scalar *)((vector []){{alpha.x,alpha.y},{{-1},{-1}}}));
  }






  _attribute[uf.x.i].refine = refine_face_solenoidal;
# 185 "./../src_local/centered-weugene.h"
 ; } return 0; }





double dtmax;

static int init_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i = 0); *ip = i; *tp = t; return ret; } static int init (const int i, const double t, Event * _ev) { ;
{
  boundary ((scalar *)((vector []){{u.x,u.y},{{-1},{-1}}}));
  ;
   {
if (!((fm.x).i >= 65536)) {
# 197 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 197 "./../src_local/centered-weugene.h"
{
# 197 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i]*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0]) + sizeof(Cell)))[u.x.i])/2.); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 197 "./../src_local/centered-weugene.h"
{
# 197 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i]*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1]) + sizeof(Cell)))[u.y.i])/2.); } }} } } }
# 198 "./../src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536)) {
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 197 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 197 "./../src_local/centered-weugene.h"
{
# 197 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i] = _const_fm.x*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0]) + sizeof(Cell)))[u.x.i])/2.); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 197 "./../src_local/centered-weugene.h"
{
# 197 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i] = _const_fm.y*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1]) + sizeof(Cell)))[u.y.i])/2.); } }} } } }
# 198 "./../src_local/centered-weugene.h"
 ; } }
  boundary ((scalar *)((vector []){{uf.x,uf.y},{{-1},{-1}}}));




  event ("properties");





  dtmax = DT;
  event ("stability");
 ; } return 0; }
# 221 "./../src_local/centered-weugene.h"
static int set_dtmax_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int set_dtmax (const int i, const double t, Event * _ev) { ; dtmax = DT; ; return 0; }

static int stability_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int stability (const int i, const double t, Event * _ev) { ; {
  dt = dtnext (stokes ? dtmax : timestep (uf, dtmax));
 ; } return 0; }







static int vof_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int vof (const int i, const double t, Event * _ev) { ; ; ; return 0; }
static int tracer_advection_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int tracer_advection (const int i, const double t, Event * _ev) { ; ; ; return 0; }






static int properties_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int properties (const int i, const double t, Event * _ev) { ; {
  boundary (((scalar []){alpha.x,alpha.y,mu.x,mu.y,rho,kappa.x,kappa.y,{-1}}));
 ; } return 0; }

static int tracer_diffusion_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int tracer_diffusion (const int i, const double t, Event * _ev) { ; ; ; return 0; }
# 257 "./../src_local/centered-weugene.h"
void prediction()
{
  vector du;
  {
# 260 "./../src_local/centered-weugene.h"
 {
    scalar s = new_scalar("s");
    du.x = s;
  }
# 260 "./../src_local/centered-weugene.h"
 {
    scalar s = new_scalar("s");
    du.y = s;
  }}

  if (_attribute[u.x.i].gradient)
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 266 "./../src_local/centered-weugene.h"

      {
# 267 "./../src_local/centered-weugene.h"
 {





   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[du.x.i] = _attribute[u.x.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i])/Delta;
      }
# 267 "./../src_local/centered-weugene.h"
 {





   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[du.y.i] = _attribute[u.y.i].gradient (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i])/Delta;
      }} } } } }; }
  else
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 276 "./../src_local/centered-weugene.h"

      {
# 277 "./../src_local/centered-weugene.h"
 {





   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[du.x.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i])/(2.*Delta);
    }
# 277 "./../src_local/centered-weugene.h"
 {





   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[du.y.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i])/(2.*Delta);
    }} } } } }; }
  boundary ((scalar *)((vector []){{du.x,du.y},{{-1},{-1}}}));

  ;
   {
if (!((fm.x).i >= 65536)) {
# 288 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 288 "./../src_local/centered-weugene.h"
{
# 288 "./../src_local/centered-weugene.h"
 {
    double un = dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i])/(2.*Delta), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[u.x.i] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[g.x.i])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[du.x.i]*Delta/2.;

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[fm.y.i] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[fm.y.i]) {
      double fyy = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[u.y.i] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[u.x.i] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+-1]) + sizeof(Cell)))[u.x.i];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[u.y.i]*fyy/(2.*Delta);
    }







    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i] *= ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i];
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 288 "./../src_local/centered-weugene.h"
{
# 288 "./../src_local/centered-weugene.h"
 {
    double un = dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i])/(2.*Delta), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[u.y.i] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[g.y.i])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[du.y.i]*Delta/2.;

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[fm.x.i] && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[fm.x.i]) {
      double fyy = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[u.x.i] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[u.y.i] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+i]) + sizeof(Cell)))[u.y.i];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[u.x.i]*fyy/(2.*Delta);
    }







    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i] *= ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i];
  } } }} } } }
# 305 "./../src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536)) {
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 288 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 288 "./../src_local/centered-weugene.h"
{
# 288 "./../src_local/centered-weugene.h"
 {
    double un = dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[u.x.i])/(2.*Delta), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[u.x.i] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[g.x.i])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[du.x.i]*Delta/2.;

    if (_const_fm.y && _const_fm.y) {
      double fyy = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[u.y.i] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+1]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[u.x.i] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[u.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+-1]) + sizeof(Cell)))[u.x.i];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[u.y.i]*fyy/(2.*Delta);
    }







    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i] *= _const_fm.x;
  } } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 288 "./../src_local/centered-weugene.h"
{
# 288 "./../src_local/centered-weugene.h"
 {
    double un = dt*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[u.y.i])/(2.*Delta), s = ((un) > 0 ? 1 : -1);
    int i = -(s + 1.)/2.;
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[u.y.i] + (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[g.y.i])*dt/4. + s*(1. - s*un)*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[du.y.i]*Delta/2.;

    if (_const_fm.x && _const_fm.x) {
      double fyy = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[u.x.i] < 0. ? ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+i]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[u.y.i] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[u.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+i]) + sizeof(Cell)))[u.y.i];
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i] -= dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[u.x.i]*fyy/(2.*Delta);
    }







    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i] *= _const_fm.y;
  } } }} } } }
# 305 "./../src_local/centered-weugene.h"
 ; } }
  boundary ((scalar *)((vector []){{uf.x,uf.y},{{-1},{-1}}}));

  delete ((scalar *)((vector []){{du.x,du.y},{{-1},{-1}}}));
}
# 320 "./../src_local/centered-weugene.h"
static int advection_term_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int advection_term (const int i, const double t, Event * _ev) { ;
{
  if (!stokes) {
    prediction();
    mgpf = project ((struct Project){uf, pf, alpha, dt/2., mgpf.nrelax});
    advection ((struct Advection){(scalar *)((vector []){{u.x,u.y},{{-1},{-1}}}), uf, dt, (scalar *)((vector []){{g.x,g.y},{{-1},{-1}}})});
  }
 ; } return 0; }







static void correction (double dt)
{
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 337 "./../src_local/centered-weugene.h"

    {
# 338 "./../src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] += dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.x.i];
# 338 "./../src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] += dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.y.i];}; } } } }; }
  boundary ((scalar *)((vector []){{u.x,u.y},{{-1},{-1}}}));
}
# 350 "./../src_local/centered-weugene.h"
static int viscous_term_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int viscous_term (const int i, const double t, Event * _ev) { ;
{
  if ((((mu.x).i >= 65536) ? _constant[(mu.x).i - 65536] : ((double)1e30)) != 0.) {
    correction (dt);
    mgu = viscosity ((struct Viscosity){u, mu, rho, dt, mgu.nrelax});
    correction (-dt);
  }




  if (!((a.x).i >= 65536)) {
    vector af = a;
    ;
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 364 "./../src_local/centered-weugene.h"
{
# 364 "./../src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[af.x.i] = 0.; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 364 "./../src_local/centered-weugene.h"
{
# 364 "./../src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[af.y.i] = 0.; } }} } } }
# 365 "./../src_local/centered-weugene.h"
 ; }
  }
 ; } return 0; }
# 386 "./../src_local/centered-weugene.h"
static int acceleration_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int acceleration (const int i, const double t, Event * _ev) { ;
{
  ;
   {
if (!((fm.x).i >= 65536) && !((a.x).i >= 65536)) {
# 389 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 389 "./../src_local/centered-weugene.h"
{
# 389 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i]*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0]) + sizeof(Cell)))[u.x.i])/2.) + dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.x.i]); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 389 "./../src_local/centered-weugene.h"
{
# 389 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i]*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1]) + sizeof(Cell)))[u.y.i])/2.) + dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.y.i]); } }} } } }
# 390 "./../src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536) && !((a.x).i >= 65536)) {
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 389 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 389 "./../src_local/centered-weugene.h"
{
# 389 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i] = _const_fm.x*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0]) + sizeof(Cell)))[u.x.i])/2.) + dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.x.i]); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 389 "./../src_local/centered-weugene.h"
{
# 389 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i] = _const_fm.y*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1]) + sizeof(Cell)))[u.y.i])/2.) + dt*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.y.i]); } }} } } }
# 390 "./../src_local/centered-weugene.h"
 ; }
if (!((fm.x).i >= 65536) && ((a.x).i >= 65536)) {
# 404 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 389 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 389 "./../src_local/centered-weugene.h"
{
# 389 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i]*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0]) + sizeof(Cell)))[u.x.i])/2.) + dt*_const_a.x); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 389 "./../src_local/centered-weugene.h"
{
# 389 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i]*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1]) + sizeof(Cell)))[u.y.i])/2.) + dt*_const_a.y); } }} } } }
# 390 "./../src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536) && ((a.x).i >= 65536)) {
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 406 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 389 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 389 "./../src_local/centered-weugene.h"
{
# 389 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i] = _const_fm.x*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0 -1][point.j+0]) + sizeof(Cell)))[u.x.i])/2.) + dt*_const_a.x); } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 389 "./../src_local/centered-weugene.h"
{
# 389 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i] = _const_fm.y*(((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0 -1]) + sizeof(Cell)))[u.y.i])/2.) + dt*_const_a.y); } }} } } }
# 390 "./../src_local/centered-weugene.h"
 ; } }
  boundary ((scalar *)((vector []){{uf.x,uf.y},{a.x,a.y},{{-1},{-1}}}));
 ; } return 0; }
# 401 "./../src_local/centered-weugene.h"
void centered_gradient (scalar p, vector g)
{





  vector gf= new_face_vector("gf");
   {
if (!((fm.x).i >= 65536) && !((a.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 409 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[p.i])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[p.i])/Delta; } }} } } }
# 410 "./../src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536) && !((a.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 409 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.x.i] = _const_fm.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[p.i])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.y.i] = _const_fm.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[p.i])/Delta; } }} } } }
# 410 "./../src_local/centered-weugene.h"
 ; }
if (!((fm.x).i >= 65536) && ((a.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 424 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 409 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i]*_const_a.x - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[p.i])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i]*_const_a.y - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[p.i])/Delta; } }} } } }
# 410 "./../src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536) && ((a.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 426 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 409 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.x.i] = _const_fm.x*_const_a.x - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.x.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[p.i])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.y.i] = _const_fm.y*_const_a.y - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.y.i]*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[p.i])/Delta; } }} } } }
# 410 "./../src_local/centered-weugene.h"
 ; }
if (!((fm.x).i >= 65536) && !((a.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 436 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 409 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.x.i] - _const_alpha.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[p.i])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.y.i] - _const_alpha.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[p.i])/Delta; } }} } } }
# 410 "./../src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536) && !((a.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 438 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 409 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.x.i] = _const_fm.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.x.i] - _const_alpha.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[p.i])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.y.i] = _const_fm.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.y.i] - _const_alpha.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[p.i])/Delta; } }} } } }
# 410 "./../src_local/centered-weugene.h"
 ; }
if (!((fm.x).i >= 65536) && ((a.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 424 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 438 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 409 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i]*_const_a.x - _const_alpha.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[p.i])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i]*_const_a.y - _const_alpha.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[p.i])/Delta; } }} } } }
# 410 "./../src_local/centered-weugene.h"
 ; }
if (((fm.x).i >= 65536) && ((a.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 426 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 440 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 409 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.x.i] = _const_fm.x*_const_a.x - _const_alpha.x*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[p.i])/Delta; } }} { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 409 "./../src_local/centered-weugene.h"
{
# 409 "./../src_local/centered-weugene.h"

    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.y.i] = _const_fm.y*_const_a.y - _const_alpha.y*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[p.i])/Delta; } }} } } }
# 410 "./../src_local/centered-weugene.h"
 ; } }
  boundary_flux (((vector []){{gf.x,gf.y},{{-1},{-1}}}));





  ;
   {
if (!((fm.x).i >= 65536)) {
# 418 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 418 "./../src_local/centered-weugene.h"

    {
# 419 "./../src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.x.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[gf.x.i])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[fm.x.i] + 1e-15);
# 419 "./../src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.y.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[gf.y.i])/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[fm.y.i] + 1e-15);}; } } } }; }
if (((fm.x).i >= 65536)) {
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 418 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 418 "./../src_local/centered-weugene.h"

    {
# 419 "./../src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.x.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.x.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[gf.x.i])/(_const_fm.x + _const_fm.x + 1e-15);
# 419 "./../src_local/centered-weugene.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[g.y.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[gf.y.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[gf.y.i])/(_const_fm.y + _const_fm.y + 1e-15);}; } } } }; } }
  boundary ((scalar *)((vector []){{g.x,g.y},{{-1},{-1}}}));
 delete (((scalar []){gf.x,gf.y,{-1}})); }






static int projection_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int projection (const int i, const double t, Event * _ev) { ;
{
  mgp = project ((struct Project){uf, p, alpha, dt, mgp.nrelax});
  centered_gradient (p, g);




  correction (dt);
 ; } return 0; }


static int brinkman_penalization_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int brinkman_penalization (const int i, const double t, Event * _ev) { ; {

 ; } return 0; }





static int end_timestep_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int end_timestep (const int i, const double t, Event * _ev) { ; ; ; return 0; }




static int vtk_file_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int vtk_file (const int i, const double t, Event * _ev) { ; ; ; return 0; }
# 463 "./../src_local/centered-weugene.h"
static int adapt_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int adapt (const int i, const double t, Event * _ev) { ; {







  event ("properties");
 ; } return 0; }
# 482 "./../src_local/centered-weugene.h"
void MinMaxValues(scalar * list, double * arr_eps) {
  double arr[10][2];
  int ilist = 0;
  if (list) for (scalar s = *list, *_i90 = list; ((scalar *)&s)->i >= 0; s = *++_i90) {
    double mina= ((double)1e30), maxa= -((double)1e30);
     {


 {
double _mina = mina; double _maxa = maxa;
# 487 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 487 "./../src_local/centered-weugene.h"
{
      if (fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i]) < _mina) _mina = fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i]);
      if (fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i]) > _maxa) _maxa = fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i]);
    } } } } }; if (_mina < mina) mina = _mina;
;
 if (_maxa > maxa) maxa = _maxa;
;



}
# 490 "./../src_local/centered-weugene.h"
 }
    arr[ilist][0] = mina;
    arr[ilist][1] = maxa;
    ilist++;

  }

  for (int i = 0; i < ilist; i++){



    arr_eps[i] *= 0.5*(arr[i][0] + arr[i][1]);




  }
}

stats statsf_weugene (scalar f, scalar fs)
{
    double dvr, min = 1e100, max = -1e100, sum = 0., sum2 = 0., volume = 0.;
     {


 {
double _sum = sum; double _sum2 = sum2; double _volume = volume; double _max = max; double _min = min;
# 512 "./../src_local/centered-weugene.h"

if (!((cm).i >= 65536)) {
# 512 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 513 "./../src_local/centered-weugene.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i] < 1. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] != ((double)1e30)) {
        dvr = (((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i])*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i]);
        _volume += dvr;
        _sum += dvr*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
        _sum2 += dvr*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i]));
        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] > _max) _max = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] < _min) _min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
    } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 512 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 513 "./../src_local/centered-weugene.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i] < 1. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] != ((double)1e30)) {
        dvr = (((Delta)*(Delta))*_const_cm)*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i]);
        _volume += dvr;
        _sum += dvr*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
        _sum2 += dvr*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i]));
        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] > _max) _max = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] < _min) _min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
    } } } } }; } sum += _sum;
;
 sum2 += _sum2;
;
 volume += _volume;
;
 if (_max > max) max = _max;
;
 if (_min < min) min = _min;
;



}
# 521 "./../src_local/centered-weugene.h"
 }
    stats s;
    s.min = min, s.max = max, s.sum = sum, s.volume = volume;
    if (volume > 0.)
        sum2 -= sum*sum/volume;
    s.stddev = sum2 > 0. ? sqrt(sum2/volume) : 0.;
    return s;
}

stats statsf_weugene2 (scalar f, scalar fs)
{
    double dvr, min = 1e100, max = -1e100, sum = 0., sum2 = 0., volume = 0.;
     {


 {
double _sum = sum; double _sum2 = sum2; double _volume = volume; double _max = max; double _min = min;
# 533 "./../src_local/centered-weugene.h"

if (!((cm).i >= 65536)) {
# 533 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 534 "./../src_local/centered-weugene.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i] == 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] != ((double)1e30)) {
        dvr = (((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i])*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i]);
        _volume += dvr;
        _sum += dvr*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
        _sum2 += dvr*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i]));
        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] > _max) _max = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] < _min) _min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
    } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 533 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 534 "./../src_local/centered-weugene.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i] == 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] != ((double)1e30)) {
        dvr = (((Delta)*(Delta))*_const_cm)*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i]);
        _volume += dvr;
        _sum += dvr*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
        _sum2 += dvr*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i])*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i]));
        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] > _max) _max = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] < _min) _min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i];
    } } } } }; } sum += _sum;
;
 sum2 += _sum2;
;
 volume += _volume;
;
 if (_max > max) max = _max;
;
 if (_min < min) min = _min;
;



}
# 542 "./../src_local/centered-weugene.h"
 }
    stats s;
    s.min = min, s.max = max, s.sum = sum, s.volume = volume;
    if (volume > 0.)
        sum2 -= sum*sum/volume;
    s.stddev = sum2 > 0. ? sqrt(sum2/volume) : 0.;
    return s;
}

norm normf_weugene (scalar f, scalar fs)
{
  double dvr, avg = 0., rms = 0., max = 0., volume = 0.;
   {


 {
double _max = max; double _avg = avg; double _rms = rms; double _volume = volume;
# 554 "./../src_local/centered-weugene.h"

if (!((cm).i >= 65536)) {
# 554 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 555 "./../src_local/centered-weugene.h"

  if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i] < 1. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] != ((double)1e30)) {
    dvr = (((Delta)*(Delta))*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[cm.i])*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i]);
    double v = fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i]);
    if (v > _max) _max = v;
    _volume += dvr;
    _avg += dvr*v;
    _rms += dvr*((v)*(v));
  } } } } }; }
if (((cm).i >= 65536)) {
const double _const_cm = _constant[cm.i -65536];
(void)(_const_cm);
# 554 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 555 "./../src_local/centered-weugene.h"

  if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i] < 1. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] != ((double)1e30)) {
    dvr = (((Delta)*(Delta))*_const_cm)*(1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i]);
    double v = fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i]);
    if (v > _max) _max = v;
    _volume += dvr;
    _avg += dvr*v;
    _rms += dvr*((v)*(v));
  } } } } }; } if (_max > max) max = _max;
;
 avg += _avg;
;
 rms += _rms;
;
 volume += _volume;
;



}
# 563 "./../src_local/centered-weugene.h"
 }
  norm n;
  n.avg = volume ? avg/volume : 0.;
  n.rms = volume ? sqrt(rms/volume) : 0.;
  n.max = max;
  n.volume = volume;
  return n;
}

double change_weugene (scalar s, scalar sn, scalar fs)
{
  double max = 0.;
   {


 {
double _max = max;
# 575 "./../src_local/centered-weugene.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 575 "./../src_local/centered-weugene.h"
 {
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i] < 1) {
      double ds = fabs (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[sn.i]);
      if (ds > _max)
        _max = ds;
    }
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[sn.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i];
  } } } } }; if (_max > max) max = _max;
;



}
# 582 "./../src_local/centered-weugene.h"
 }
  return max;
}
# 7 "karman_GI.c"
# 1 "view.h"
# 1 "/Users/weugene/basilisk/src/view.h"
# 61 "/Users/weugene/basilisk/src/view.h"
# 1 "/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 1 3
# 40 "/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 3
# 1 "/System/Library/Frameworks/OpenGL.framework/Headers/gltypes.h" 1 3
# 9 "/System/Library/Frameworks/OpenGL.framework/Headers/gltypes.h" 3

# 9 "/System/Library/Frameworks/OpenGL.framework/Headers/gltypes.h" 3
typedef uint32_t GLbitfield;
typedef uint8_t GLboolean;
typedef int8_t GLbyte;
typedef float GLclampf;
typedef uint32_t GLenum;
typedef float GLfloat;
typedef int32_t GLint;
typedef int16_t GLshort;
typedef int32_t GLsizei;
typedef uint8_t GLubyte;
typedef uint32_t GLuint;
typedef uint16_t GLushort;
typedef void GLvoid;


typedef char GLchar;


typedef char GLcharARB;
typedef void *GLhandleARB;

typedef double GLdouble;
typedef double GLclampd;

typedef int32_t GLfixed;


typedef uint16_t GLhalf;


typedef uint16_t GLhalfARB;


typedef int64_t GLint64;
typedef struct __GLsync *GLsync;
typedef uint64_t GLuint64;


typedef int64_t GLint64EXT;
typedef uint64_t GLuint64EXT;


typedef intptr_t GLintptr;
typedef intptr_t GLsizeiptr;


typedef intptr_t GLintptrARB;
typedef intptr_t GLsizeiptrARB;
# 41 "/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 2 3


# 1 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 1 3
# 2152 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glClampColorARB(GLenum target, GLenum clamp);







extern void glDrawBuffersARB(GLsizei n, const GLenum *bufs);
# 2171 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex);
extern void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex);
extern void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint base_vertex);
extern void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei primcount, const GLint *base_vertex);
# 2183 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
extern void glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
# 2211 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern GLboolean glIsRenderbuffer(GLuint renderbuffer);
extern void glBindRenderbuffer(GLenum target, GLuint renderbuffer);
extern void glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers);
extern void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers);
extern void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
extern void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params);
extern GLboolean glIsFramebuffer(GLuint framebuffer);
extern void glBindFramebuffer(GLenum target, GLuint framebuffer);
extern void glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers);
extern void glGenFramebuffers(GLsizei n, GLuint *framebuffers);
extern GLenum glCheckFramebufferStatus(GLenum target);
extern void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params);
extern void glGenerateMipmap(GLenum target);
extern void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
extern void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
extern void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);







extern void glVertexAttribDivisorARB(GLuint index, GLuint divisor);







extern void glSampleCoverageARB(GLclampf value, GLboolean invert);
# 2287 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glActiveTextureARB(GLenum texture);
extern void glClientActiveTextureARB(GLenum texture);
extern void glMultiTexCoord1dARB(GLenum target, GLdouble s);
extern void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord1fARB(GLenum target, GLfloat s);
extern void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord1iARB(GLenum target, GLint s);
extern void glMultiTexCoord1ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord1sARB(GLenum target, GLshort s);
extern void glMultiTexCoord1svARB(GLenum target, const GLshort *v);
extern void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t);
extern void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t);
extern void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t);
extern void glMultiTexCoord2ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t);
extern void glMultiTexCoord2svARB(GLenum target, const GLshort *v);
extern void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r);
extern void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r);
extern void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r);
extern void glMultiTexCoord3ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r);
extern void glMultiTexCoord3svARB(GLenum target, const GLshort *v);
extern void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q);
extern void glMultiTexCoord4ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
extern void glMultiTexCoord4svARB(GLenum target, const GLshort *v);
# 2335 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glGenQueriesARB(GLsizei n, GLuint *ids);
extern void glDeleteQueriesARB(GLsizei n, const GLuint *ids);
extern GLboolean glIsQueryARB(GLuint id);
extern void glBeginQueryARB(GLenum target, GLuint id);
extern void glEndQueryARB(GLenum target);
extern void glGetQueryivARB(GLenum target, GLenum pname, GLint *params);
extern void glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params);
extern void glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params);
# 2351 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPointParameterfARB(GLenum pname, GLfloat param);
extern void glPointParameterfvARB(GLenum pname, const GLfloat *params);







extern void glProvokingVertex(GLenum mode);
# 2406 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glDeleteObjectARB(GLhandleARB obj);
extern GLhandleARB glGetHandleARB(GLenum pname);
extern void glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj);
extern GLhandleARB glCreateShaderObjectARB(GLenum shaderType);
extern void glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB* const *string, const GLint *length);
extern void glCompileShaderARB(GLhandleARB shaderObj);
extern GLhandleARB glCreateProgramObjectARB(void);
extern void glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj);
extern void glLinkProgramARB(GLhandleARB programObj);
extern void glUseProgramObjectARB(GLhandleARB programObj);
extern void glValidateProgramARB(GLhandleARB programObj);
extern void glUniform1fARB(GLint location, GLfloat v0);
extern void glUniform2fARB(GLint location, GLfloat v0, GLfloat v1);
extern void glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern void glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern void glUniform1iARB(GLint location, GLint v0);
extern void glUniform2iARB(GLint location, GLint v0, GLint v1);
extern void glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2);
extern void glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern void glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform1ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniform2ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniform3ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniform4ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params);
extern void glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params);
extern void glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
extern void glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
extern GLint glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name);
extern void glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
extern void glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params);
extern void glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params);
extern void glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
# 2458 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern GLsync glFenceSync(GLenum condition, GLbitfield flags);
extern GLboolean glIsSync(GLsync sync);
extern void glDeleteSync(GLsync sync);
extern GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern void glGetInteger64v(GLenum pname, GLint64 *params);
extern void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
# 2478 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glGetCompressedTexImageARB(GLenum target, GLint level, GLvoid *data);
# 2495 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glLoadTransposeMatrixfARB(const GLfloat *m);
extern void glLoadTransposeMatrixdARB(const GLdouble *m);
extern void glMultTransposeMatrixfARB(const GLfloat *m);
extern void glMultTransposeMatrixdARB(const GLdouble *m);
# 2515 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glWeightbvARB(GLint size, const GLbyte *weights);
extern void glWeightsvARB(GLint size, const GLshort *weights);
extern void glWeightivARB(GLint size, const GLint *weights);
extern void glWeightfvARB(GLint size, const GLfloat *weights);
extern void glWeightdvARB(GLint size, const GLdouble *weights);
extern void glWeightubvARB(GLint size, const GLubyte *weights);
extern void glWeightusvARB(GLint size, const GLushort *weights);
extern void glWeightuivARB(GLint size, const GLuint *weights);
extern void glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glVertexBlendARB(GLint count);
# 2542 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindBufferARB(GLenum target, GLuint buffer);
extern void glDeleteBuffersARB(GLsizei n, const GLuint *buffers);
extern void glGenBuffersARB(GLsizei n, GLuint *buffers);
extern GLboolean glIsBufferARB(GLuint buffer);
extern void glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
extern void glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
extern void glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
extern GLvoid *glMapBufferARB(GLenum target, GLenum access);
extern GLboolean glUnmapBufferARB(GLenum target);
extern void glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params);
extern void glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params);
# 2582 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindProgramARB(GLenum target, GLuint program);
extern void glDeleteProgramsARB(GLsizei n, const GLuint *programs);
extern void glGenProgramsARB(GLsizei n, GLuint *programs);
extern GLboolean glIsProgramARB(GLuint program);
extern void glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params);
extern void glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params);
extern void glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params);
extern void glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params);
extern void glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params);
extern void glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params);

extern void glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params);
extern void glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params);

extern void glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params);
extern void glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params);
extern void glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string);
extern void glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string);
extern void glGetProgramivARB(GLenum target, GLenum pname, GLint *params);
# 2614 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name);
extern void glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
extern GLint glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name);
# 2666 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glVertexAttrib1dARB(GLuint index, GLdouble x);
extern void glVertexAttrib1dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib1fARB(GLuint index, GLfloat x);
extern void glVertexAttrib1fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib1sARB(GLuint index, GLshort x);
extern void glVertexAttrib1svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y);
extern void glVertexAttrib2dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y);
extern void glVertexAttrib2fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y);
extern void glVertexAttrib2svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern void glVertexAttrib3dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern void glVertexAttrib3fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z);
extern void glVertexAttrib3svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib4NbvARB(GLuint index, const GLbyte *v);
extern void glVertexAttrib4NivARB(GLuint index, const GLint *v);
extern void glVertexAttrib4NsvARB(GLuint index, const GLshort *v);
extern void glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern void glVertexAttrib4NubvARB(GLuint index, const GLubyte *v);
extern void glVertexAttrib4NuivARB(GLuint index, const GLuint *v);
extern void glVertexAttrib4NusvARB(GLuint index, const GLushort *v);
extern void glVertexAttrib4bvARB(GLuint index, const GLbyte *v);
extern void glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertexAttrib4dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertexAttrib4fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib4ivARB(GLuint index, const GLint *v);
extern void glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertexAttrib4svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib4ubvARB(GLuint index, const GLubyte *v);
extern void glVertexAttrib4uivARB(GLuint index, const GLuint *v);
extern void glVertexAttrib4usvARB(GLuint index, const GLushort *v);
extern void glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
extern void glDisableVertexAttribArrayARB(GLuint index);
extern void glEnableVertexAttribArrayARB(GLuint index);
extern void glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer);
extern void glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params);
extern void glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params);
extern void glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params);
# 2731 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glWindowPos2dARB(GLdouble x, GLdouble y);
extern void glWindowPos2dvARB(const GLdouble *p);
extern void glWindowPos2fARB(GLfloat x, GLfloat y);
extern void glWindowPos2fvARB(const GLfloat *p);
extern void glWindowPos2iARB(GLint x, GLint y);
extern void glWindowPos2ivARB(const GLint *p);
extern void glWindowPos2sARB(GLshort x, GLshort y);
extern void glWindowPos2svARB(const GLshort *p);
extern void glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z);
extern void glWindowPos3dvARB(const GLdouble *p);
extern void glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z);
extern void glWindowPos3fvARB(const GLfloat *p);
extern void glWindowPos3iARB(GLint x, GLint y, GLint z);
extern void glWindowPos3ivARB(const GLint *p);
extern void glWindowPos3sARB(GLshort x, GLshort y, GLshort z);
extern void glWindowPos3svARB(const GLshort *p);
# 2756 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glUniformBufferEXT(GLuint program, GLint location, GLuint buffer);
extern GLint glGetUniformBufferSizeEXT(GLuint program, GLint location);
extern GLintptr glGetUniformOffsetEXT(GLuint program, GLint location);







extern void glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);







extern void glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha);







extern void glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);







extern void glBlendEquationEXT(GLenum mode);
# 2867 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar *label);
extern void glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label);
# 2878 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glInsertEventMarkerEXT(GLsizei length, const char *marker);
extern void glPushGroupMarkerEXT(GLsizei length, const char *marker);
extern void glPopGroupMarkerEXT(void);







extern void glDepthBoundsEXT(GLclampd zmin, GLclampd zmax);
# 2899 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
extern void glEnableIndexedEXT(GLenum target, GLuint index);
extern void glDisableIndexedEXT(GLenum target, GLuint index);
extern GLboolean glIsEnabledIndexedEXT(GLenum target, GLuint index);







extern void glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
# 2922 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glFogCoordfEXT(GLfloat coord);
extern void glFogCoordfvEXT(const GLfloat *coord);
extern void glFogCoorddEXT(GLdouble coord);
extern void glFogCoorddvEXT(const GLdouble *coord);
extern void glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer);







extern void glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);







extern void glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 2966 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern GLboolean glIsRenderbufferEXT(GLuint renderbuffer);
extern void glBindRenderbufferEXT(GLenum target, GLuint renderbuffer);
extern void glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers);
extern void glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers);
extern void glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
extern void glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern GLboolean glIsFramebufferEXT(GLuint framebuffer);
extern void glBindFramebufferEXT(GLenum target, GLuint framebuffer);
extern void glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers);
extern void glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers);
extern GLenum glCheckFramebufferStatusEXT(GLenum target);
extern void glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern void glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern void glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params);
extern void glGenerateMipmapEXT(GLenum target);
# 2992 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value);
extern void glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level);
extern void glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);







extern void glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
# 3043 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glVertexAttribI1iEXT(GLuint index, GLint x);
extern void glVertexAttribI2iEXT(GLuint index, GLint x, GLint y);
extern void glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z);
extern void glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w);
extern void glVertexAttribI1uiEXT(GLuint index, GLuint x);
extern void glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y);
extern void glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z);
extern void glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
extern void glVertexAttribI1ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI2ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI3ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI4ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI1uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI2uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI3uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI4uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI4bvEXT(GLuint index, const GLbyte *v);
extern void glVertexAttribI4svEXT(GLuint index, const GLshort *v);
extern void glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v);
extern void glVertexAttribI4usvEXT(GLuint index, const GLushort *v);
extern void glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params);
extern void glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params);
extern void glUniform1uiEXT(GLint location, GLuint v0);
extern void glUniform2uiEXT(GLint location, GLuint v0, GLuint v1);
extern void glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2);
extern void glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
extern void glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glGetUniformuivEXT(GLuint program, GLint location, GLuint *params);
extern void glBindFragDataLocationEXT(GLuint program, GLuint colorNumber, const GLchar *name);
extern GLint glGetFragDataLocationEXT(GLuint program, const GLchar *name);
# 3111 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern void glMultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei primcount);
# 3144 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glProvokingVertexEXT(GLenum mode);
# 3168 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue);
extern void glSecondaryColor3bvEXT(const GLbyte *v);
extern void glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue);
extern void glSecondaryColor3dvEXT(const GLdouble *v);
extern void glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue);
extern void glSecondaryColor3fvEXT(const GLfloat *v);
extern void glSecondaryColor3iEXT(GLint red, GLint green, GLint blue);
extern void glSecondaryColor3ivEXT(const GLint *v);
extern void glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue);
extern void glSecondaryColor3svEXT(const GLshort *v);
extern void glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue);
extern void glSecondaryColor3ubvEXT(const GLubyte *v);
extern void glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue);
extern void glSecondaryColor3uivEXT(const GLuint *v);
extern void glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue);
extern void glSecondaryColor3usvEXT(const GLushort *v);
extern void glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);







extern void glActiveStencilFaceEXT(GLenum face);
# 3225 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glClearColorIiEXT( GLint r, GLint g, GLint b, GLint a );
extern void glClearColorIuiEXT( GLuint r, GLuint g, GLuint b, GLuint a );
extern void glTexParameterIivEXT( GLenum target, GLenum pname, GLint *params );
extern void glTexParameterIuivEXT( GLenum target, GLenum pname, GLuint *params );
extern void glGetTexParameterIivEXT( GLenum target, GLenum pname, GLint *params);
extern void glGetTexParameterIuivEXT( GLenum target, GLenum pname, GLuint *params);
# 3257 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params);
extern void glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params);
# 3272 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern void glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
extern void glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer);
extern void glBeginTransformFeedbackEXT(GLenum primitiveMode);
extern void glEndTransformFeedbackEXT(void);
extern void glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar* const *varyings, GLenum bufferMode);
extern void glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
# 3287 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glGetIntegerIndexedvEXT(GLenum param, GLuint index, GLint *values);
extern void glGetBooleanIndexedvEXT(GLenum param, GLuint index, GLboolean *values);
# 3324 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glElementPointerAPPLE(GLenum type, const GLvoid *pointer);
extern void glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count);
extern void glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
extern void glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern void glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);
# 3343 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glGenFencesAPPLE(GLsizei n, GLuint *fences);
extern void glDeleteFencesAPPLE(GLsizei n, const GLuint *fences);
extern void glSetFenceAPPLE(GLuint fence);
extern GLboolean glIsFenceAPPLE(GLuint fence);
extern GLboolean glTestFenceAPPLE(GLuint fence);
extern void glFinishFenceAPPLE(GLuint fence);
extern GLboolean glTestObjectAPPLE(GLenum object, GLuint name);
extern void glFinishObjectAPPLE(GLenum object, GLuint name);
# 3359 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param);
extern void glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size);
# 3370 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glFlushRenderAPPLE(void);
extern void glFinishRenderAPPLE(void);
extern void glSwapAPPLE(void);
# 3382 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern GLenum glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);
extern GLenum glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);
extern void glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params);
# 3393 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid *pointer);
extern void glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params);
# 3405 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBindVertexArrayAPPLE(GLuint id);
extern void glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *ids);
extern void glGenVertexArraysAPPLE(GLsizei n, GLuint *ids);
extern GLboolean glIsVertexArrayAPPLE(GLuint id);
# 3418 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer);
extern void glFlushVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer);
extern void glVertexArrayParameteriAPPLE(GLenum pname, GLint param);
# 3429 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPointSizePointerAPPLE(GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glVertexPointSizefAPPLE(GLfloat size);
# 3444 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glEnableVertexAttribAPPLE(GLuint index, GLenum pname);
extern void glDisableVertexAttribAPPLE(GLuint index, GLenum pname);
extern GLboolean glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname);
extern void glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);







extern void glBlendEquationSeparateATI(GLenum equationRGB, GLenum equationAlpha);
# 3477 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
extern void glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
# 3497 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glBeginConditionalRenderNV(GLuint id, GLenum mode);
extern void glEndConditionalRenderNV(void);
# 3507 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glPointParameteriNV(GLenum pname, GLint param);
extern void glPointParameterivNV(GLenum pname, const GLint *params);
# 3558 "/System/Library/Frameworks/OpenGL.framework/Headers/glext.h" 3
extern void glTextureBarrierNV (void);
# 44 "/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 2 3
# 2378 "/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 3
extern void glAccum (GLenum op, GLfloat value);
extern void glAlphaFunc (GLenum func, GLclampf ref);
extern GLboolean glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
extern void glArrayElement (GLint i);
extern void glBegin (GLenum mode);
extern void glBindTexture (GLenum target, GLuint texture);
extern void glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
extern void glBlendColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void glBlendEquation (GLenum mode);
extern void glBlendEquationSeparate (GLenum modeRGB, GLenum modeAlpha);
extern void glBlendFunc (GLenum sfactor, GLenum dfactor);
extern void glCallList (GLuint list);
extern void glCallLists (GLsizei n, GLenum type, const GLvoid *lists);
extern void glClear (GLbitfield mask);
extern void glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void glClearDepth (GLclampd depth);
extern void glClearIndex (GLfloat c);
extern void glClearStencil (GLint s);
extern void glClipPlane (GLenum plane, const GLdouble *equation);
extern void glColor3b (GLbyte red, GLbyte green, GLbyte blue);
extern void glColor3bv (const GLbyte *v);
extern void glColor3d (GLdouble red, GLdouble green, GLdouble blue);
extern void glColor3dv (const GLdouble *v);
extern void glColor3f (GLfloat red, GLfloat green, GLfloat blue);
extern void glColor3fv (const GLfloat *v);
extern void glColor3i (GLint red, GLint green, GLint blue);
extern void glColor3iv (const GLint *v);
extern void glColor3s (GLshort red, GLshort green, GLshort blue);
extern void glColor3sv (const GLshort *v);
extern void glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
extern void glColor3ubv (const GLubyte *v);
extern void glColor3ui (GLuint red, GLuint green, GLuint blue);
extern void glColor3uiv (const GLuint *v);
extern void glColor3us (GLushort red, GLushort green, GLushort blue);
extern void glColor3usv (const GLushort *v);
extern void glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
extern void glColor4bv (const GLbyte *v);
extern void glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
extern void glColor4dv (const GLdouble *v);
extern void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glColor4fv (const GLfloat *v);
extern void glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
extern void glColor4iv (const GLint *v);
extern void glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
extern void glColor4sv (const GLshort *v);
extern void glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
extern void glColor4ubv (const GLubyte *v);
extern void glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
extern void glColor4uiv (const GLuint *v);
extern void glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
extern void glColor4usv (const GLushort *v);
extern void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern void glColorMaterial (GLenum face, GLenum mode);
extern void glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glColorSubTable (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
extern void glColorTable (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
extern void glColorTableParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glColorTableParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glConvolutionFilter1D (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
extern void glConvolutionFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
extern void glConvolutionParameterf (GLenum target, GLenum pname, GLfloat params);
extern void glConvolutionParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glConvolutionParameteri (GLenum target, GLenum pname, GLint params);
extern void glConvolutionParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glCopyColorSubTable (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
extern void glCopyColorTable (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void glCopyConvolutionFilter1D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void glCopyConvolutionFilter2D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
extern void glCopyTexImage1D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern void glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCopyTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCullFace (GLenum mode);
extern void glDeleteLists (GLuint list, GLsizei range);
extern void glDeleteTextures (GLsizei n, const GLuint *textures);
extern void glDepthFunc (GLenum func);
extern void glDepthMask (GLboolean flag);
extern void glDepthRange (GLclampd zNear, GLclampd zFar);
extern void glDisable (GLenum cap);
extern void glDisableClientState (GLenum array);
extern void glDrawArrays (GLenum mode, GLint first, GLsizei count);
extern void glDrawBuffer (GLenum mode);
extern void glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
extern void glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void glDrawRangeElements (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
extern void glEdgeFlag (GLboolean flag);
extern void glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);
extern void glEdgeFlagv (const GLboolean *flag);
extern void glEnable (GLenum cap);
extern void glEnableClientState (GLenum array);
extern void glEnd (void);
extern void glEndList (void);
extern void glEvalCoord1d (GLdouble u);
extern void glEvalCoord1dv (const GLdouble *u);
extern void glEvalCoord1f (GLfloat u);
extern void glEvalCoord1fv (const GLfloat *u);
extern void glEvalCoord2d (GLdouble u, GLdouble v);
extern void glEvalCoord2dv (const GLdouble *u);
extern void glEvalCoord2f (GLfloat u, GLfloat v);
extern void glEvalCoord2fv (const GLfloat *u);
extern void glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
extern void glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
extern void glEvalPoint1 (GLint i);
extern void glEvalPoint2 (GLint i, GLint j);
extern void glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
extern void glFinish (void);
extern void glFlush (void);
extern void glFogf (GLenum pname, GLfloat param);
extern void glFogfv (GLenum pname, const GLfloat *params);
extern void glFogi (GLenum pname, GLint param);
extern void glFogiv (GLenum pname, const GLint *params);
extern void glFrontFace (GLenum mode);
extern void glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern GLuint glGenLists (GLsizei range);
extern void glGenTextures (GLsizei n, GLuint *textures);
extern void glGetBooleanv (GLenum pname, GLboolean *params);
extern void glGetClipPlane (GLenum plane, GLdouble *equation);
extern void glGetColorTable (GLenum target, GLenum format, GLenum type, GLvoid *table);
extern void glGetColorTableParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetColorTableParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetConvolutionFilter (GLenum target, GLenum format, GLenum type, GLvoid *image);
extern void glGetConvolutionParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetConvolutionParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetDoublev (GLenum pname, GLdouble *params);
extern GLenum glGetError (void);
extern void glGetFloatv (GLenum pname, GLfloat *params);
extern void glGetHistogram (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void glGetHistogramParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetHistogramParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetIntegerv (GLenum pname, GLint *params);
extern void glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
extern void glGetLightiv (GLenum light, GLenum pname, GLint *params);
extern void glGetMapdv (GLenum target, GLenum query, GLdouble *v);
extern void glGetMapfv (GLenum target, GLenum query, GLfloat *v);
extern void glGetMapiv (GLenum target, GLenum query, GLint *v);
extern void glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
extern void glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
extern void glGetMinmax (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void glGetMinmaxParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetMinmaxParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetPixelMapfv (GLenum map, GLfloat *values);
extern void glGetPixelMapuiv (GLenum map, GLuint *values);
extern void glGetPixelMapusv (GLenum map, GLushort *values);
extern void glGetPointerv (GLenum pname, GLvoid **params);
extern void glGetPolygonStipple (GLubyte *mask);
extern void glGetSeparableFilter (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
extern const GLubyte *glGetString (GLenum name);
extern void glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
extern void glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
extern void glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
extern void glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
extern void glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
extern void glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
extern void glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
extern void glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glHint (GLenum target, GLenum mode);
extern void glHistogram (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
extern void glIndexMask (GLuint mask);
extern void glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glIndexd (GLdouble c);
extern void glIndexdv (const GLdouble *c);
extern void glIndexf (GLfloat c);
extern void glIndexfv (const GLfloat *c);
extern void glIndexi (GLint c);
extern void glIndexiv (const GLint *c);
extern void glIndexs (GLshort c);
extern void glIndexsv (const GLshort *c);
extern void glIndexub (GLubyte c);
extern void glIndexubv (const GLubyte *c);
extern void glInitNames (void);
extern void glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer);
extern GLboolean glIsEnabled (GLenum cap);
extern GLboolean glIsList (GLuint list);
extern GLboolean glIsTexture (GLuint texture);
extern void glLightModelf (GLenum pname, GLfloat param);
extern void glLightModelfv (GLenum pname, const GLfloat *params);
extern void glLightModeli (GLenum pname, GLint param);
extern void glLightModeliv (GLenum pname, const GLint *params);
extern void glLightf (GLenum light, GLenum pname, GLfloat param);
extern void glLightfv (GLenum light, GLenum pname, const GLfloat *params);
extern void glLighti (GLenum light, GLenum pname, GLint param);
extern void glLightiv (GLenum light, GLenum pname, const GLint *params);
extern void glLineStipple (GLint factor, GLushort pattern);
extern void glLineWidth (GLfloat width);
extern void glListBase (GLuint base);
extern void glLoadIdentity (void);
extern void glLoadMatrixd (const GLdouble *m);
extern void glLoadMatrixf (const GLfloat *m);
extern void glLoadName (GLuint name);
extern void glLogicOp (GLenum opcode);
extern void glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
extern void glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
extern void glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
extern void glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
extern void glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
extern void glMaterialf (GLenum face, GLenum pname, GLfloat param);
extern void glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
extern void glMateriali (GLenum face, GLenum pname, GLint param);
extern void glMaterialiv (GLenum face, GLenum pname, const GLint *params);
extern void glMatrixMode (GLenum mode);
extern void glMinmax (GLenum target, GLenum internalformat, GLboolean sink);
extern void glMultMatrixd (const GLdouble *m);
extern void glMultMatrixf (const GLfloat *m);
extern void glNewList (GLuint list, GLenum mode);
extern void glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
extern void glNormal3bv (const GLbyte *v);
extern void glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
extern void glNormal3dv (const GLdouble *v);
extern void glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
extern void glNormal3fv (const GLfloat *v);
extern void glNormal3i (GLint nx, GLint ny, GLint nz);
extern void glNormal3iv (const GLint *v);
extern void glNormal3s (GLshort nx, GLshort ny, GLshort nz);
extern void glNormal3sv (const GLshort *v);
extern void glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern void glPassThrough (GLfloat token);
extern void glPixelMapfv (GLenum map, GLint mapsize, const GLfloat *values);
extern void glPixelMapuiv (GLenum map, GLint mapsize, const GLuint *values);
extern void glPixelMapusv (GLenum map, GLint mapsize, const GLushort *values);
extern void glPixelStoref (GLenum pname, GLfloat param);
extern void glPixelStorei (GLenum pname, GLint param);
extern void glPixelTransferf (GLenum pname, GLfloat param);
extern void glPixelTransferi (GLenum pname, GLint param);
extern void glPixelZoom (GLfloat xfactor, GLfloat yfactor);
extern void glPointSize (GLfloat size);
extern void glPolygonMode (GLenum face, GLenum mode);
extern void glPolygonOffset (GLfloat factor, GLfloat units);
extern void glPolygonStipple (const GLubyte *mask);
extern void glPopAttrib (void);
extern void glPopClientAttrib (void);
extern void glPopMatrix (void);
extern void glPopName (void);
extern void glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern void glPushAttrib (GLbitfield mask);
extern void glPushClientAttrib (GLbitfield mask);
extern void glPushMatrix (void);
extern void glPushName (GLuint name);
extern void glRasterPos2d (GLdouble x, GLdouble y);
extern void glRasterPos2dv (const GLdouble *v);
extern void glRasterPos2f (GLfloat x, GLfloat y);
extern void glRasterPos2fv (const GLfloat *v);
extern void glRasterPos2i (GLint x, GLint y);
extern void glRasterPos2iv (const GLint *v);
extern void glRasterPos2s (GLshort x, GLshort y);
extern void glRasterPos2sv (const GLshort *v);
extern void glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
extern void glRasterPos3dv (const GLdouble *v);
extern void glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
extern void glRasterPos3fv (const GLfloat *v);
extern void glRasterPos3i (GLint x, GLint y, GLint z);
extern void glRasterPos3iv (const GLint *v);
extern void glRasterPos3s (GLshort x, GLshort y, GLshort z);
extern void glRasterPos3sv (const GLshort *v);
extern void glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glRasterPos4dv (const GLdouble *v);
extern void glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glRasterPos4fv (const GLfloat *v);
extern void glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
extern void glRasterPos4iv (const GLint *v);
extern void glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glRasterPos4sv (const GLshort *v);
extern void glReadBuffer (GLenum mode);
extern void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
extern void glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
extern void glRectdv (const GLdouble *v1, const GLdouble *v2);
extern void glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
extern void glRectfv (const GLfloat *v1, const GLfloat *v2);
extern void glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
extern void glRectiv (const GLint *v1, const GLint *v2);
extern void glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
extern void glRectsv (const GLshort *v1, const GLshort *v2);
extern GLint glRenderMode (GLenum mode);
extern void glResetHistogram (GLenum target);
extern void glResetMinmax (GLenum target);
extern void glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
extern void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern void glScaled (GLdouble x, GLdouble y, GLdouble z);
extern void glScalef (GLfloat x, GLfloat y, GLfloat z);
extern void glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
extern void glSelectBuffer (GLsizei size, GLuint *buffer);
extern void glSeparableFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
extern void glShadeModel (GLenum mode);
extern void glStencilFunc (GLenum func, GLint ref, GLuint mask);
extern void glStencilMask (GLuint mask);
extern void glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
extern void glTexCoord1d (GLdouble s);
extern void glTexCoord1dv (const GLdouble *v);
extern void glTexCoord1f (GLfloat s);
extern void glTexCoord1fv (const GLfloat *v);
extern void glTexCoord1i (GLint s);
extern void glTexCoord1iv (const GLint *v);
extern void glTexCoord1s (GLshort s);
extern void glTexCoord1sv (const GLshort *v);
extern void glTexCoord2d (GLdouble s, GLdouble t);
extern void glTexCoord2dv (const GLdouble *v);
extern void glTexCoord2f (GLfloat s, GLfloat t);
extern void glTexCoord2fv (const GLfloat *v);
extern void glTexCoord2i (GLint s, GLint t);
extern void glTexCoord2iv (const GLint *v);
extern void glTexCoord2s (GLshort s, GLshort t);
extern void glTexCoord2sv (const GLshort *v);
extern void glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
extern void glTexCoord3dv (const GLdouble *v);
extern void glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
extern void glTexCoord3fv (const GLfloat *v);
extern void glTexCoord3i (GLint s, GLint t, GLint r);
extern void glTexCoord3iv (const GLint *v);
extern void glTexCoord3s (GLshort s, GLshort t, GLshort r);
extern void glTexCoord3sv (const GLshort *v);
extern void glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glTexCoord4dv (const GLdouble *v);
extern void glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glTexCoord4fv (const GLfloat *v);
extern void glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
extern void glTexCoord4iv (const GLint *v);
extern void glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
extern void glTexCoord4sv (const GLshort *v);
extern void glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glTexEnvf (GLenum target, GLenum pname, GLfloat param);
extern void glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexEnvi (GLenum target, GLenum pname, GLint param);
extern void glTexEnviv (GLenum target, GLenum pname, const GLint *params);
extern void glTexGend (GLenum coord, GLenum pname, GLdouble param);
extern void glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
extern void glTexGenf (GLenum coord, GLenum pname, GLfloat param);
extern void glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
extern void glTexGeni (GLenum coord, GLenum pname, GLint param);
extern void glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
extern void glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexImage3D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexParameterf (GLenum target, GLenum pname, GLfloat param);
extern void glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexParameteri (GLenum target, GLenum pname, GLint param);
extern void glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTranslated (GLdouble x, GLdouble y, GLdouble z);
extern void glTranslatef (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex2d (GLdouble x, GLdouble y);
extern void glVertex2dv (const GLdouble *v);
extern void glVertex2f (GLfloat x, GLfloat y);
extern void glVertex2fv (const GLfloat *v);
extern void glVertex2i (GLint x, GLint y);
extern void glVertex2iv (const GLint *v);
extern void glVertex2s (GLshort x, GLshort y);
extern void glVertex2sv (const GLshort *v);
extern void glVertex3d (GLdouble x, GLdouble y, GLdouble z);
extern void glVertex3dv (const GLdouble *v);
extern void glVertex3f (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex3fv (const GLfloat *v);
extern void glVertex3i (GLint x, GLint y, GLint z);
extern void glVertex3iv (const GLint *v);
extern void glVertex3s (GLshort x, GLshort y, GLshort z);
extern void glVertex3sv (const GLshort *v);
extern void glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertex4dv (const GLdouble *v);
extern void glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertex4fv (const GLfloat *v);
extern void glVertex4i (GLint x, GLint y, GLint z, GLint w);
extern void glVertex4iv (const GLint *v);
extern void glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertex4sv (const GLshort *v);
extern void glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glViewport (GLint x, GLint y, GLsizei width, GLsizei height);

extern void glSampleCoverage (GLclampf value, GLboolean invert);

extern void glLoadTransposeMatrixf (const GLfloat *m);
extern void glLoadTransposeMatrixd (const GLdouble *m);
extern void glMultTransposeMatrixf (const GLfloat *m);
extern void glMultTransposeMatrixd (const GLdouble *m);

extern void glCompressedTexImage3D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage1D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glGetCompressedTexImage (GLenum target, GLint lod, GLvoid *img);

extern void glActiveTexture (GLenum texture);
extern void glClientActiveTexture (GLenum texture);
extern void glMultiTexCoord1d (GLenum target, GLdouble s);
extern void glMultiTexCoord1dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord1f (GLenum target, GLfloat s);
extern void glMultiTexCoord1fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord1i (GLenum target, GLint s);
extern void glMultiTexCoord1iv (GLenum target, const GLint *v);
extern void glMultiTexCoord1s (GLenum target, GLshort s);
extern void glMultiTexCoord1sv (GLenum target, const GLshort *v);
extern void glMultiTexCoord2d (GLenum target, GLdouble s, GLdouble t);
extern void glMultiTexCoord2dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord2f (GLenum target, GLfloat s, GLfloat t);
extern void glMultiTexCoord2fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord2i (GLenum target, GLint s, GLint t);
extern void glMultiTexCoord2iv (GLenum target, const GLint *v);
extern void glMultiTexCoord2s (GLenum target, GLshort s, GLshort t);
extern void glMultiTexCoord2sv (GLenum target, const GLshort *v);
extern void glMultiTexCoord3d (GLenum target, GLdouble s, GLdouble t, GLdouble r);
extern void glMultiTexCoord3dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord3f (GLenum target, GLfloat s, GLfloat t, GLfloat r);
extern void glMultiTexCoord3fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord3i (GLenum target, GLint s, GLint t, GLint r);
extern void glMultiTexCoord3iv (GLenum target, const GLint *v);
extern void glMultiTexCoord3s (GLenum target, GLshort s, GLshort t, GLshort r);
extern void glMultiTexCoord3sv (GLenum target, const GLshort *v);
extern void glMultiTexCoord4d (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glMultiTexCoord4dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord4f (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glMultiTexCoord4fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord4i (GLenum target, GLint s, GLint t, GLint r, GLint q);
extern void glMultiTexCoord4iv (GLenum target, const GLint *v);
extern void glMultiTexCoord4s (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
extern void glMultiTexCoord4sv (GLenum target, const GLshort *v);

extern void glFogCoordf (GLfloat coord);
extern void glFogCoordfv (const GLfloat *coord);
extern void glFogCoordd (GLdouble coord);
extern void glFogCoorddv (const GLdouble *coord);
extern void glFogCoordPointer (GLenum type, GLsizei stride, const GLvoid *pointer);

extern void glSecondaryColor3b (GLbyte red, GLbyte green, GLbyte blue);
extern void glSecondaryColor3bv (const GLbyte *v);
extern void glSecondaryColor3d (GLdouble red, GLdouble green, GLdouble blue);
extern void glSecondaryColor3dv (const GLdouble *v);
extern void glSecondaryColor3f (GLfloat red, GLfloat green, GLfloat blue);
extern void glSecondaryColor3fv (const GLfloat *v);
extern void glSecondaryColor3i (GLint red, GLint green, GLint blue);
extern void glSecondaryColor3iv (const GLint *v);
extern void glSecondaryColor3s (GLshort red, GLshort green, GLshort blue);
extern void glSecondaryColor3sv (const GLshort *v);
extern void glSecondaryColor3ub (GLubyte red, GLubyte green, GLubyte blue);
extern void glSecondaryColor3ubv (const GLubyte *v);
extern void glSecondaryColor3ui (GLuint red, GLuint green, GLuint blue);
extern void glSecondaryColor3uiv (const GLuint *v);
extern void glSecondaryColor3us (GLushort red, GLushort green, GLushort blue);
extern void glSecondaryColor3usv (const GLushort *v);
extern void glSecondaryColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

extern void glPointParameterf (GLenum pname, GLfloat param);
extern void glPointParameterfv (GLenum pname, const GLfloat *params);
extern void glPointParameteri (GLenum pname, GLint param);
extern void glPointParameteriv (GLenum pname, const GLint *params);

extern void glBlendFuncSeparate (GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);

extern void glMultiDrawArrays (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern void glMultiDrawElements (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei primcount);

extern void glWindowPos2d (GLdouble x, GLdouble y);
extern void glWindowPos2dv (const GLdouble *v);
extern void glWindowPos2f (GLfloat x, GLfloat y);
extern void glWindowPos2fv (const GLfloat *v);
extern void glWindowPos2i (GLint x, GLint y);
extern void glWindowPos2iv (const GLint *v);
extern void glWindowPos2s (GLshort x, GLshort y);
extern void glWindowPos2sv (const GLshort *v);
extern void glWindowPos3d (GLdouble x, GLdouble y, GLdouble z);
extern void glWindowPos3dv (const GLdouble *v);
extern void glWindowPos3f (GLfloat x, GLfloat y, GLfloat z);
extern void glWindowPos3fv (const GLfloat *v);
extern void glWindowPos3i (GLint x, GLint y, GLint z);
extern void glWindowPos3iv (const GLint *v);
extern void glWindowPos3s (GLshort x, GLshort y, GLshort z);
extern void glWindowPos3sv (const GLshort *v);

extern void glGenQueries (GLsizei n, GLuint *ids);
extern void glDeleteQueries (GLsizei n, const GLuint *ids);
extern GLboolean glIsQuery (GLuint id);
extern void glBeginQuery (GLenum target, GLuint id);
extern void glEndQuery (GLenum target);
extern void glGetQueryiv (GLenum target, GLenum pname, GLint *params);
extern void glGetQueryObjectiv (GLuint id, GLenum pname, GLint *params);
extern void glGetQueryObjectuiv (GLuint id, GLenum pname, GLuint *params);

extern void glBindBuffer (GLenum target, GLuint buffer);
extern void glDeleteBuffers (GLsizei n, const GLuint *buffers);
extern void glGenBuffers (GLsizei n, GLuint *buffers);
extern GLboolean glIsBuffer (GLuint buffer);
extern void glBufferData (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
extern void glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
extern void glGetBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
extern GLvoid *glMapBuffer (GLenum target, GLenum access);
extern GLboolean glUnmapBuffer (GLenum target);
extern void glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetBufferPointerv (GLenum target, GLenum pname, GLvoid **params);

extern void glDrawBuffers (GLsizei n, const GLenum *bufs);
extern void glVertexAttrib1d (GLuint index, GLdouble x);
extern void glVertexAttrib1dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib1f (GLuint index, GLfloat x);
extern void glVertexAttrib1fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib1s (GLuint index, GLshort x);
extern void glVertexAttrib1sv (GLuint index, const GLshort *v);
extern void glVertexAttrib2d (GLuint index, GLdouble x, GLdouble y);
extern void glVertexAttrib2dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib2f (GLuint index, GLfloat x, GLfloat y);
extern void glVertexAttrib2fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib2s (GLuint index, GLshort x, GLshort y);
extern void glVertexAttrib2sv (GLuint index, const GLshort *v);
extern void glVertexAttrib3d (GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern void glVertexAttrib3dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib3f (GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern void glVertexAttrib3fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib3s (GLuint index, GLshort x, GLshort y, GLshort z);
extern void glVertexAttrib3sv (GLuint index, const GLshort *v);
extern void glVertexAttrib4Nbv (GLuint index, const GLbyte *v);
extern void glVertexAttrib4Niv (GLuint index, const GLint *v);
extern void glVertexAttrib4Nsv (GLuint index, const GLshort *v);
extern void glVertexAttrib4Nub (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern void glVertexAttrib4Nubv (GLuint index, const GLubyte *v);
extern void glVertexAttrib4Nuiv (GLuint index, const GLuint *v);
extern void glVertexAttrib4Nusv (GLuint index, const GLushort *v);
extern void glVertexAttrib4bv (GLuint index, const GLbyte *v);
extern void glVertexAttrib4d (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertexAttrib4dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib4f (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertexAttrib4fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib4iv (GLuint index, const GLint *v);
extern void glVertexAttrib4s (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertexAttrib4sv (GLuint index, const GLshort *v);
extern void glVertexAttrib4ubv (GLuint index, const GLubyte *v);
extern void glVertexAttrib4uiv (GLuint index, const GLuint *v);
extern void glVertexAttrib4usv (GLuint index, const GLushort *v);
extern void glVertexAttribPointer (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
extern void glEnableVertexAttribArray (GLuint index);
extern void glDisableVertexAttribArray (GLuint index);
extern void glGetVertexAttribdv (GLuint index, GLenum pname, GLdouble *params);
extern void glGetVertexAttribfv (GLuint index, GLenum pname, GLfloat *params);
extern void glGetVertexAttribiv (GLuint index, GLenum pname, GLint *params);
extern void glGetVertexAttribPointerv (GLuint index, GLenum pname, GLvoid **pointer);
extern void glDeleteShader (GLuint shader);
extern void glDetachShader (GLuint program, GLuint shader);
extern GLuint glCreateShader (GLenum type);
extern void glShaderSource (GLuint shader, GLsizei count, const GLchar* const *string, const GLint *length);
extern void glCompileShader (GLuint shader);
extern GLuint glCreateProgram (void);
extern void glAttachShader (GLuint program, GLuint shader);
extern void glLinkProgram (GLuint program);
extern void glUseProgram (GLuint program);
extern void glDeleteProgram (GLuint program);
extern void glValidateProgram (GLuint program);
extern void glUniform1f (GLint location, GLfloat v0);
extern void glUniform2f (GLint location, GLfloat v0, GLfloat v1);
extern void glUniform3f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern void glUniform4f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern void glUniform1i (GLint location, GLint v0);
extern void glUniform2i (GLint location, GLint v0, GLint v1);
extern void glUniform3i (GLint location, GLint v0, GLint v1, GLint v2);
extern void glUniform4i (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern void glUniform1fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform2fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform3fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform4fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform1iv (GLint location, GLsizei count, const GLint *value);
extern void glUniform2iv (GLint location, GLsizei count, const GLint *value);
extern void glUniform3iv (GLint location, GLsizei count, const GLint *value);
extern void glUniform4iv (GLint location, GLsizei count, const GLint *value);
extern void glUniformMatrix2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern GLboolean glIsShader (GLuint shader);
extern GLboolean glIsProgram (GLuint program);
extern void glGetShaderiv (GLuint shader, GLenum pname, GLint *params);
extern void glGetProgramiv (GLuint program, GLenum pname, GLint *params);
extern void glGetAttachedShaders (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
extern void glGetShaderInfoLog (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern void glGetProgramInfoLog (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern GLint glGetUniformLocation (GLuint program, const GLchar *name);
extern void glGetActiveUniform (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern void glGetUniformfv (GLuint program, GLint location, GLfloat *params);
extern void glGetUniformiv (GLuint program, GLint location, GLint *params);
extern void glGetShaderSource (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
extern void glBindAttribLocation (GLuint program, GLuint index, const GLchar *name);
extern void glGetActiveAttrib (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern GLint glGetAttribLocation (GLuint program, const GLchar *name);
extern void glStencilFuncSeparate (GLenum face, GLenum func, GLint ref, GLuint mask);
extern void glStencilOpSeparate (GLenum face, GLenum fail, GLenum zfail, GLenum zpass);
extern void glStencilMaskSeparate (GLenum face, GLuint mask);

extern void glUniformMatrix2x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix2x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
# 62 "/Users/weugene/basilisk/src/view.h" 2
# 1 "/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 1 3







# 1 "/System/Library/Frameworks/OpenGL.framework/Headers/OpenGLAvailability.h" 1 3
# 9 "/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 2 3
# 228 "/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
typedef struct GLUnurbs GLUnurbs __attribute__((deprecated));
typedef struct GLUquadric GLUquadric __attribute__((deprecated));
typedef struct GLUtesselator GLUtesselator __attribute__((deprecated));

typedef struct GLUnurbs GLUnurbsObj __attribute__((deprecated));
typedef struct GLUquadric GLUquadricObj __attribute__((deprecated));
typedef struct GLUtesselator GLUtesselatorObj __attribute__((deprecated));
typedef struct GLUtesselator GLUtriangulatorObj __attribute__((deprecated));




extern void gluBeginCurve (GLUnurbs* nurb) __attribute__((deprecated));
extern void gluBeginPolygon (GLUtesselator* tess) __attribute__((deprecated));
extern void gluBeginSurface (GLUnurbs* nurb) __attribute__((deprecated));
extern void gluBeginTrim (GLUnurbs* nurb) __attribute__((deprecated));
extern GLint gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data) __attribute__((deprecated("" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data) __attribute__((deprecated("" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data) __attribute__((deprecated("" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data) __attribute__((deprecated("" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data) __attribute__((deprecated("" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data) __attribute__((deprecated("" "\"Use glGenerateMipmap\"" "")));
extern GLboolean gluCheckExtension (const GLubyte *extName, const GLubyte *extString) __attribute__((deprecated));
extern void gluCylinder (GLUquadric* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks) __attribute__((deprecated));
extern void gluDeleteNurbsRenderer (GLUnurbs* nurb) __attribute__((deprecated));
extern void gluDeleteQuadric (GLUquadric* quad) __attribute__((deprecated));
extern void gluDeleteTess (GLUtesselator* tess) __attribute__((deprecated));
extern void gluDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops) __attribute__((deprecated));
extern void gluEndCurve (GLUnurbs* nurb) __attribute__((deprecated));
extern void gluEndPolygon (GLUtesselator* tess) __attribute__((deprecated));
extern void gluEndSurface (GLUnurbs* nurb) __attribute__((deprecated));
extern void gluEndTrim (GLUnurbs* nurb) __attribute__((deprecated));
extern const GLubyte * gluErrorString (GLenum error) __attribute__((deprecated));
extern void gluGetNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat* data) __attribute__((deprecated));
extern const GLubyte * gluGetString (GLenum name) __attribute__((deprecated));
extern void gluGetTessProperty (GLUtesselator* tess, GLenum which, GLdouble* data) __attribute__((deprecated));
extern void gluLoadSamplingMatrices (GLUnurbs* nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view) __attribute__((deprecated));
extern void gluLookAt (GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ) __attribute__((deprecated("" "\"Use GLKMatrix4MakeLookAt\"" "")));
extern GLUnurbs* gluNewNurbsRenderer (void) __attribute__((deprecated));
extern GLUquadric* gluNewQuadric (void) __attribute__((deprecated));
extern GLUtesselator* gluNewTess (void) __attribute__((deprecated));
extern void gluNextContour (GLUtesselator* tess, GLenum type) __attribute__((deprecated));
extern void gluNurbsCallback (GLUnurbs* nurb, GLenum which, GLvoid (*CallBackFunc)()) __attribute__((deprecated));
extern void gluNurbsCallbackData (GLUnurbs* nurb, GLvoid* userData) __attribute__((deprecated));
extern void gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData) __attribute__((deprecated));
extern void gluNurbsCurve (GLUnurbs* nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type) __attribute__((deprecated));
extern void gluNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat value) __attribute__((deprecated));
extern void gluNurbsSurface (GLUnurbs* nurb, GLint sKnotCount, GLfloat* sKnots, GLint tKnotCount, GLfloat* tKnots, GLint sStride, GLint tStride, GLfloat* control, GLint sOrder, GLint tOrder, GLenum type) __attribute__((deprecated));
extern void gluOrtho2D (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top) __attribute__((deprecated("" "\"Use GLKMatrix4MakeOrtho\"" "")));
extern void gluPartialDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep) __attribute__((deprecated));
extern void gluPerspective (GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar) __attribute__((deprecated("" "\"Use GLKMatrix4MakePerspective\"" "")));
extern void gluPickMatrix (GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport) __attribute__((deprecated));
extern GLint gluProject (GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* winX, GLdouble* winY, GLdouble* winZ) __attribute__((deprecated("" "\"Use GLKMathProject\"" "")));
extern void gluPwlCurve (GLUnurbs* nurb, GLint count, GLfloat* data, GLint stride, GLenum type) __attribute__((deprecated));
extern void gluQuadricCallback (GLUquadric* quad, GLenum which, GLvoid (*CallBackFunc)()) __attribute__((deprecated));
extern void gluQuadricDrawStyle (GLUquadric* quad, GLenum draw) __attribute__((deprecated));
extern void gluQuadricNormals (GLUquadric* quad, GLenum normal) __attribute__((deprecated));
extern void gluQuadricOrientation (GLUquadric* quad, GLenum orientation) __attribute__((deprecated));
extern void gluQuadricTexture (GLUquadric* quad, GLboolean texture) __attribute__((deprecated));
extern GLint gluScaleImage (GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid* dataOut) __attribute__((deprecated));
extern void gluSphere (GLUquadric* quad, GLdouble radius, GLint slices, GLint stacks) __attribute__((deprecated));
extern void gluTessBeginContour (GLUtesselator* tess) __attribute__((deprecated));
extern void gluTessBeginPolygon (GLUtesselator* tess, GLvoid* data) __attribute__((deprecated));
extern void gluTessCallback (GLUtesselator* tess, GLenum which, GLvoid (*CallBackFunc)()) __attribute__((deprecated));
extern void gluTessEndContour (GLUtesselator* tess) __attribute__((deprecated));
extern void gluTessEndPolygon (GLUtesselator* tess) __attribute__((deprecated));
extern void gluTessNormal (GLUtesselator* tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ) __attribute__((deprecated));
extern void gluTessProperty (GLUtesselator* tess, GLenum which, GLdouble data) __attribute__((deprecated));
extern void gluTessVertex (GLUtesselator* tess, GLdouble *location, GLvoid* data) __attribute__((deprecated));
extern GLint gluUnProject (GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* objX, GLdouble* objY, GLdouble* objZ) __attribute__((deprecated("" "\"Use GLKMathUnproject\"" "")));
extern GLint gluUnProject4 (GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearPlane, GLdouble farPlane, GLdouble* objX, GLdouble* objY, GLdouble* objZ, GLdouble* objW) __attribute__((deprecated("" "\"Use GLKMathUnproject\"" "")));
# 63 "/Users/weugene/basilisk/src/view.h" 2





# 1 "/Users/weugene/basilisk/src/gl/framebuffer.h" 1

# 1 "/Users/weugene/basilisk/src/gl/framebuffer.h"
typedef struct _framebuffer framebuffer;
typedef unsigned int fbdepth_t;

framebuffer * framebuffer_new (unsigned width, unsigned height);
void framebuffer_destroy (framebuffer * p);
unsigned char * framebuffer_image (framebuffer * p);
fbdepth_t * framebuffer_depth (framebuffer * p);
# 69 "/Users/weugene/basilisk/src/view.h" 2
# 1 "/Users/weugene/basilisk/src/gl/gl2ps/gl2ps.h" 1
# 176 "/Users/weugene/basilisk/src/gl/gl2ps/gl2ps.h"
typedef GLfloat GL2PSrgba[4];
typedef GLfloat GL2PSxyz[3];

typedef struct {
  GL2PSxyz xyz;
  GL2PSrgba rgba;
} GL2PSvertex;
# 201 "/Users/weugene/basilisk/src/gl/gl2ps/gl2ps.h"
 GLint gl2psBeginPage(const char *title, const char *producer,
                                  GLint viewport[4], GLint format, GLint sort,
                                  GLint options, GLint colormode,
                                  GLint colorsize, GL2PSrgba *colormap,
                                  GLint nr, GLint ng, GLint nb, GLint buffersize,
                                  FILE *stream, const char *filename);
 GLint gl2psEndPage(void);
 GLint gl2psSetOptions(GLint options);
 GLint gl2psGetOptions(GLint *options);
 GLint gl2psBeginViewport(GLint viewport[4]);
 GLint gl2psEndViewport(void);
 GLint gl2psText(const char *str, const char *fontname,
                             GLshort fontsize);
 GLint gl2psTextOpt(const char *str, const char *fontname,
                                GLshort fontsize, GLint align, GLfloat angle);
 GLint gl2psTextOptColor(const char *str, const char *fontname,
                                     GLshort fontsize, GLint align, GLfloat angle,
                                     GL2PSrgba color);
 GLint gl2psSpecial(GLint format, const char *str);
 GLint gl2psSpecialColor(GLint format, const char *str, GL2PSrgba rgba);
 GLint gl2psDrawPixels(GLsizei width, GLsizei height,
                                   GLint xorig, GLint yorig,
                                   GLenum format, GLenum type, const void *pixels);
 GLint gl2psEnable(GLint mode);
 GLint gl2psDisable(GLint mode);
 GLint gl2psPointSize(GLfloat value);
 GLint gl2psLineCap(GLint value);
 GLint gl2psLineJoin(GLint value);
 GLint gl2psLineWidth(GLfloat value);
 GLint gl2psBlendFunc(GLenum sfactor, GLenum dfactor);


 GLint gl2psForceRasterPos(GL2PSvertex *vert);
 void gl2psAddPolyPrimitive(GLshort type, GLshort numverts,
                                        GL2PSvertex *verts, GLint offset,
                                        GLfloat ofactor, GLfloat ounits,
                                        GLushort pattern, GLint factor,
                                        GLfloat width, GLint linecap,
                                        GLint linejoin, char boundary);


 GLint gl2psDrawImageMap(GLsizei width, GLsizei height,
                                     const GLfloat position[3],
                                     const unsigned char *imagemap);
 const char *gl2psGetFileExtension(GLint format);
 const char *gl2psGetFormatDescription(GLint format);
 GLint gl2psGetFileFormat();
# 70 "/Users/weugene/basilisk/src/view.h" 2
# 1 "/Users/weugene/basilisk/src/gl/trackball.h" 1
# 50 "/Users/weugene/basilisk/src/gl/trackball.h"
void
gl_trackball(float q[4], float p1x, float p1y, float p2x, float p2y);
# 61 "/Users/weugene/basilisk/src/gl/trackball.h"
void
gl_add_quats(float *q1, float *q2, float *dest);





void
gl_build_rotmatrix(float m[4][4], float q[4]);






void
gl_axis_to_quat(float a[3], float phi, float q[4]);
# 71 "/Users/weugene/basilisk/src/view.h" 2
# 1 "/Users/weugene/basilisk/src/gl/utils.h" 1
# 11 "/Users/weugene/basilisk/src/gl/utils.h"
void gl_write_image (FILE * fp, const GLubyte * buffer,
       unsigned width, unsigned height, unsigned samples);
void init_gl();

void matrix_multiply (float * m, float * n);
void vector_multiply (float * v, float * m);

typedef struct {
  float m[16], p[16];
  float n[6][3];
  float d[6];
  unsigned width;




} Frustum;

void gl_get_frustum (Frustum * f);
int sphere_in_frustum (double x, double y, double z, double r, Frustum * f);
float sphere_diameter (double x, double y, double z, double r, Frustum * f);
void gl_check_error();

enum FeedbackFormat {
  FEEDBACK_GNU, FEEDBACK_OBJ, FEEDBACK_KML
};

float * gl_feedback_begin (unsigned buffersize);

# 39 "/Users/weugene/basilisk/src/gl/utils.h" 3 4
_Bool 
# 39 "/Users/weugene/basilisk/src/gl/utils.h"
       gl_feedback_end (float * f,
      FILE * fp,
      enum FeedbackFormat format);

int polygonize (const double val[8], double isolevel, double triangles[5][3][3]);
# 72 "/Users/weugene/basilisk/src/view.h" 2
# 1 "utils.h"
# 75 "/Users/weugene/basilisk/src/view.h"
# 1 "input.h"
# 1 "/Users/weugene/basilisk/src/input.h"
# 16 "/Users/weugene/basilisk/src/input.h"
struct InputPGM {

  scalar s;
  FILE * fp;

  double ox, oy, width;
};

void input_pgm (struct InputPGM p)
{
  scalar s = p.s;
  if (p.width == 0.) p.width = L0;

  char line[81];
  if (!fgets (line, 81, p.fp)) {
    fprintf (
# 31 "/Users/weugene/basilisk/src/input.h" 3 4
            __stderrp
# 31 "/Users/weugene/basilisk/src/input.h"
                     , "input_pgm: could not read magic number\n");
    exit (1);
  }
  if (strcmp (line, "P2\n") && strcmp (line, "P5\n")) {
    fprintf (
# 35 "/Users/weugene/basilisk/src/input.h" 3 4
            __stderrp
# 35 "/Users/weugene/basilisk/src/input.h"
                     , "input_pgm: magic number '%s' does not match PGM\n",
      line);
    exit (1);
  }
  int binary = !strcmp (line, "P5\n");
  if (!fgets (line, 81, p.fp)) {
    fprintf (
# 41 "/Users/weugene/basilisk/src/input.h" 3 4
            __stderrp
# 41 "/Users/weugene/basilisk/src/input.h"
                     , "input_pgm: could not read width and height\n");
    exit (1);
  }
  int width, height;
  while (line[0] == '#' && fgets (line, 81, p.fp));
  if (line[0] == '#' || sscanf (line, "%d %d", &width, &height) != 2) {
    fprintf (
# 47 "/Users/weugene/basilisk/src/input.h" 3 4
            __stderrp
# 47 "/Users/weugene/basilisk/src/input.h"
                     , "input_pgm: could not read width and height\n");
    exit (1);
  }
  if (!fgets (line, 81, p.fp)) {
    fprintf (
# 51 "/Users/weugene/basilisk/src/input.h" 3 4
            __stderrp
# 51 "/Users/weugene/basilisk/src/input.h"
                     , "input_pgm: could not read maxval\n");
    exit (1);
  }
  int maxval;
  if (sscanf (line, "%d", &maxval) != 1) {
    fprintf (
# 56 "/Users/weugene/basilisk/src/input.h" 3 4
            __stderrp
# 56 "/Users/weugene/basilisk/src/input.h"
                     , "input_pgm: could not read maxval\n");
    exit (1);
  }
  if (maxval < 256) {
    unsigned char * a = ((unsigned char *) malloc((width*height)*sizeof(unsigned char)));
    size_t n = 0;
    if (binary)
      n = fread (a, 1, width*height, p.fp);
    else {
      int v;
      while (n < width*height && fscanf (p.fp, "%d ", &v) == 1)
 a[n++] = v;
    }
    if (n != width*height) {
      fprintf (
# 70 "/Users/weugene/basilisk/src/input.h" 3 4
              __stderrp
# 70 "/Users/weugene/basilisk/src/input.h"
                       , "input_pgm: read only %ld values\n", n);
      exit (1);
    }
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 73 "/Users/weugene/basilisk/src/input.h"
 {
      int i = (x - p.ox)*width/p.width, j = (y - p.oy)*width/p.width;
      if (i >= 0 && i < width && j >= 0 && j < height)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = 1. - a[(height - 1 - j)*width + i]/(double)maxval;
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = 0.;
    } } } } }; }
    free(a);
  }
  else {
    unsigned short * a = ((unsigned short *) malloc((width*height)*sizeof(unsigned short)));
    size_t n = 0;
    if (binary)
      n = fread (a, 2, width*height, p.fp);
    else {
      int v;
      while (n < width*height && fscanf (p.fp, "%d ", &v) == 1)
 a[n++] = v;
    }
    if (n != width*height) {
      fprintf (
# 93 "/Users/weugene/basilisk/src/input.h" 3 4
              __stderrp
# 93 "/Users/weugene/basilisk/src/input.h"
                       , "input_pgm: read only %ld values\n", n);
      exit (1);
    }
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 96 "/Users/weugene/basilisk/src/input.h"
 {
      int i = (x - p.ox)*width/p.width, j = (y - p.oy)*width/p.width;
      if (i >= 0 && i < width && j >= 0 && j < height)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = 1. - a[(height - 1 - j)*width + i]/(double)maxval;
      else
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = 0.;
    } } } } }; }
    free(a);
  }
}

static void next_char (FILE * fp, int target)
{
  int c = fgetc(fp), para = 0;
  while (c != 
# 110 "/Users/weugene/basilisk/src/input.h" 3 4
             (-1) 
# 110 "/Users/weugene/basilisk/src/input.h"
                 && (c != target || para > 0)) {
    if (c == '{') para++;
    if (c == '}') para--;
    c = fgetc(fp);
  }
  if (c != target) {
    fprintf (
# 116 "/Users/weugene/basilisk/src/input.h" 3 4
            __stderrp
# 116 "/Users/weugene/basilisk/src/input.h"
                     , "input_gfs(): error: expecting '%c'\n", target);
    exit (1);
  }
}

static int next_string (FILE * fp, const char * target)
{
  int slen = strlen (target), para = 0;
  char s[slen + 1];
  s[slen] = '\0';
  int len = 0, c = fgetc (fp);
  while (c != 
# 127 "/Users/weugene/basilisk/src/input.h" 3 4
             (-1) 
# 127 "/Users/weugene/basilisk/src/input.h"
                 && len < slen) {
    if (c == '{') para++;
    if (c == '}') para--;
    s[len++] = c;
    c = fgetc (fp);
  }
  while (c != 
# 133 "/Users/weugene/basilisk/src/input.h" 3 4
             (-1) 
# 133 "/Users/weugene/basilisk/src/input.h"
                 && para >= 0) {
    if (!strcmp (s, target) && para == 0)
      break;
    if (c == '{') para++;
    if (c == '}') para--;
    for (int i = 0; i < slen - 1; i++)
      s[i] = s[i+1];
    s[slen - 1] = c;
    c = fgetc (fp);
  }
  if (strcmp (s, target))
    c = -1;
  return c;
}
# 166 "/Users/weugene/basilisk/src/input.h"

void input_gfs (struct OutputGfs p)
{ ;
  ;

  
# 171 "/Users/weugene/basilisk/src/input.h" 3 4
 _Bool 
# 171 "/Users/weugene/basilisk/src/input.h"
      opened = 
# 171 "/Users/weugene/basilisk/src/input.h" 3 4
               0
# 171 "/Users/weugene/basilisk/src/input.h"
                    ;
  if (p.fp == 
# 172 "/Users/weugene/basilisk/src/input.h" 3 4
             ((void *)0)
# 172 "/Users/weugene/basilisk/src/input.h"
                 ) {
    if (p.file == 
# 173 "/Users/weugene/basilisk/src/input.h" 3 4
                 ((void *)0)
# 173 "/Users/weugene/basilisk/src/input.h"
                     )
      p.fp = 
# 174 "/Users/weugene/basilisk/src/input.h" 3 4
            __stdinp
# 174 "/Users/weugene/basilisk/src/input.h"
                 ;
    else if (!(p.fp = fopen (p.file, "r"))) {
      perror (p.file);
      exit (1);
    }
    else
      opened = 
# 180 "/Users/weugene/basilisk/src/input.h" 3 4
              1
# 180 "/Users/weugene/basilisk/src/input.h"
                  ;
  }
  
# 182 "/Users/weugene/basilisk/src/input.h" 3 4
 _Bool 
# 182 "/Users/weugene/basilisk/src/input.h"
      input_all = (p.list == all);
  if (p.list == 
# 183 "/Users/weugene/basilisk/src/input.h" 3 4
               ((void *)0)
# 183 "/Users/weugene/basilisk/src/input.h"
                   ) p.list = all;


  init_grid (1);


  next_char (p.fp, '{');

  char * s = ((char *) malloc((1)*sizeof(char)));
  int len = 0;
  int c = fgetc(p.fp);
  while (c != 
# 194 "/Users/weugene/basilisk/src/input.h" 3 4
             (-1) 
# 194 "/Users/weugene/basilisk/src/input.h"
                 && c != '}') {
    s[len++] = c;
    s = (char *) realloc(s,(len + 1)*sizeof(char));
    s[len] = '\0';
    c = fgetc(p.fp);
  }
  if (c != '}') {
    fprintf (
# 201 "/Users/weugene/basilisk/src/input.h" 3 4
            __stderrp
# 201 "/Users/weugene/basilisk/src/input.h"
                     , "input_gfs(): error: expecting '}'\n");
    exit (1);
  }

  char * s1 = strstr (s, "variables");
  if (!s1) {
    fprintf (
# 207 "/Users/weugene/basilisk/src/input.h" 3 4
            __stderrp
# 207 "/Users/weugene/basilisk/src/input.h"
                     , "input_gfs(): error: expecting 'variables'\n");
    exit (1);
  }

  s1 = strstr (s1, "=");
  if (!s1) {
    fprintf (
# 213 "/Users/weugene/basilisk/src/input.h" 3 4
            __stderrp
# 213 "/Users/weugene/basilisk/src/input.h"
                     , "input_gfs(): error: expecting '='\n");
    exit (1);
  }
  s1++;

  while (strchr (" \t", *s1))
    s1++;

  scalar * input = 
# 221 "/Users/weugene/basilisk/src/input.h" 3 4
                  ((void *)0)
# 221 "/Users/weugene/basilisk/src/input.h"
                      ;
  s1 = strtok (s1, ", \t");
  while (s1) {
    char * name = replace (s1, '_', '.', 
# 224 "/Users/weugene/basilisk/src/input.h" 3 4
                                        0
# 224 "/Users/weugene/basilisk/src/input.h"
                                             );
    
# 225 "/Users/weugene/basilisk/src/input.h" 3 4
   _Bool 
# 225 "/Users/weugene/basilisk/src/input.h"
        found = 
# 225 "/Users/weugene/basilisk/src/input.h" 3 4
                0
# 225 "/Users/weugene/basilisk/src/input.h"
                     ;
    if (p.list) for (scalar s = *p.list, *_i91 = p.list; ((scalar *)&s)->i >= 0; s = *++_i91)
      if (!((s).i >= 65536) && _attribute[s.i].name && !strcmp (_attribute[s.i].name, name)) {
 input = list_append (input, s);
 found = 
# 229 "/Users/weugene/basilisk/src/input.h" 3 4
        1
# 229 "/Users/weugene/basilisk/src/input.h"
            ; break;
      }
    if (!found) {
      if (input_all) {
 scalar s = new_scalar("s");
 free(_attribute[s.i].name);
 _attribute[s.i].name = strdup(name);
 input = list_append (input, s);
      }
      else
 input = list_append (input, (scalar){0x7fffffff});
    }
    free(name);
    s1 = strtok (
# 242 "/Users/weugene/basilisk/src/input.h" 3 4
                ((void *)0)
# 242 "/Users/weugene/basilisk/src/input.h"
                    , ", \t");
  }
  free(s);

  next_char (p.fp, '{');
  double t1 = 0.;
  if (next_string (p.fp, "Time") >= 0) {
    next_char (p.fp, '{');
    next_char (p.fp, 't');
    next_char (p.fp, '=');
    if (fscanf (p.fp, "%lf", &t1) != 1) {
      fprintf (
# 253 "/Users/weugene/basilisk/src/input.h" 3 4
              __stderrp
# 253 "/Users/weugene/basilisk/src/input.h"
                       , "input_gfs(): error: expecting 't'\n");
      exit (1);
    }
    next_char (p.fp, '}');
    next_char (p.fp, '}');
  }

  if (next_string (p.fp, "Box") < 0) {
    fprintf (
# 261 "/Users/weugene/basilisk/src/input.h" 3 4
            __stderrp
# 261 "/Users/weugene/basilisk/src/input.h"
                     , "input_gfs(): error: expecting 'GfsBox'\n");
    exit (1);
  }

  next_char (p.fp, '{');
  next_char (p.fp, '{');
  next_char (p.fp, '\n');

  scalar * listm = ((scalar []){cm,fm.x,fm.y,{-1}});
  scalar * listr = !((cm).i >= 65536) ? listm : 
# 270 "/Users/weugene/basilisk/src/input.h" 3 4
                                             ((void *)0)
# 270 "/Users/weugene/basilisk/src/input.h"
                                                 ;
  (void)(listr);

   { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 273 "/Users/weugene/basilisk/src/input.h"
 {
    unsigned flags;
    if (fread (&flags, sizeof (unsigned), 1, p.fp) != 1) {
      fprintf (
# 276 "/Users/weugene/basilisk/src/input.h" 3 4
              __stderrp
# 276 "/Users/weugene/basilisk/src/input.h"
                       , "input_gfs(): error: expecting 'flags'\n");
      exit (1);
    }
    if (!(flags & (1 << 4)) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf))
      refine_cell (point, listr, 0, 
# 280 "/Users/weugene/basilisk/src/input.h" 3 4
                                   ((void *)0)
# 280 "/Users/weugene/basilisk/src/input.h"
                                       );
    double a;
    if (fread (&a, sizeof (double), 1, p.fp) != 1 || a != -1) {
      fprintf (
# 283 "/Users/weugene/basilisk/src/input.h" 3 4
              __stderrp
# 283 "/Users/weugene/basilisk/src/input.h"
                       , "input_gfs(): error: expecting '-1'\n");
      exit (1);
    }
    if (input) for (scalar s = *input, *_i92 = input; ((scalar *)&s)->i >= 0; s = *++_i92) {
      if (fread (&a, sizeof (double), 1, p.fp) != 1) {
 fprintf (
# 288 "/Users/weugene/basilisk/src/input.h" 3 4
         __stderrp
# 288 "/Users/weugene/basilisk/src/input.h"
                  , "input_gfs(): error: expecting a scalar\n");
 exit (1);
      }
      if (s.i != 0x7fffffff) {
 if (_attribute[s.i].v.x.i >= 0) {



   if (_attribute[s.i].v.x.i == s.i) {
     s = _attribute[s.i].v.y;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = a;
   }
   else if (_attribute[s.i].v.y.i == s.i) {
     s = _attribute[s.i].v.x;
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = - a;
   }





 }
 else
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i] = a;
      }
    }
    if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf))
      continue;
  } } if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } }; }
  boundary (listm);
  boundary (input);

  free(input);
  if (opened)
    fclose (p.fp);


  while (t < t1 && events (
# 325 "/Users/weugene/basilisk/src/input.h" 3 4
                          0
# 325 "/Users/weugene/basilisk/src/input.h"
                               ))
    t = tnext;
  events (
# 327 "/Users/weugene/basilisk/src/input.h" 3 4
         0
# 327 "/Users/weugene/basilisk/src/input.h"
              );
 ; }
# 357 "/Users/weugene/basilisk/src/input.h"
struct InputGRD {
  scalar s;
  FILE * fp;
  char * file;
  double nodatavalue;
  
# 362 "/Users/weugene/basilisk/src/input.h" 3 4
 _Bool 
# 362 "/Users/weugene/basilisk/src/input.h"
      linear;
};

void input_grd (struct InputGRD p)
{
  scalar input = p.s;

  
# 369 "/Users/weugene/basilisk/src/input.h" 3 4
 _Bool 
# 369 "/Users/weugene/basilisk/src/input.h"
      opened = 
# 369 "/Users/weugene/basilisk/src/input.h" 3 4
               0
# 369 "/Users/weugene/basilisk/src/input.h"
                    ;
  if (p.fp == 
# 370 "/Users/weugene/basilisk/src/input.h" 3 4
             ((void *)0)
# 370 "/Users/weugene/basilisk/src/input.h"
                 ) {
    if (p.file == 
# 371 "/Users/weugene/basilisk/src/input.h" 3 4
                 ((void *)0)
# 371 "/Users/weugene/basilisk/src/input.h"
                     )
      p.fp = 
# 372 "/Users/weugene/basilisk/src/input.h" 3 4
            __stdinp
# 372 "/Users/weugene/basilisk/src/input.h"
                 ;
    else if (!(p.fp = fopen (p.file, "r"))) {
      perror (p.file);
      exit (1);
    }
    else
      opened = 
# 378 "/Users/weugene/basilisk/src/input.h" 3 4
              1
# 378 "/Users/weugene/basilisk/src/input.h"
                  ;
  }


  double DeltaGRD;
  int nx, ny;
  double XG0, YG0, ndv;


  char waste[100];
  fscanf (p.fp, "%s %d", waste, &nx);
  fscanf (p.fp, "%s %d", waste, &ny);
  fscanf (p.fp, "%s %lf", waste, &XG0);
  fscanf (p.fp, "%s %lf", waste, &YG0);
  fscanf (p.fp, "%s %lf", waste, &DeltaGRD);
  fscanf (p.fp, "%s %lf", waste, &ndv);


  if (!p.nodatavalue)
    p.nodatavalue = ndv;


  double * value = ((double *) malloc((nx*ny)*sizeof(double)));
  for (int i = ny - 1; i >= 0; i--)
    for (int j = 0 ; j < nx; j++)
      fscanf (p.fp, "%lf ", &value[j + i*nx]);

  double LGx0 = nx*DeltaGRD;
  double LGy0 = ny*DeltaGRD;
  
# 407 "/Users/weugene/basilisk/src/input.h" 3 4
 _Bool 
# 407 "/Users/weugene/basilisk/src/input.h"
      warning = 
# 407 "/Users/weugene/basilisk/src/input.h" 3 4
                0
# 407 "/Users/weugene/basilisk/src/input.h"
                     ;

   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 409 "/Users/weugene/basilisk/src/input.h"
 {

    
# 411 "/Users/weugene/basilisk/src/input.h" 3 4
   _Bool 
# 411 "/Users/weugene/basilisk/src/input.h"
        incl = (x >= XG0 - DeltaGRD/2. &&
   x <= XG0 + LGx0 + DeltaGRD/2. &&
   y >= YG0 - DeltaGRD/2. &&
   y <= YG0 + LGy0 + DeltaGRD/2.);
    if (incl) {
      double val;

      
# 418 "/Users/weugene/basilisk/src/input.h" 3 4
     _Bool 
# 418 "/Users/weugene/basilisk/src/input.h"
          ring = (x >= XG0 &&
     x <= XG0 + LGx0 &&
     y >= YG0 &&
     y <= YG0 + LGy0);
      if (p.linear && ring ) {
 int j = (x - XG0)/DeltaGRD; int i = (y - YG0)/DeltaGRD;
 double dx = x -(j*DeltaGRD + XG0); double dy = y - (i*DeltaGRD + YG0);
 val = value[j + i*nx]
   + dx*(value[j + 1 + i*nx] - value[j + i*nx])/DeltaGRD
   + dy*(value[j + (i + 1)*nx] - value[j + i*nx])/DeltaGRD
   + dx*dy*(value[j + i*nx] + value[j +1 + (i+1)*nx]
     - value[j + (i + 1)*nx]-value[j + 1 + i*nx])/((DeltaGRD)*(DeltaGRD));
      }
      else {
 int j = (x - XG0 + DeltaGRD/2.)/DeltaGRD;
 int i = (y - YG0 + DeltaGRD/2.)/DeltaGRD;
 val = value[j + i*nx];
      }
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[input.i] = val;
      if (val == ndv)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[input.i] = p.nodatavalue;
    }
    else {
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[input.i] = p.nodatavalue;
      warning = 
# 442 "/Users/weugene/basilisk/src/input.h" 3 4
               1
# 442 "/Users/weugene/basilisk/src/input.h"
                   ;
    }
  } } } } }; }
  free(value);

  if (warning)
    fprintf (
# 448 "/Users/weugene/basilisk/src/input.h" 3 4
            __stderrp
# 448 "/Users/weugene/basilisk/src/input.h"
                     ,
      "input_grd(): Warning: Raster data is not covering all"
      " the simulation area\n");

  if (opened)
    fclose (p.fp);
}
# 76 "/Users/weugene/basilisk/src/view.h"






struct _bview {
  float tx, ty, sx, sy, sz;
  float quat[4];
  float fov;

  
# 87 "/Users/weugene/basilisk/src/view.h" 3 4
 _Bool 
# 87 "/Users/weugene/basilisk/src/view.h"
      gfsview;
  
# 88 "/Users/weugene/basilisk/src/view.h" 3 4
 _Bool 
# 88 "/Users/weugene/basilisk/src/view.h"
      vector;
  
# 89 "/Users/weugene/basilisk/src/view.h" 3 4
 _Bool 
# 89 "/Users/weugene/basilisk/src/view.h"
      reversed;

  float bg[3];
  float lc;
  float res;

  unsigned width, height, samples;

  framebuffer * fb;
  Frustum frustum;

  void (* map) (coord *);

  int ni;

  
# 104 "/Users/weugene/basilisk/src/view.h" 3 4
 _Bool 
# 104 "/Users/weugene/basilisk/src/view.h"
      active;
};

typedef struct _bview bview;




bview * bview_new() {
  bview * p = ((bview *) calloc(1,sizeof(bview)));

  p->tx = p->ty = 0;
  p->sx = p->sy = p->sz = 1.;
  p->quat[0] = p->quat[1] = p->quat[2] = 0; p->quat[3] = 1;
  p->fov = 24.;
  gl_trackball (p->quat, 0.0, 0.0, 0.0, 0.0);


  p->bg[0] = 1; p->bg[1] = 1; p->bg[2] = 1;



  p->res = 1.;
  p->lc = 0.001;

  p->vector = 
# 129 "/Users/weugene/basilisk/src/view.h" 3 4
             0
# 129 "/Users/weugene/basilisk/src/view.h"
                  ;

  p->samples = 4;
  p->width = 600*p->samples, p->height = 600*p->samples;

  p->fb = framebuffer_new (p->width, p->height);

  init_gl();
  p->active = 
# 137 "/Users/weugene/basilisk/src/view.h" 3 4
             0
# 137 "/Users/weugene/basilisk/src/view.h"
                  ;

  return p;
}




void bview_destroy (bview * p)
{
  framebuffer_destroy (p->fb);
  free(p);
}




static bview * _view = 
# 154 "/Users/weugene/basilisk/src/view.h" 3 4
                      ((void *)0)
# 154 "/Users/weugene/basilisk/src/view.h"
                          ;






static void destroy_view()
{
  
# 163 "/Users/weugene/basilisk/src/view.h" 3 4
 (__builtin_expect(!(
# 163 "/Users/weugene/basilisk/src/view.h"
 _view
# 163 "/Users/weugene/basilisk/src/view.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/view.h", 163, 
# 163 "/Users/weugene/basilisk/src/view.h"
 "_view"
# 163 "/Users/weugene/basilisk/src/view.h" 3 4
 ) : (void)0)
# 163 "/Users/weugene/basilisk/src/view.h"
               ;
  bview_destroy (_view);
}

bview * get_view() {
  if (!_view) {
    _view = bview_new();
    free_solver_func_add (destroy_view);
  }
  return _view;
}




static void redraw() {
  bview * view = get_view();


  fedisableexcept (
# 182 "/Users/weugene/basilisk/src/view.h" 3 4
 0x0004
# 182 "/Users/weugene/basilisk/src/view.h"
 |
# 182 "/Users/weugene/basilisk/src/view.h" 3 4
 0x0001
# 182 "/Users/weugene/basilisk/src/view.h"
 );

  glMatrixMode (
# 184 "/Users/weugene/basilisk/src/view.h" 3
               0x1701
# 184 "/Users/weugene/basilisk/src/view.h"
                            );
  glLoadIdentity ();
  double max = 2.;





  gluPerspective (view->fov, view->width/(float)view->height, 1., 1. + 2.*max);

  glMatrixMode (
# 194 "/Users/weugene/basilisk/src/view.h" 3
               0x1700
# 194 "/Users/weugene/basilisk/src/view.h"
                           );

  glLoadIdentity ();
  glTranslatef (view->tx, view->ty, - (1. + max));

  GLfloat m[4][4];
  gl_build_rotmatrix (m, view->quat);
  glMultMatrixf (&m[0][0]);

  if (view->gfsview) {
    m[0][0] = 0., m[0][1] = 0., m[0][2] = -1.;
    m[1][0] = 0., m[1][1] = -1., m[1][2] = 0.;
    m[2][0] = 1., m[2][1] = 0., m[2][2] = 0.;
    glMultMatrixf (&m[0][0]);
  }

  glScalef (view->sx/L0, view->sy/L0, view->sz/L0);

  glClearColor (view->bg[0], view->bg[1], view->bg[2], 0.);
  glClear (
# 213 "/Users/weugene/basilisk/src/view.h" 3
          0x00004000
# 213 "/Users/weugene/basilisk/src/view.h"
                             |
# 213 "/Users/weugene/basilisk/src/view.h" 3
                              0x00000100
# 213 "/Users/weugene/basilisk/src/view.h"
                                                 );

  gl_get_frustum (&view->frustum);

  view->active = 
# 217 "/Users/weugene/basilisk/src/view.h" 3 4
                1
# 217 "/Users/weugene/basilisk/src/view.h"
                    ;
  view->ni = 0;
}




bview * draw() {
  bview * view = get_view();
  if (!view->active)
    redraw();
  else


    fedisableexcept (
# 231 "/Users/weugene/basilisk/src/view.h" 3 4
   0x0004
# 231 "/Users/weugene/basilisk/src/view.h"
   |
# 231 "/Users/weugene/basilisk/src/view.h" 3 4
   0x0001
# 231 "/Users/weugene/basilisk/src/view.h"
   );
  return view;
}







typedef void * pointer;



static pointer compose_image (bview * view) { ;
  { pointer _ret = framebuffer_image((view)->fb); ; return _ret; }
 ; }
# 345 "/Users/weugene/basilisk/src/view.h"
# 1 "draw.h"
# 1 "/Users/weugene/basilisk/src/draw.h"
# 1 "fractions.h"
# 1 "/Users/weugene/basilisk/src/fractions.h"
# 12 "/Users/weugene/basilisk/src/fractions.h"
# 1 "geometry.h"
# 1 "/Users/weugene/basilisk/src/geometry.h"
# 28 "/Users/weugene/basilisk/src/geometry.h"
double line_alpha (double c, coord n)
{
  double alpha, n1, n2;

  n1 = fabs (n.x); n2 = fabs (n.y);
  if (n1 > n2)
    { double tmp = n1; n1 = n2; n2 = tmp; };

  c = ((c) < (0.) ? (0.) : (c) > (1.) ? (1.) : (c));
  double v1 = n1/2.;
  if (c <= v1/n2)
    alpha = sqrt (2.*c*n1*n2);
  else if (c <= 1. - v1/n2)
    alpha = c*n2 + v1;
  else
    alpha = n1 + n2 - sqrt (2.*n1*n2*(1. - c));

  if (n.x < 0.)
    alpha += n.x;
  if (n.y < 0.)
    alpha += n.y;

  return alpha - (n.x + n.y)/2.;
}
# 133 "/Users/weugene/basilisk/src/geometry.h"
double line_area (double nx, double ny, double alpha)
{
  double a, v, area;

  alpha += (nx + ny)/2.;
  if (nx < 0.) {
    alpha -= nx;
    nx = - nx;
  }
  if (ny < 0.) {
    alpha -= ny;
    ny = - ny;
  }

  if (alpha <= 0.)
    return 0.;

  if (alpha >= nx + ny)
    return 1.;

  if (nx < 1e-10)
    area = alpha/ny;
  else if (ny < 1e-10)
    area = alpha/nx;
  else {
    v = ((alpha)*(alpha));

    a = alpha - nx;
    if (a > 0.)
      v -= a*a;

    a = alpha - ny;
    if (a > 0.)
      v -= a*a;

    area = v/(2.*nx*ny);
  }

  return ((area) < (0.) ? (0.) : (area) > (1.) ? (1.) : (area));
}
# 237 "/Users/weugene/basilisk/src/geometry.h"
double rectangle_fraction (coord n, double alpha, coord a, coord b)
{
  coord n1;
  {
# 240 "/Users/weugene/basilisk/src/geometry.h"
 {
    alpha -= n.x*(b.x + a.x)/2.;
    n1.x = n.x*(b.x - a.x);
  }
# 240 "/Users/weugene/basilisk/src/geometry.h"
 {
    alpha -= n.y*(b.y + a.y)/2.;
    n1.y = n.y*(b.y - a.y);
  }}
  return line_area(n1.x, n1.y, alpha);
}
# 262 "/Users/weugene/basilisk/src/geometry.h"
int facets (coord n, double alpha, coord p[2])
{
  int i = 0;
  for (double s = -0.5; s <= 0.5; s += 1.)
    {
# 266 "/Users/weugene/basilisk/src/geometry.h"

      if (fabs (n.y) > 1e-4 && i < 2) {
 double a = (alpha - s*n.x)/n.y;
 if (a >= -0.5 && a <= 0.5) {
   p[i].x = s;
   p[i++].y = a;
 }
      }
# 266 "/Users/weugene/basilisk/src/geometry.h"

      if (fabs (n.x) > 1e-4 && i < 2) {
 double a = (alpha - s*n.y)/n.x;
 if (a >= -0.5 && a <= 0.5) {
   p[i].y = s;
   p[i++].x = a;
 }
      }}
  return i;
}
# 352 "/Users/weugene/basilisk/src/geometry.h"
double line_length_center (coord m, double alpha, coord * p)
{
  alpha += (m.x + m.y)/2.;

  coord n = m;
  {
# 357 "/Users/weugene/basilisk/src/geometry.h"

    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }
# 357 "/Users/weugene/basilisk/src/geometry.h"

    if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }}

  p->x = p->y = p->z = 0.;

  if (alpha <= 0. || alpha >= n.x + n.y)
    return 0.;

  {
# 368 "/Users/weugene/basilisk/src/geometry.h"

    if (n.x < 1e-4) {
      p->x = 0.;
      p->y = (m.y < 0. ? 1. - alpha : alpha) - 0.5;
      return 1.;
    }
# 368 "/Users/weugene/basilisk/src/geometry.h"

    if (n.y < 1e-4) {
      p->y = 0.;
      p->x = (m.x < 0. ? 1. - alpha : alpha) - 0.5;
      return 1.;
    }}

  if (alpha >= n.x) {
    p->x += 1.;
    p->y += (alpha - n.x)/n.y;
  }
  else
    p->x += alpha/n.x;

  double ax = p->x, ay = p->y;
  if (alpha >= n.y) {
    p->y += 1.;
    ay -= 1.;
    p->x += (alpha - n.y)/n.x;
    ax -= (alpha - n.y)/n.x;
  }
  else {
    p->y += alpha/n.y;
    ay -= alpha/n.y;
  }

  {
# 394 "/Users/weugene/basilisk/src/geometry.h"
 {
    p->x /= 2.;
    p->x = ((p->x) < (0.) ? (0.) : (p->x) > (1.) ? (1.) : (p->x));
    if (m.x < 0.)
      p->x = 1. - p->x;
    p->x -= 0.5;
  }
# 394 "/Users/weugene/basilisk/src/geometry.h"
 {
    p->y /= 2.;
    p->y = ((p->y) < (0.) ? (0.) : (p->y) > (1.) ? (1.) : (p->y));
    if (m.y < 0.)
      p->y = 1. - p->y;
    p->y -= 0.5;
  }}

  return sqrt (ax*ax + ay*ay);
}
# 482 "/Users/weugene/basilisk/src/geometry.h"
void line_center (coord m, double alpha, double a, coord * p)
{
  alpha += (m.x + m.y)/2.;

  coord n = m;
  {
# 487 "/Users/weugene/basilisk/src/geometry.h"

    if (n.x < 0.) {
      alpha -= n.x;
      n.x = - n.x;
    }
# 487 "/Users/weugene/basilisk/src/geometry.h"

    if (n.y < 0.) {
      alpha -= n.y;
      n.y = - n.y;
    }}

  p->z = 0.;
  if (alpha <= 0.) {
    p->x = p->y = -0.5;
    return;
  }

  if (alpha >= n.x + n.y) {
    p->x = p->y = 0.;
    return;
  }

  {
# 504 "/Users/weugene/basilisk/src/geometry.h"

    if (n.x < 1e-4) {
      p->x = 0.;
      p->y = ((m.y) > 0 ? 1 : -1)*(a/2. - 0.5);
      return;
    }
# 504 "/Users/weugene/basilisk/src/geometry.h"

    if (n.y < 1e-4) {
      p->y = 0.;
      p->x = ((m.x) > 0 ? 1 : -1)*(a/2. - 0.5);
      return;
    }}

  p->x = p->y = ((alpha)*(alpha)*(alpha));

  {
# 513 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = alpha - n.x;
    if (b > 0.) {
      p->x -= ((b)*(b))*(alpha + 2.*n.x);
      p->y -= ((b)*(b)*(b));
    }
  }
# 513 "/Users/weugene/basilisk/src/geometry.h"
 {
    double b = alpha - n.y;
    if (b > 0.) {
      p->y -= ((b)*(b))*(alpha + 2.*n.y);
      p->x -= ((b)*(b)*(b));
    }
  }}

  {
# 521 "/Users/weugene/basilisk/src/geometry.h"
 {
    p->x /= 6.*((n.x)*(n.x))*n.y*a;
    p->x = ((m.x) > 0 ? 1 : -1)*(p->x - 0.5);
  }
# 521 "/Users/weugene/basilisk/src/geometry.h"
 {
    p->y /= 6.*((n.y)*(n.y))*n.x*a;
    p->y = ((m.y) > 0 ? 1 : -1)*(p->y - 0.5);
  }}
}
# 13 "/Users/weugene/basilisk/src/fractions.h"
# 1 "myc2d.h"
# 1 "/Users/weugene/basilisk/src/myc2d.h"





coord mycs (Point point, scalar c)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 7 "/Users/weugene/basilisk/src/myc2d.h"

  int ix;
  double c_t,c_b,c_r,c_l;
  double mx0,my0,mx1,my1,mm1,mm2;


  c_t = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[c.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[c.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[c.i];
  c_b = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[c.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[c.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[c.i];
  c_r = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[c.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[c.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[c.i];
  c_l = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[c.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[c.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[c.i];



  mx0 = 0.5*(c_l-c_r);
  my0 = 0.5*(c_b-c_t);


  if (fabs(mx0) <= fabs(my0)) {
    my0 = my0 > 0. ? 1. : -1.;
    ix = 1;
  }
  else {
    mx0 = mx0 > 0. ? 1. : -1.;
    ix = 0;
  }


  mm1 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[c.i] + 2.0*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[c.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[c.i];
  mm2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[c.i] + 2.0*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[c.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[c.i];
  mx1 = mm1 - mm2 + 1.e-30;
  mm1 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[c.i] + 2.0*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[c.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[c.i];
  mm2 = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[c.i] + 2.0*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[c.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[c.i];
  my1 = mm1 - mm2 + 1.e-30;


  if (ix) {
    mm1 = fabs(my1);
    mm1 = fabs(mx1)/mm1;
    if (mm1 > fabs(mx0)) {
      mx0 = mx1;
      my0 = my1;
    }
  }
  else {
    mm1 = fabs(mx1);
    mm1 = fabs(my1)/mm1;
    if (mm1 > fabs(my0)) {
      mx0 = mx1;
      my0 = my1;
    }
  }



  mm1 = fabs(mx0) + fabs(my0);
  coord n = {mx0/mm1, my0/mm1};

  return n;
}
# 20 "/Users/weugene/basilisk/src/fractions.h"
# 41 "/Users/weugene/basilisk/src/fractions.h"
void fraction_refine (Point point, scalar c)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 42 "/Users/weugene/basilisk/src/fractions.h"






  double cc = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i];
  if (cc <= 0. || cc >= 1.)
     { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] = cc; } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
  else {




    coord n = mycs (point, c);
    double alpha = line_alpha (cc, n);






     { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
      static const coord a = {0.,0.,0.}, b = {.5,.5,.5};
      coord nc;
      {
# 68 "/Users/weugene/basilisk/src/fractions.h"

 nc.x = child.x*n.x;
# 68 "/Users/weugene/basilisk/src/fractions.h"

 nc.y = child.y*n.y;}
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] = rectangle_fraction (nc, alpha, a, b);
    } } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
  }
}
# 85 "/Users/weugene/basilisk/src/fractions.h"
static void alpha_refine (Point point, scalar alpha)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 86 "/Users/weugene/basilisk/src/fractions.h"

  vector n = _attribute[alpha.i].n;
  double alphac = 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.i];
  coord m;
  {
# 90 "/Users/weugene/basilisk/src/fractions.h"

    m.x = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[n.x.i];
# 90 "/Users/weugene/basilisk/src/fractions.h"

    m.y = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[n.y.i];}
   { { int _i = 2*point.i - 2, _j = 2*point.j - 2; point.level++; for (int _k = 0; _k < 2; _k++) { point.i = _i + _k; for (int _l = 0; _l < 2; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.i] = alphac;
    {
# 94 "/Users/weugene/basilisk/src/fractions.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.i] -= child.x*m.x/2.;
# 94 "/Users/weugene/basilisk/src/fractions.h"

      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.i] -= child.y*m.y/2.;}
  } } } point.i = (_i + 2)/2; point.j = (_j + 2)/2; point.level--;}; }
}
# 121 "/Users/weugene/basilisk/src/fractions.h"
struct Fractions {
  scalar Phi;
  scalar c;
  vector s;
  double val;
};


void fractions (struct Fractions a)
{ ;
  scalar Phi = a.Phi;
  scalar c = a.c;
  vector s = (a.s).x.i ? (a.s) : new_face_vector("s");
  double val = a.val;
# 145 "/Users/weugene/basilisk/src/fractions.h"
  vector p;
  p.x = s.y; p.y = s.x;
# 155 "/Users/weugene/basilisk/src/fractions.h"
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->faces.n; _k++) { point.i = ((Tree *)grid)->faces.p[_k].i; point.j = ((Tree *)grid)->faces.p[_k].j; point.level = ((Tree *)grid)->faces.p[_k].level; _flags = ((Tree *)grid)->faces.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { int jg = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_y)) {
# 155 "/Users/weugene/basilisk/src/fractions.h"
{
# 155 "/Users/weugene/basilisk/src/fractions.h"
 {





    if ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[Phi.i] - val)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[Phi.i] - val) < 0.) {






      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.x.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[Phi.i] - val)/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[Phi.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[Phi.i]);
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[Phi.i] < val)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.x.i] = 1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.x.i];
    }
# 180 "/Users/weugene/basilisk/src/fractions.h"
    else
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.x.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[Phi.i] > val || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[Phi.i] > val);
  } } }} { int ig = -1; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ;; if ((_flags & face_x)) {
# 155 "/Users/weugene/basilisk/src/fractions.h"
{
# 155 "/Users/weugene/basilisk/src/fractions.h"
 {





    if ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[Phi.i] - val)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[Phi.i] - val) < 0.) {






      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.y.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[Phi.i] - val)/(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[Phi.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[Phi.i]);
      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[Phi.i] < val)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.y.i] = 1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.y.i];
    }
# 180 "/Users/weugene/basilisk/src/fractions.h"
    else
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.y.i] = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[Phi.i] > val || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[Phi.i] > val);
  } } }} } } }
# 182 "/Users/weugene/basilisk/src/fractions.h"
 ; }
# 197 "/Users/weugene/basilisk/src/fractions.h"
  boundary_flux (((vector []){{s.x,s.y},{{-1},{-1}}}));
  scalar s_z = c;
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 199 "/Users/weugene/basilisk/src/fractions.h"


  {
# 233 "/Users/weugene/basilisk/src/fractions.h"
    coord n;
    double nn = 0.;
    {
# 235 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.x = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[p.y.i];
      nn += fabs(n.x);
    }
# 235 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.y = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[p.x.i];
      nn += fabs(n.y);
    }}





    if (nn == 0.)
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s_z.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.x.i];
    else {





      {
# 252 "/Users/weugene/basilisk/src/fractions.h"

 n.x /= nn;
# 252 "/Users/weugene/basilisk/src/fractions.h"

 n.y /= nn;}






      double alpha = 0., ni = 0.;
      for (int i = 0; i <= 1; i++)
 {
# 262 "/Users/weugene/basilisk/src/fractions.h"

   if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[p.x.i] > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[p.x.i] < 1.) {
     double a = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[Phi.i] - val) > 0 ? 1 : -1)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+i]) + sizeof(Cell)))[p.x.i] - 0.5);
     alpha += n.x*a + n.y*(i - 0.5);
     ni++;
   }
# 262 "/Users/weugene/basilisk/src/fractions.h"

   if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[p.y.i] > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[p.y.i] < 1.) {
     double a = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[Phi.i] - val) > 0 ? 1 : -1)*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+i][point.j+0]) + sizeof(Cell)))[p.y.i] - 0.5);
     alpha += n.y*a + n.x*(i - 0.5);
     ni++;
   }}
# 276 "/Users/weugene/basilisk/src/fractions.h"
      if (ni == 0)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s_z.i] = ((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.x.i]) > (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.y.i]) ? (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.x.i]) : (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[p.y.i]));
      else if (ni != 4)
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s_z.i] = line_area (n.x, n.y, alpha/ni);
      else {



 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s_z.i] = 0.;

      }
    }
  } } } } }; }
# 345 "/Users/weugene/basilisk/src/fractions.h"
  boundary (((scalar []){c,{-1}}));
 { if (!(a.s).x.i) delete (((scalar []){s.x,s.y,{-1}})); } ; }
# 384 "/Users/weugene/basilisk/src/fractions.h"
coord youngs_normal (Point point, scalar c)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 385 "/Users/weugene/basilisk/src/fractions.h"

  coord n;
  double nn = 0.;
  
# 388 "/Users/weugene/basilisk/src/fractions.h" 3 4
 (__builtin_expect(!(
# 388 "/Users/weugene/basilisk/src/fractions.h"
 2 == 2
# 388 "/Users/weugene/basilisk/src/fractions.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/fractions.h", 388, 
# 388 "/Users/weugene/basilisk/src/fractions.h"
 "2 == 2"
# 388 "/Users/weugene/basilisk/src/fractions.h" 3 4
 ) : (void)0)
# 388 "/Users/weugene/basilisk/src/fractions.h"
                ;
  {
# 389 "/Users/weugene/basilisk/src/fractions.h"
 {
    n.x = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[c.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[c.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[c.i] -
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+1]) + sizeof(Cell)))[c.i] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+0]) + sizeof(Cell)))[c.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+ +1][point.j+-1]) + sizeof(Cell)))[c.i]);
    nn += fabs(n.x);
  }
# 389 "/Users/weugene/basilisk/src/fractions.h"
 {
    n.y = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[c.i] + 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[c.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[c.i] -
    ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+ +1]) + sizeof(Cell)))[c.i] - 2.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+ +1]) + sizeof(Cell)))[c.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+ +1]) + sizeof(Cell)))[c.i]);
    nn += fabs(n.y);
  }}

  if (nn > 0.)
    {
# 396 "/Users/weugene/basilisk/src/fractions.h"

      n.x /= nn;
# 396 "/Users/weugene/basilisk/src/fractions.h"

      n.y /= nn;}
  else
    n.x = 1.;
  return n;
}





coord facet_normal (Point point, scalar c, vector s)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 408 "/Users/weugene/basilisk/src/fractions.h"

  if (s.x.i >= 0) {
    coord n;
    double nn = 0.;
    {
# 412 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.x = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.x.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[s.x.i];
      nn += fabs(n.x);
    }
# 412 "/Users/weugene/basilisk/src/fractions.h"
 {
      n.y = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.y.i] - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[s.y.i];
      nn += fabs(n.y);
    }}
    if (nn > 0.)
      {
# 417 "/Users/weugene/basilisk/src/fractions.h"

 n.x /= nn;
# 417 "/Users/weugene/basilisk/src/fractions.h"

 n.y /= nn;}
    else
      {
# 420 "/Users/weugene/basilisk/src/fractions.h"

 n.x = 1./2;
# 420 "/Users/weugene/basilisk/src/fractions.h"

 n.y = 1./2;}
    return n;
  }
  return mycs (point, c);
}
# 434 "/Users/weugene/basilisk/src/fractions.h"

void reconstruction (const scalar c, vector n, scalar alpha)
{ ;
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 437 "/Users/weugene/basilisk/src/fractions.h"
 {





    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] <= 0. || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] >= 1.) {
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.i] = 0.;
      {
# 445 "/Users/weugene/basilisk/src/fractions.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[n.x.i] = 0.;
# 445 "/Users/weugene/basilisk/src/fractions.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[n.y.i] = 0.;}
    }
    else {






      coord m = mycs (point, c);
      {
# 456 "/Users/weugene/basilisk/src/fractions.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[n.x.i] = m.x;
# 456 "/Users/weugene/basilisk/src/fractions.h"

 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[n.y.i] = m.y;}
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.i] = line_alpha (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i], m);
    }
  } } } } }; }
# 469 "/Users/weugene/basilisk/src/fractions.h"
  {
# 469 "/Users/weugene/basilisk/src/fractions.h"

    _attribute[n.x.i].refine = _attribute[n.x.i].prolongation = refine_injection;
# 469 "/Users/weugene/basilisk/src/fractions.h"

    _attribute[n.y.i].refine = _attribute[n.y.i].prolongation = refine_injection;}




  _attribute[alpha.i].n = n;
  _attribute[alpha.i].refine = _attribute[alpha.i].prolongation = alpha_refine;







  boundary (((scalar []){n.x,n.y,alpha,{-1}}));
 ; }
# 505 "/Users/weugene/basilisk/src/fractions.h"
struct OutputFacets {
  scalar c;
  FILE * fp;
  vector s;
};


void output_facets (struct OutputFacets p)
{ ;
  scalar c = p.c;
  vector s = p.s;
  if (!p.fp) p.fp = 
# 516 "/Users/weugene/basilisk/src/fractions.h" 3 4
                   __stdoutp
# 516 "/Users/weugene/basilisk/src/fractions.h"
                            ;
  if (!s.x.i) s.x.i = -1;

   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 519 "/Users/weugene/basilisk/src/fractions.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] > 1e-6 && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] < 1. - 1e-6) {
      coord n = facet_normal (point, c, s);
      double alpha = line_alpha (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i], n);

      coord segment[2];
      if (facets (n, alpha, segment) == 2)
 fprintf (p.fp, "%g %g\n%g %g\n\n",
   x + segment[0].x*Delta, y + segment[0].y*Delta,
   x + segment[1].x*Delta, y + segment[1].y*Delta);
# 538 "/Users/weugene/basilisk/src/fractions.h"
    } } } } }; }

  fflush (p.fp);
 ; }
# 550 "/Users/weugene/basilisk/src/fractions.h"
double interface_area (scalar c)
{ ;
  double area = 0.;
   {


 {
double _area = area;
# 553 "/Users/weugene/basilisk/src/fractions.h"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 553 "/Users/weugene/basilisk/src/fractions.h"

    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] > 1e-6 && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] < 1. - 1e-6) {
      coord n = mycs (point, c), p;
      double alpha = line_alpha (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i], n);
      _area += pow(Delta, 2 - 1)*line_length_center(n,alpha,&p);
    } } } } }; area += _area;
;



}
# 558 "/Users/weugene/basilisk/src/fractions.h"
 }
  { double _ret = area; ; return _ret; }
 ; }
# 6 "/Users/weugene/basilisk/src/draw.h"
# 1 "gl/font.h"
# 1 "/Users/weugene/basilisk/src/gl/font.h"
void gl_StrokeCharacter( int character );
void gl_StrokeString( const char *string );
float gl_StrokeWidth( int character );
float gl_StrokeLength( const char *string );
GLfloat gl_StrokeHeight( );
# 7 "/Users/weugene/basilisk/src/draw.h"




void clear()
{
  bview * view = get_view();
  if (view->active)
    view->active = 
# 15 "/Users/weugene/basilisk/src/draw.h" 3 4
                  0
# 15 "/Users/weugene/basilisk/src/draw.h"
                       ;
  draw();
}
# 46 "/Users/weugene/basilisk/src/draw.h"
struct _view_set {
  float tx, ty;
  float fov;
  float quat[4];
  float sx, sy, sz;
  unsigned width, height, samples;
  float bg[3];
  float theta, phi, psi;
  
# 54 "/Users/weugene/basilisk/src/draw.h" 3 4
 _Bool 
# 54 "/Users/weugene/basilisk/src/draw.h"
      relative;
  float res;
  char * camera;
  void (* map) (coord *);
  float p1x, p1y, p2x, p2y;
  bview * view;
};

void view (struct _view_set p)
{
  bview * v = p.view ? p.view : get_view();
  if (p.fov) {
    if (p.relative)
      v->fov += (0.1 + 3.*v->fov)*p.fov;
    else
      v->fov = p.fov;
    v->fov = ((v->fov) < (0.01) ? (0.01) : (v->fov) > (100.) ? (100.) : (v->fov));
  }
  for (int i = 0; i < 4; i++)
    if (p.quat[i]) {
      for (int j = 0; j < 4; j++)
 v->quat[j] = p.quat[j];
      break;
    }
  if (p.tx) v->tx = p.relative ? v->tx + p.tx*0.02*(0.01 + 3.*v->fov) : p.tx;
  if (p.ty) v->ty = p.relative ? v->ty + p.ty*0.02*(0.01 + 3.*v->fov) : p.ty;
  if (p.sx) v->sx = p.sx;
  if (p.sy) v->sy = p.sy;
  if (p.sz) v->sz = p.sz;
  if (p.bg[0] || p.bg[1] || p.bg[2])
    for (int i = 0; i < 3; i++)
      v->bg[i] = p.bg[i];

  if (p.camera) {
    v->gfsview = 
# 88 "/Users/weugene/basilisk/src/draw.h" 3 4
                0
# 88 "/Users/weugene/basilisk/src/draw.h"
                     ;
    if (strlen(p.camera) >= 4 &&
 !strcmp (&p.camera[strlen(p.camera) - 4], ".gfv")) {
      FILE * fp = fopen (p.camera, "r");
      if (!fp) {
 perror (p.camera);
 exit (1);
      }
      char s[81];
      float q[4], fov;
      int nq = 0, nf = 0;
      while (fgets (s, 81, fp) && (!nq || !nf)) {
 if (!nq)
   nq = sscanf (s, "  q0 = %f q1 = %f q2 = %f q3 = %f",
         &q[0], &q[1], &q[2], &q[3]);
 if (!nf)
   nf = sscanf (s, "  fov = %f", &fov);
      }
      if (nq != 4 || nf != 1) {
 fprintf (
# 107 "/Users/weugene/basilisk/src/draw.h" 3 4
         __stderrp
# 107 "/Users/weugene/basilisk/src/draw.h"
                  , "%s: not a valid gfv file\n", p.camera);
 exit (1);
      }
      for (int j = 0; j < 4; j++)
 v->quat[j] = q[j];
      v->fov = fov;
      v->gfsview = 
# 113 "/Users/weugene/basilisk/src/draw.h" 3 4
                  1
# 113 "/Users/weugene/basilisk/src/draw.h"
                      ;
    }
    else if (!strcmp (p.camera, "left"))
      gl_axis_to_quat ((float[]){0,1,0}, - 3.14159265358979/2., v->quat);
    else if (!strcmp (p.camera, "right"))
      gl_axis_to_quat ((float[]){0,1,0}, 3.14159265358979/2., v->quat);
    else if (!strcmp (p.camera, "top"))
      gl_axis_to_quat ((float[]){1,0,0}, - 3.14159265358979/2., v->quat);
    else if (!strcmp (p.camera, "bottom"))
      gl_axis_to_quat ((float[]){1,0,0}, 3.14159265358979/2., v->quat);
    else if (!strcmp (p.camera, "front"))
      gl_axis_to_quat ((float[]){0,0,1}, 0., v->quat);
    else if (!strcmp (p.camera, "back"))
      gl_axis_to_quat ((float[]){0,1,0}, 3.14159265358979, v->quat);
    else if (!strcmp (p.camera, "iso")) {
      gl_axis_to_quat ((float[]){0,1,0}, 3.14159265358979/4., v->quat);
      float q[4];
      gl_axis_to_quat ((float[]){1,0,0}, - 3.14159265358979/4., q);
      gl_add_quats(q, v->quat, v->quat);
    }
    else {
      fprintf (
# 134 "/Users/weugene/basilisk/src/draw.h" 3 4
              __stderrp
# 134 "/Users/weugene/basilisk/src/draw.h"
                       , "view(): unknown camera '%s'\n", p.camera);
      exit (1);
    }
  }
  else if (p.theta || p.phi || p.psi) {
    v->gfsview = 
# 139 "/Users/weugene/basilisk/src/draw.h" 3 4
                0
# 139 "/Users/weugene/basilisk/src/draw.h"
                     ;
    float q[4];
    gl_axis_to_quat ((float[]){1,0,0}, - p.phi, q);
    if (p.relative) {
      float q1[4];
      gl_axis_to_quat ((float[]){0,1,0}, p.theta, q1);
      gl_add_quats(q, q1, q1);
      float q2[4];
      gl_axis_to_quat ((float[]){0,0,1}, p.psi, q2);
      gl_add_quats(q1, q2, q2);
      gl_add_quats(q2, v->quat, v->quat);
    }
    else {
      gl_axis_to_quat ((float[]){0,1,0}, p.theta, v->quat);
      gl_add_quats(q, v->quat, v->quat);
      gl_axis_to_quat ((float[]){0,0,1}, p.psi, q);
      gl_add_quats(q, v->quat, v->quat);
    }
  }

  if (p.map)
    v->map = p.map;

  if (p.p1x || p.p1y || p.p2x || p.p2y) {
    float q[4];
    gl_trackball(q, p.p1x, p.p1y, p.p2x, p.p2y);
    gl_add_quats (q, v->quat, v->quat);
  }

  if (p.res)
    v->res = p.res;

  if ((p.width && p.width != v->width) ||
      (p.height && p.height != v->height) ||
      (p.samples && p.samples != v->samples)) {
    v->width = v->width/v->samples;
    v->height = v->height/v->samples;
    if (p.width) v->width = p.width;
    if (p.height) v->height = p.height;
    if (p.samples) v->samples = p.samples;
    v->width *= v->samples;
    v->height *= v->samples;
    framebuffer_destroy (v->fb);
    v->fb = framebuffer_new (v->width, v->height);
    init_gl();
  }

  clear();
}







struct _translate {
  float x, y, z;
};

void begin_translate (struct _translate p)
{
  bview * view = draw();
  glMatrixMode (
# 202 "/Users/weugene/basilisk/src/draw.h" 3
               0x1700
# 202 "/Users/weugene/basilisk/src/draw.h"
                           );
  glPushMatrix();
  glTranslatef (p.x, p.y, p.z);
  gl_get_frustum (&view->frustum);
}

void end_translate()
{
  bview * view = draw();
  glMatrixMode (
# 211 "/Users/weugene/basilisk/src/draw.h" 3
               0x1700
# 211 "/Users/weugene/basilisk/src/draw.h"
                           );
  glPopMatrix();
  gl_get_frustum (&view->frustum);
}
# 224 "/Users/weugene/basilisk/src/draw.h"
struct _mirror {
  coord n;
  double alpha;
};

void begin_mirror (struct _mirror p)
{
  bview * view = draw();
  glMatrixMode (
# 232 "/Users/weugene/basilisk/src/draw.h" 3
               0x1700
# 232 "/Users/weugene/basilisk/src/draw.h"
                           );
  glPushMatrix();
  normalize (&p.n);
  GLfloat s[16], t[16];
  s[0] = 1. - 2.*p.n.x*p.n.x;
  s[1] = - 2.*p.n.x*p.n.y; s[2] = - 2.*p.n.x*p.n.z;
  s[3] = 0.;
  s[4] = s[1];
  s[5] = 1. - 2.*p.n.y*p.n.y; s[6] = - 2.*p.n.y*p.n.z;
  s[7] = 0.;
  s[8] = s[2]; s[9] = s[6]; s[10] = 1. - 2.*p.n.z*p.n.z;
  s[11] = 0.;
  s[12] = 0.; s[13] = 0.; s[14] = 0.;
  s[15] = 1.;

  t[0] = 1.; t[1] = 0.; t[2] = 0.; t[3] = 0.;
  t[4] = 0.; t[5] = 1.; t[6] = 0.; t[7] = 0.;
  t[8] = 0.; t[9] = 0.; t[10] = 1.; t[11] = 0.;
  t[12] = - 2.*p.n.x*p.alpha;
  t[13] = - 2.*p.n.y*p.alpha;
  t[14] = - 2.*p.n.z*p.alpha;
  t[15] = 1.;
  matrix_multiply (s, t);
  glMultMatrixf (s);
  gl_get_frustum (&view->frustum);
  view->reversed = !view->reversed;
}

void end_mirror() {
  end_translate();
  bview * view = draw();
  view->reversed = !view->reversed;
}







static void mapped_position (bview * view, coord * p, double * r)
{
  double x = p->x, y = p->y, z = p->z, rm = 0.;
  view->map (p);
  for (int i = -1; i <= 1; i += 2)
    for (int j = -1; j <= 1; j += 2)
      for (int k = -1; k <= 1; k += 2) {
 coord q = {x + i**r, y + j**r, z + k**r};
 view->map (&q);
 double pq = ((p->x - q.x)*(p->x - q.x)) + ((p->y - q.y)*(p->y - q.y)) + ((p->z - q.z)*(p->z - q.z));
 if (pq > rm)
   rm = pq;
      }
  *r = sqrt (rm);
}
# 304 "/Users/weugene/basilisk/src/draw.h"
# 311 "/Users/weugene/basilisk/src/draw.h"
# 359 "/Users/weugene/basilisk/src/draw.h"
static 
# 359 "/Users/weugene/basilisk/src/draw.h" 3 4
      _Bool 
# 359 "/Users/weugene/basilisk/src/draw.h"
           _reversed = 
# 359 "/Users/weugene/basilisk/src/draw.h" 3 4
                       0
# 359 "/Users/weugene/basilisk/src/draw.h"
                            ;

static void begin_draw_lines (bview * view, float color[3], float lw)
{
  glMatrixMode (
# 363 "/Users/weugene/basilisk/src/draw.h" 3
               0x1701
# 363 "/Users/weugene/basilisk/src/draw.h"
                            );
  glPushMatrix();
  glTranslatef (0., 0., view->lc*view->fov/24.);
  glColor3f (color[0], color[1], color[2]);
  glLineWidth (view->samples*(lw > 0. ? lw : 1.));
  _reversed = view->reversed;
  view->reversed = 
# 369 "/Users/weugene/basilisk/src/draw.h" 3 4
                  0
# 369 "/Users/weugene/basilisk/src/draw.h"
                       ;
}

static void end_draw_lines()
{
  glMatrixMode (
# 374 "/Users/weugene/basilisk/src/draw.h" 3
               0x1701
# 374 "/Users/weugene/basilisk/src/draw.h"
                            );
  glPopMatrix();
  bview * view = draw();
  view->reversed = _reversed;
}

static inline double interp (Point point, coord p, scalar col) { int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 380 "/Users/weugene/basilisk/src/draw.h"

  struct _interpolate _r = { col, x + p.x*Delta, y + p.y*Delta, z + p.z*Delta };
  return interpolate_linear (point, _r);
}
# 440 "/Users/weugene/basilisk/src/draw.h"
static void begin_colorized (float fc[3],
        double cmap[127][3], 
# 441 "/Users/weugene/basilisk/src/draw.h" 3 4
                            _Bool 
# 441 "/Users/weugene/basilisk/src/draw.h"
                                 use_texture)
{

  if (use_texture) {
    GLfloat texture[3*256];
    for (int i = 0; i < 256; i++) {
      color c = colormap_color (cmap, i/255., 0, 1);
      texture[3*i] = c.r/255.;
      texture[3*i + 1] = c.g/255.;
      texture[3*i + 2] = c.b/255.;
    }
    glTexImage1D (
# 452 "/Users/weugene/basilisk/src/draw.h" 3
                 0x0DE0
# 452 "/Users/weugene/basilisk/src/draw.h"
                              , 0, 
# 452 "/Users/weugene/basilisk/src/draw.h" 3
                                   0x1907
# 452 "/Users/weugene/basilisk/src/draw.h"
                                         , 256,0, 
# 452 "/Users/weugene/basilisk/src/draw.h" 3
                                                  0x1907
# 452 "/Users/weugene/basilisk/src/draw.h"
                                                        , 
# 452 "/Users/weugene/basilisk/src/draw.h" 3
                                                          0x1406
# 452 "/Users/weugene/basilisk/src/draw.h"
                                                                  , texture);
    glTexParameteri (
# 453 "/Users/weugene/basilisk/src/draw.h" 3
                    0x0DE0
# 453 "/Users/weugene/basilisk/src/draw.h"
                                 , 
# 453 "/Users/weugene/basilisk/src/draw.h" 3
                                   0x2801
# 453 "/Users/weugene/basilisk/src/draw.h"
                                                        , 
# 453 "/Users/weugene/basilisk/src/draw.h" 3
                                                          0x2601
# 453 "/Users/weugene/basilisk/src/draw.h"
                                                                   );
    glTexParameteri (
# 454 "/Users/weugene/basilisk/src/draw.h" 3
                    0x0DE0
# 454 "/Users/weugene/basilisk/src/draw.h"
                                 , 
# 454 "/Users/weugene/basilisk/src/draw.h" 3
                                   0x2800
# 454 "/Users/weugene/basilisk/src/draw.h"
                                                        , 
# 454 "/Users/weugene/basilisk/src/draw.h" 3
                                                          0x2601
# 454 "/Users/weugene/basilisk/src/draw.h"
                                                                   );
    glTexParameteri (
# 455 "/Users/weugene/basilisk/src/draw.h" 3
                    0x0DE0
# 455 "/Users/weugene/basilisk/src/draw.h"
                                 , 
# 455 "/Users/weugene/basilisk/src/draw.h" 3
                                   0x2802
# 455 "/Users/weugene/basilisk/src/draw.h"
                                                    , 
# 455 "/Users/weugene/basilisk/src/draw.h" 3
                                                      0x812F
# 455 "/Users/weugene/basilisk/src/draw.h"
                                                                      );
    glTexParameteri (
# 456 "/Users/weugene/basilisk/src/draw.h" 3
                    0x0DE0
# 456 "/Users/weugene/basilisk/src/draw.h"
                                 , 
# 456 "/Users/weugene/basilisk/src/draw.h" 3
                                   0x2803
# 456 "/Users/weugene/basilisk/src/draw.h"
                                                    , 
# 456 "/Users/weugene/basilisk/src/draw.h" 3
                                                      0x812F
# 456 "/Users/weugene/basilisk/src/draw.h"
                                                                      );
    glEnable (
# 457 "/Users/weugene/basilisk/src/draw.h" 3
             0x0DE0
# 457 "/Users/weugene/basilisk/src/draw.h"
                          );
  }
  glColor3f (fc[0], fc[1], fc[2]);
}

static void end_colorized() {
  glDisable (
# 463 "/Users/weugene/basilisk/src/draw.h" 3
            0x0DE0
# 463 "/Users/weugene/basilisk/src/draw.h"
                         );
}
# 495 "/Users/weugene/basilisk/src/draw.h"
struct _draw_vof {
  char * c;
  char * s;
  
# 498 "/Users/weugene/basilisk/src/draw.h" 3 4
 _Bool 
# 498 "/Users/weugene/basilisk/src/draw.h"
      edges;
  double larger;
  int filled;

  char * color;
  double min, max, spread;
  
# 504 "/Users/weugene/basilisk/src/draw.h" 3 4
 _Bool 
# 504 "/Users/weugene/basilisk/src/draw.h"
      linear;
  colormap map;
  float fc[3], lc[3], lw;
};







static 
# 515 "/Users/weugene/basilisk/src/draw.h" 3 4
      _Bool 
# 515 "/Users/weugene/basilisk/src/draw.h"
           cfilter (Point point, scalar c, double cmin)
{ int ig = 0; (void)(ig); int jg = 0; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 516 "/Users/weugene/basilisk/src/draw.h"

  double cmin1 = 4.*cmin;
  if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] <= cmin) {
    {
# 519 "/Users/weugene/basilisk/src/draw.h"

      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[c.i] >= 1. - cmin1 || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[c.i] >= 1. - cmin1)
 return 
# 521 "/Users/weugene/basilisk/src/draw.h" 3 4
       1
# 521 "/Users/weugene/basilisk/src/draw.h"
           ;
# 519 "/Users/weugene/basilisk/src/draw.h"

      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[c.i] >= 1. - cmin1 || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[c.i] >= 1. - cmin1)
 return 
# 521 "/Users/weugene/basilisk/src/draw.h" 3 4
       1
# 521 "/Users/weugene/basilisk/src/draw.h"
           ;}
    return 
# 522 "/Users/weugene/basilisk/src/draw.h" 3 4
          0
# 522 "/Users/weugene/basilisk/src/draw.h"
               ;
  }
  if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] >= 1. - cmin) {
    {
# 525 "/Users/weugene/basilisk/src/draw.h"

      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[c.i] <= cmin1 || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[c.i] <= cmin1)
 return 
# 527 "/Users/weugene/basilisk/src/draw.h" 3 4
       1
# 527 "/Users/weugene/basilisk/src/draw.h"
           ;
# 525 "/Users/weugene/basilisk/src/draw.h"

      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[c.i] <= cmin1 || ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[c.i] <= cmin1)
 return 
# 527 "/Users/weugene/basilisk/src/draw.h" 3 4
       1
# 527 "/Users/weugene/basilisk/src/draw.h"
           ;}
    return 
# 528 "/Users/weugene/basilisk/src/draw.h" 3 4
          0
# 528 "/Users/weugene/basilisk/src/draw.h"
               ;
  }
  int n = 0;
  double min = ((double)1e30), max = - ((double)1e30);
   { { int _nn = 1 + 0 ? 1 + 0 : 2; int _i = point.i, _j = point.j; for (int _k = - _nn; _k <= _nn; _k++) { point.i = _i + _k; for (int _l = - _nn; _l <= _nn; _l++) { point.j = _j + _l; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; {
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] > cmin && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] < 1. - cmin && ++n >= (1 << 2))
      return 
# 534 "/Users/weugene/basilisk/src/draw.h" 3 4
            1
# 534 "/Users/weugene/basilisk/src/draw.h"
                ;
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] > max) max = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i];
    if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] < min) min = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i];
  } } } point.i = _i; point.j = _j;}; }
  return max - min > 0.5;
}


static void glvertex2d (bview * view, double x, double y) {
  if (view->map) {
    coord p = {x, y, 0.};
    view->map (&p);
    glVertex2d (p.x, p.y);
  }
  else
    glVertex2d (x, y);
}
# 563 "/Users/weugene/basilisk/src/draw.h"


# 564 "/Users/weugene/basilisk/src/draw.h" 3 4
_Bool 
# 564 "/Users/weugene/basilisk/src/draw.h"
    draw_vof (struct _draw_vof p)
{ ;
  scalar c = lookup_field (p.c);
  if (c.i < 0) {
    fprintf (
# 568 "/Users/weugene/basilisk/src/draw.h" 3 4
            __stderrp
# 568 "/Users/weugene/basilisk/src/draw.h"
                     , "draw_vof(): no field named '%s'\n", p.c);
    { 
# 569 "/Users/weugene/basilisk/src/draw.h" 3 4
     _Bool 
# 569 "/Users/weugene/basilisk/src/draw.h"
          _ret = 
# 569 "/Users/weugene/basilisk/src/draw.h" 3 4
                  0
# 569 "/Users/weugene/basilisk/src/draw.h"
                       ; ; return _ret; }
  }
  vector s = lookup_vector (p.s);

  scalar col = {-1}; if (p.color && strcmp (p.color, "level")) { col = lookup_field (p.color); if (col.i < 0) { fprintf (
# 573 "/Users/weugene/basilisk/src/draw.h" 3 4
                                                                                                                        __stderrp
# 573 "/Users/weugene/basilisk/src/draw.h"
                                                                                                                                 , "colorize_args(): no field named '%s'\n", p.color); { 
# 573 "/Users/weugene/basilisk/src/draw.h" 3 4
                                                                                                                                                                                         _Bool 
# 573 "/Users/weugene/basilisk/src/draw.h"
                                                                                                                                                                                              _ret = 
# 573 "/Users/weugene/basilisk/src/draw.h" 3 4
                                                                                                                                                                                                      0
# 573 "/Users/weugene/basilisk/src/draw.h"
                                                                                                                                                                                                           ; ; return _ret; } } } double cmap[127][3]; if (p.color) { if (p.min == 0 && p.max == 0) { if (col.i < 0) p.min = 0, p.max = (grid->depth); else { stats s = statsf (col); double avg = s.sum/s.volume; if (p.spread < 0.) p.min = s.min, p.max = s.max; else { double spread = (p.spread ? p.spread : 5.)*s.stddev; p.min = avg - spread; p.max = avg + spread; } } } if (!p.map) p.map = jet; p.map (cmap); } if ((2 > 2 || p.linear) && !p.fc[0] && !p.fc[1] && !p.fc[2]) p.fc[0] = p.fc[1] = p.fc[2] = 1.;;

  double cmin = 1e-3;



  void (* prolongation) (Point, scalar) = _attribute[c.i].prolongation;
  if (prolongation != fraction_refine) {
    _attribute[c.i].prolongation = fraction_refine;
    boundary (((scalar []){c,{-1}}));
  }


  bview * view = draw();

  if (p.filled) {
    glColor3f (p.fc[0], p.fc[1], p.fc[2]);
    glNormal3d (0, 0, view->reversed ? -1 : 1);
     { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { double _r = Delta*0.71; coord _p = {x, y, z}; if ((view)->map) mapped_position (view, &_p, &_r); if (!sphere_in_frustum (_p.x, _p.y, _p.z, _r, &(view)->frustum)) continue; if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf) || sphere_diameter (_p.x, _p.y, _p.z, _r/L0, &(view)->frustum) < (view)->res) { if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & active) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0)) {{
# 591 "/Users/weugene/basilisk/src/draw.h"
 {
      if ((p.filled > 0 && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] >= 1.) || (p.filled < 0 && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] <= 0.)) {
 glBegin (
# 593 "/Users/weugene/basilisk/src/draw.h" 3
         0x0007
# 593 "/Users/weugene/basilisk/src/draw.h"
                 );
 glvertex2d (view, x - Delta/2., y - Delta/2.);
 glvertex2d (view, x + Delta/2., y - Delta/2.);
 glvertex2d (view, x + Delta/2., y + Delta/2.);
 glvertex2d (view, x - Delta/2., y + Delta/2.);
 glEnd();
 view->ni++;
      }
      else if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] > 0. && ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] < 1.) {
 coord n = facet_normal (point, c, s), s = {1.,1.};
 if (p.filled < 0)
   {
# 604 "/Users/weugene/basilisk/src/draw.h"

     n.x = - n.x;
# 604 "/Users/weugene/basilisk/src/draw.h"

     n.y = - n.y;}
 double alpha = line_alpha (p.filled < 0. ? 1. - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i] : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i], n);
 alpha += (n.x + n.y)/2.;
 {
# 608 "/Users/weugene/basilisk/src/draw.h"

   if (n.x < 0.) alpha -= n.x, n.x = - n.x, s.x = - 1.;
# 608 "/Users/weugene/basilisk/src/draw.h"

   if (n.y < 0.) alpha -= n.y, n.y = - n.y, s.y = - 1.;}
 coord v[5];
 int nv = 0;
 if (alpha >= 0. && alpha <= n.x) {
   v[nv].x = alpha/n.x, v[nv++].y = 0.;
   if (alpha <= n.y)
     v[nv].x = 0., v[nv++].y = alpha/n.y;
   else if (alpha >= n.y && alpha - n.y <= n.x) {
     v[nv].x = (alpha - n.y)/n.x, v[nv++].y = 1.;
     v[nv].x = 0., v[nv++].y = 1.;
   }
   v[nv].x = 0., v[nv++].y = 0.;
 }
 else if (alpha >= n.x && alpha - n.x <= n.y) {
   v[nv].x = 1., v[nv++].y = (alpha - n.x)/n.y;
   if (alpha >= n.y && alpha - n.y <= n.x) {
     v[nv].x = (alpha - n.y)/n.x, v[nv++].y = 1.;
     v[nv].x = 0., v[nv++].y = 1.;
   }
   else if (alpha <= n.y)
     v[nv].x = 0., v[nv++].y = alpha/n.y;
   v[nv].x = 0., v[nv++].y = 0.;
   v[nv].x = 1., v[nv++].y = 0.;
 }
 glBegin (
# 633 "/Users/weugene/basilisk/src/draw.h" 3
         0x0009
# 633 "/Users/weugene/basilisk/src/draw.h"
                   );
 if (s.x*s.y < 0.)
   for (int i = nv - 1; i >= 0; i--)
     glvertex2d (view, x + s.x*(v[i].x - 0.5)*Delta,
   y + s.y*(v[i].y - 0.5)*Delta);
 else
   for (int i = 0; i < nv; i++)
     glvertex2d (view, x + s.x*(v[i].x - 0.5)*Delta,
   y + s.y*(v[i].y - 0.5)*Delta);
 glEnd ();
 view->ni++;
      }
    } } } continue; }}if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };; }
  }
  if (!p.filled || p.edges)
    { begin_draw_lines (view, p.lc, p.lw); {
      glBegin (
# 649 "/Users/weugene/basilisk/src/draw.h" 3
              0x0001
# 649 "/Users/weugene/basilisk/src/draw.h"
                      );
       { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { double _r = Delta*0.71; coord _p = {x, y, z}; if ((view)->map) mapped_position (view, &_p, &_r); if (!sphere_in_frustum (_p.x, _p.y, _p.z, _r, &(view)->frustum)) continue; if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf) || sphere_diameter (_p.x, _p.y, _p.z, _r/L0, &(view)->frustum) < (view)->res) { if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & active) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0)) {{
# 650 "/Users/weugene/basilisk/src/draw.h"

 if (cfilter (point, c, cmin)) {
   coord n = facet_normal (point, c, s);
   double alpha = line_alpha (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[c.i], n);
   coord segment[2];
   if (facets (n, alpha, segment) == 2) {
     glvertex2d (view, x + segment[0].x*Delta, y + segment[0].y*Delta);
     glvertex2d (view, x + segment[1].x*Delta, y + segment[1].y*Delta);
     view->ni++;
   }
 } } } continue; }}if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };; }
      glEnd ();
    } end_draw_lines(); }
# 709 "/Users/weugene/basilisk/src/draw.h"
  if (prolongation != fraction_refine) {
    _attribute[c.i].prolongation = prolongation;
    boundary (((scalar []){c,{-1}}));
  }


  { 
# 715 "/Users/weugene/basilisk/src/draw.h" 3 4
   _Bool 
# 715 "/Users/weugene/basilisk/src/draw.h"
        _ret = 
# 715 "/Users/weugene/basilisk/src/draw.h" 3 4
                1
# 715 "/Users/weugene/basilisk/src/draw.h"
                    ; ; return _ret; }
 ; }
# 727 "/Users/weugene/basilisk/src/draw.h"
struct _isoline {
  char * phi;
  double val;
  int n;


  char * c;
  char * s;
  
# 735 "/Users/weugene/basilisk/src/draw.h" 3 4
 _Bool 
# 735 "/Users/weugene/basilisk/src/draw.h"
      edges;
  double larger;
  int filled;

  char * color;
  double min, max, spread;
  
# 741 "/Users/weugene/basilisk/src/draw.h" 3 4
 _Bool 
# 741 "/Users/weugene/basilisk/src/draw.h"
      linear;
  colormap map;
  float fc[3], lc[3], lw;
};



# 747 "/Users/weugene/basilisk/src/draw.h" 3 4
_Bool 
# 747 "/Users/weugene/basilisk/src/draw.h"
    isoline (struct _isoline p)
{ ;

  if (!p.color) p.color = p.phi;
  scalar col = {-1}; if (p.color && strcmp (p.color, "level")) { col = lookup_field (p.color); if (col.i < 0) { fprintf (
# 751 "/Users/weugene/basilisk/src/draw.h" 3 4
                                                                                                                        __stderrp
# 751 "/Users/weugene/basilisk/src/draw.h"
                                                                                                                                 , "colorize_args(): no field named '%s'\n", p.color); { 
# 751 "/Users/weugene/basilisk/src/draw.h" 3 4
                                                                                                                                                                                         _Bool 
# 751 "/Users/weugene/basilisk/src/draw.h"
                                                                                                                                                                                              _ret = 
# 751 "/Users/weugene/basilisk/src/draw.h" 3 4
                                                                                                                                                                                                      0
# 751 "/Users/weugene/basilisk/src/draw.h"
                                                                                                                                                                                                           ; ; return _ret; } } } double cmap[127][3]; if (p.color) { if (p.min == 0 && p.max == 0) { if (col.i < 0) p.min = 0, p.max = (grid->depth); else { stats s = statsf (col); double avg = s.sum/s.volume; if (p.spread < 0.) p.min = s.min, p.max = s.max; else { double spread = (p.spread ? p.spread : 5.)*s.stddev; p.min = avg - spread; p.max = avg + spread; } } } if (!p.map) p.map = jet; p.map (cmap); } if ((2 > 2 || p.linear) && !p.fc[0] && !p.fc[1] && !p.fc[2]) p.fc[0] = p.fc[1] = p.fc[2] = 1.;;
  scalar phi = col, fiso= new_scalar("fiso");
  vector siso= new_face_vector("siso");
  p.c = "fiso", p.s = "siso";
  struct _draw_vof a = *((struct _draw_vof *)&p.c);
  if (p.n < 2) {
    fractions ((struct Fractions){phi, fiso, siso, p.val});
    draw_vof (a);
  }
  else if (p.max > p.min) {
    double dv = (p.max - p.min)/(p.n - 1);
    for (p.val = p.min; p.val <= p.max; p.val += dv) {
      fractions ((struct Fractions){phi, fiso, siso, p.val});
      draw_vof (a);
    }
  }



  { 
# 770 "/Users/weugene/basilisk/src/draw.h" 3 4
   _Bool 
# 770 "/Users/weugene/basilisk/src/draw.h"
        _ret = 
# 770 "/Users/weugene/basilisk/src/draw.h" 3 4
                1
# 770 "/Users/weugene/basilisk/src/draw.h"
                    ; delete (((scalar []){siso.x,siso.y,fiso,{-1}})); ; return _ret; }
 delete (((scalar []){siso.x,siso.y,fiso,{-1}})); ; }
# 784 "/Users/weugene/basilisk/src/draw.h"
struct _cells {
  coord n;
  double alpha;
  float lc[3], lw;
};


void cells (struct _cells p)
{ ;
  bview * view = draw();
  { begin_draw_lines (view, p.lc, p.lw); {

     { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { double _r = Delta*0.71; coord _p = {x, y, z}; if ((view)->map) mapped_position (view, &_p, &_r); if (!sphere_in_frustum (_p.x, _p.y, _p.z, _r, &(view)->frustum)) continue; if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf) || sphere_diameter (_p.x, _p.y, _p.z, _r/L0, &(view)->frustum) < (view)->res) { if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & active) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0)) {{
# 796 "/Users/weugene/basilisk/src/draw.h"
 {
      glBegin (
# 797 "/Users/weugene/basilisk/src/draw.h" 3
              0x0002
# 797 "/Users/weugene/basilisk/src/draw.h"
                          );
      glvertex2d (view, x - Delta/2., y - Delta/2.);
      glvertex2d (view, x + Delta/2., y - Delta/2.);
      glvertex2d (view, x + Delta/2., y + Delta/2.);
      glvertex2d (view, x - Delta/2., y + Delta/2.);
      glEnd();
      view->ni++;
    } } } continue; }}if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };; }
# 818 "/Users/weugene/basilisk/src/draw.h"
  } end_draw_lines(); }
 ; }






struct _vectors {
  char * u;
  double scale;
  float lc[3], lw;
};


void vectors (struct _vectors p)
{ ;

  vector u;
  struct { char x, y, z; } index = {'x', 'y', 'z'};
  {
# 838 "/Users/weugene/basilisk/src/draw.h"
 {
    char name[80];
    
# 840 "/Users/weugene/basilisk/src/draw.h" 3 4
   __builtin___sprintf_chk (
# 840 "/Users/weugene/basilisk/src/draw.h"
   name
# 840 "/Users/weugene/basilisk/src/draw.h" 3 4
   , 0, __builtin_object_size (
# 840 "/Users/weugene/basilisk/src/draw.h"
   name
# 840 "/Users/weugene/basilisk/src/draw.h" 3 4
   , 2 > 1 ? 1 : 0), 
# 840 "/Users/weugene/basilisk/src/draw.h"
   "%s.%c", p.u, index.x
# 840 "/Users/weugene/basilisk/src/draw.h" 3 4
   )
# 840 "/Users/weugene/basilisk/src/draw.h"
                                        ;
    u.x = lookup_field (name);
  }
# 838 "/Users/weugene/basilisk/src/draw.h"
 {
    char name[80];
    
# 840 "/Users/weugene/basilisk/src/draw.h" 3 4
   __builtin___sprintf_chk (
# 840 "/Users/weugene/basilisk/src/draw.h"
   name
# 840 "/Users/weugene/basilisk/src/draw.h" 3 4
   , 0, __builtin_object_size (
# 840 "/Users/weugene/basilisk/src/draw.h"
   name
# 840 "/Users/weugene/basilisk/src/draw.h" 3 4
   , 2 > 1 ? 1 : 0), 
# 840 "/Users/weugene/basilisk/src/draw.h"
   "%s.%c", p.u, index.y
# 840 "/Users/weugene/basilisk/src/draw.h" 3 4
   )
# 840 "/Users/weugene/basilisk/src/draw.h"
                                        ;
    u.y = lookup_field (name);
  }}
  bview * view = draw();
  { begin_draw_lines (view, p.lc, p.lw); {
    double scale = p.scale ? p.scale : 1.;
    glBegin (
# 846 "/Users/weugene/basilisk/src/draw.h" 3
            0x0001
# 846 "/Users/weugene/basilisk/src/draw.h"
                    );
     { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { double _r = Delta*0.71; coord _p = {x, y, z}; if ((view)->map) mapped_position (view, &_p, &_r); if (!sphere_in_frustum (_p.x, _p.y, _p.z, _r, &(view)->frustum)) continue; if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf) || sphere_diameter (_p.x, _p.y, _p.z, _r/L0, &(view)->frustum) < (view)->res) { if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & active) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0)) {{
# 847 "/Users/weugene/basilisk/src/draw.h"

      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i] != ((double)1e30)) {
 glvertex2d (view, x, y);
 glvertex2d (view, x + scale*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.x.i], y + scale*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[u.y.i]);
 view->ni++;
      } } } continue; }}if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };; }
    glEnd();
  } end_draw_lines(); }



 ; }
# 875 "/Users/weugene/basilisk/src/draw.h"
struct _squares {
  char * color;
  double min, max, spread;
  
# 878 "/Users/weugene/basilisk/src/draw.h" 3 4
 _Bool 
# 878 "/Users/weugene/basilisk/src/draw.h"
      linear;
  colormap map;
  float fc[3], lc[3];

  coord n;
  double alpha;
};



# 887 "/Users/weugene/basilisk/src/draw.h" 3 4
_Bool 
# 887 "/Users/weugene/basilisk/src/draw.h"
    squares (struct _squares p)
{ ;
  scalar col = {-1}; if (p.color && strcmp (p.color, "level")) { col = lookup_field (p.color); if (col.i < 0) { fprintf (
# 889 "/Users/weugene/basilisk/src/draw.h" 3 4
                                                                                                                        __stderrp
# 889 "/Users/weugene/basilisk/src/draw.h"
                                                                                                                                 , "colorize_args(): no field named '%s'\n", p.color); { 
# 889 "/Users/weugene/basilisk/src/draw.h" 3 4
                                                                                                                                                                                         _Bool 
# 889 "/Users/weugene/basilisk/src/draw.h"
                                                                                                                                                                                              _ret = 
# 889 "/Users/weugene/basilisk/src/draw.h" 3 4
                                                                                                                                                                                                      0
# 889 "/Users/weugene/basilisk/src/draw.h"
                                                                                                                                                                                                           ; ; return _ret; } } } double cmap[127][3]; if (p.color) { if (p.min == 0 && p.max == 0) { if (col.i < 0) p.min = 0, p.max = (grid->depth); else { stats s = statsf (col); double avg = s.sum/s.volume; if (p.spread < 0.) p.min = s.min, p.max = s.max; else { double spread = (p.spread ? p.spread : 5.)*s.stddev; p.min = avg - spread; p.max = avg + spread; } } } if (!p.map) p.map = jet; p.map (cmap); } if ((2 > 2 || p.linear) && !p.fc[0] && !p.fc[1] && !p.fc[2]) p.fc[0] = p.fc[1] = p.fc[2] = 1.;;
  scalar f = col;

  bview * view = draw();
  glShadeModel (
# 893 "/Users/weugene/basilisk/src/draw.h" 3
               0x1D01
# 893 "/Users/weugene/basilisk/src/draw.h"
                        );
  if (p.linear) {
    { begin_colorized (p.fc, cmap, !view->vector && p.color && p.linear && col.i >= 0); {

      glNormal3d (0, 0, view->reversed ? -1 : 1);
       { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { double _r = Delta*0.71; coord _p = {x, y, z}; if ((view)->map) mapped_position (view, &_p, &_r); if (!sphere_in_frustum (_p.x, _p.y, _p.z, _r, &(view)->frustum)) continue; if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf) || sphere_diameter (_p.x, _p.y, _p.z, _r/L0, &(view)->frustum) < (view)->res) { if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & active) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0)) {{
# 898 "/Users/weugene/basilisk/src/draw.h"

        if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] != ((double)1e30)) {
   glBegin (
# 900 "/Users/weugene/basilisk/src/draw.h" 3
           0x0006
# 900 "/Users/weugene/basilisk/src/draw.h"
                          );
   if (p.color && p.linear && col.i >= 0) { if (view->vector) { color b = colormap_color (cmap, (4.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] + 2.*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[f.i]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[f.i])/16., p.min, p.max); glColor3f (b.r/255., b.g/255., b.b/255.); } else { double _v = (4.*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] + 2.*(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[f.i]) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[f.i])/16.; glTexCoord1d (((((_v) - p.min)/(p.max - p.min)) < (0.) ? (0.) : (((_v) - p.min)/(p.max - p.min)) > (1.) ? (1.) : (((_v) - p.min)/(p.max - p.min)))); } }

                                                  ;
   glvertex2d (view, x, y);
   if (p.color && p.linear && col.i >= 0) { if (view->vector) { color b = colormap_color (cmap, (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[f.i])/4., p.min, p.max); glColor3f (b.r/255., b.g/255., b.b/255.); } else { double _v = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[f.i])/4.; glTexCoord1d (((((_v) - p.min)/(p.max - p.min)) < (0.) ? (0.) : (((_v) - p.min)/(p.max - p.min)) > (1.) ? (1.) : (((_v) - p.min)/(p.max - p.min)))); } };
   glvertex2d (view, x - Delta/2., y - Delta/2.);
   if (p.color && p.linear && col.i >= 0) { if (view->vector) { color b = colormap_color (cmap, (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[f.i])/4., p.min, p.max); glColor3f (b.r/255., b.g/255., b.b/255.); } else { double _v = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+-1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[f.i])/4.; glTexCoord1d (((((_v) - p.min)/(p.max - p.min)) < (0.) ? (0.) : (((_v) - p.min)/(p.max - p.min)) > (1.) ? (1.) : (((_v) - p.min)/(p.max - p.min)))); } };
   glvertex2d (view, x + Delta/2., y - Delta/2.);
   if (p.color && p.linear && col.i >= 0) { if (view->vector) { color b = colormap_color (cmap, (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[f.i])/4., p.min, p.max); glColor3f (b.r/255., b.g/255., b.b/255.); } else { double _v = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[f.i])/4.; glTexCoord1d (((((_v) - p.min)/(p.max - p.min)) < (0.) ? (0.) : (((_v) - p.min)/(p.max - p.min)) > (1.) ? (1.) : (((_v) - p.min)/(p.max - p.min)))); } };
   glvertex2d (view, x + Delta/2., y + Delta/2.);
   if (p.color && p.linear && col.i >= 0) { if (view->vector) { color b = colormap_color (cmap, (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[f.i])/4., p.min, p.max); glColor3f (b.r/255., b.g/255., b.b/255.); } else { double _v = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[f.i])/4.; glTexCoord1d (((((_v) - p.min)/(p.max - p.min)) < (0.) ? (0.) : (((_v) - p.min)/(p.max - p.min)) > (1.) ? (1.) : (((_v) - p.min)/(p.max - p.min)))); } };
   glvertex2d (view, x - Delta/2., y + Delta/2.);
   if (p.color && p.linear && col.i >= 0) { if (view->vector) { color b = colormap_color (cmap, (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[f.i])/4., p.min, p.max); glColor3f (b.r/255., b.g/255., b.b/255.); } else { double _v = (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+0]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+-1][point.j+-1]) + sizeof(Cell)))[f.i] + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+-1]) + sizeof(Cell)))[f.i])/4.; glTexCoord1d (((((_v) - p.min)/(p.max - p.min)) < (0.) ? (0.) : (((_v) - p.min)/(p.max - p.min)) > (1.) ? (1.) : (((_v) - p.min)/(p.max - p.min)))); } };
   glvertex2d (view, x - Delta/2., y - Delta/2.);
   glEnd();
   view->ni++;
 } } } continue; }}if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };; }
# 944 "/Users/weugene/basilisk/src/draw.h"
    } end_colorized(); }
  }
  else {

    glNormal3d (0, 0, view->reversed ? -1 : 1);
    glBegin (
# 949 "/Users/weugene/basilisk/src/draw.h" 3
            0x0007
# 949 "/Users/weugene/basilisk/src/draw.h"
                    );
     { { Point root = {2,2,0}; { int ig = 0, jg = 0; (void)(ig); (void)(jg); Point point; struct { int l, i, j, stage; } stack[20]; int _s = -1; { _s++; stack[_s].l = 0; stack[_s].i = root.i; stack[_s].j = root.j; stack[_s].stage = 0; }; while (_s >= 0) { int stage; { point.level = stack[_s].l; point.i = stack[_s].i; point.j = stack[_s].j; stage = stack[_s].stage; _s--; }; if (!(point.i+0 >= 0 && point.i+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0] && point.j+0 >= 0 && point.j+0 < (1 << point.level) + 2*2 && ((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0])) continue; switch (stage) { case 0: { double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { double _r = Delta*0.71; coord _p = {x, y, z}; if ((view)->map) mapped_position (view, &_p, &_r); if (!sphere_in_frustum (_p.x, _p.y, _p.z, _r, &(view)->frustum)) continue; if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & leaf) || sphere_diameter (_p.x, _p.y, _p.z, _r/L0, &(view)->frustum) < (view)->res) { if ((((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).flags & active) && (((*((Cell *)((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]))))).pid == 0)) {{
# 950 "/Users/weugene/basilisk/src/draw.h"

      if (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[f.i] != ((double)1e30)) {
 if (p.color && (!p.linear || col.i < 0)) { color b = colormap_color (cmap, col.i < 0 ? (double) level : ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[col.i], p.min, p.max); glColor3f (b.r/255., b.g/255., b.b/255.); };
 glvertex2d (view, x - Delta/2., y - Delta/2.);
 glvertex2d (view, x + Delta/2., y - Delta/2.);
 glvertex2d (view, x + Delta/2., y + Delta/2.);
 glvertex2d (view, x - Delta/2., y + Delta/2.);
 view->ni++;
      } } } continue; }}if (point.level < grid->depth) { { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 1; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; } break; } case 1: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 2; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = (2*point.i - 2); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; case 2: { _s++; stack[_s].l = point.level; stack[_s].i = point.i; stack[_s].j = point.j; stack[_s].stage = 3; }; { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = (2*point.j - 2); stack[_s].stage = 0; }; break; case 3: { _s++; stack[_s].l = point.level + 1; stack[_s].i = ((2*point.i - 2) + 1); stack[_s].j = ((2*point.j - 2) + 1); stack[_s].stage = 0; }; break; } } } };; }
    glEnd();
# 976 "/Users/weugene/basilisk/src/draw.h"
  }
  { 
# 977 "/Users/weugene/basilisk/src/draw.h" 3 4
   _Bool 
# 977 "/Users/weugene/basilisk/src/draw.h"
        _ret = 
# 977 "/Users/weugene/basilisk/src/draw.h" 3 4
                1
# 977 "/Users/weugene/basilisk/src/draw.h"
                    ; ; return _ret; }
 ; }
# 989 "/Users/weugene/basilisk/src/draw.h"
struct _box {
  
# 990 "/Users/weugene/basilisk/src/draw.h" 3 4
 _Bool 
# 990 "/Users/weugene/basilisk/src/draw.h"
      notics;
  float lc[3], lw;
};



# 995 "/Users/weugene/basilisk/src/draw.h" 3 4
_Bool 
# 995 "/Users/weugene/basilisk/src/draw.h"
    box (struct _box p)
{ ;
  bview * view = draw();
  { begin_draw_lines (view, p.lc, p.lw); {

    float height = 0.5*gl_StrokeHeight();
    float width = gl_StrokeWidth ('1'), scale = L0/(60.*width), length;
    float Z1 = 2 == 2 ? 0. : Z0;
    char label[80];

    glMatrixMode (
# 1005 "/Users/weugene/basilisk/src/draw.h" 3
                 0x1700
# 1005 "/Users/weugene/basilisk/src/draw.h"
                             );

    if (!p.notics) {
      int nt = 8;
      for (int i = 0; i <= nt; i++) {
 glPushMatrix();
 glTranslatef (X0 + i*L0/nt - height/2.*scale, Y0 - width/3.*scale, Z1);
 glRotatef (-90, 0, 0, 1);
 glScalef (scale, scale, scale);
 
# 1014 "/Users/weugene/basilisk/src/draw.h" 3 4
__builtin___sprintf_chk (
# 1014 "/Users/weugene/basilisk/src/draw.h"
label
# 1014 "/Users/weugene/basilisk/src/draw.h" 3 4
, 0, __builtin_object_size (
# 1014 "/Users/weugene/basilisk/src/draw.h"
label
# 1014 "/Users/weugene/basilisk/src/draw.h" 3 4
, 2 > 1 ? 1 : 0), 
# 1014 "/Users/weugene/basilisk/src/draw.h"
"%g", X0 + i*L0/nt
# 1014 "/Users/weugene/basilisk/src/draw.h" 3 4
)
# 1014 "/Users/weugene/basilisk/src/draw.h"
                                   ;
 gl_StrokeString (label);
 glPopMatrix();

 glPushMatrix();
 
# 1019 "/Users/weugene/basilisk/src/draw.h" 3 4
__builtin___sprintf_chk (
# 1019 "/Users/weugene/basilisk/src/draw.h"
label
# 1019 "/Users/weugene/basilisk/src/draw.h" 3 4
, 0, __builtin_object_size (
# 1019 "/Users/weugene/basilisk/src/draw.h"
label
# 1019 "/Users/weugene/basilisk/src/draw.h" 3 4
, 2 > 1 ? 1 : 0), 
# 1019 "/Users/weugene/basilisk/src/draw.h"
"%g", Y0 + i*L0/nt
# 1019 "/Users/weugene/basilisk/src/draw.h" 3 4
)
# 1019 "/Users/weugene/basilisk/src/draw.h"
                                   ;
 length = gl_StrokeLength (label);
 glTranslatef (X0 - (length + width/3.)*scale,
        Y0 + i*L0/nt - height/2.*scale, Z1);
 glScalef (scale, scale, scale);
 gl_StrokeString (label);
 glPopMatrix();
# 1038 "/Users/weugene/basilisk/src/draw.h"
      }

      glPushMatrix();
      
# 1041 "/Users/weugene/basilisk/src/draw.h" 3 4
     __builtin___sprintf_chk (
# 1041 "/Users/weugene/basilisk/src/draw.h"
     label
# 1041 "/Users/weugene/basilisk/src/draw.h" 3 4
     , 0, __builtin_object_size (
# 1041 "/Users/weugene/basilisk/src/draw.h"
     label
# 1041 "/Users/weugene/basilisk/src/draw.h" 3 4
     , 2 > 1 ? 1 : 0), 
# 1041 "/Users/weugene/basilisk/src/draw.h"
     "%g", X0 + L0/2.
# 1041 "/Users/weugene/basilisk/src/draw.h" 3 4
     )
# 1041 "/Users/weugene/basilisk/src/draw.h"
                                      ;
      length = gl_StrokeLength (label);
      glTranslatef (X0 + L0/2 - height*scale, Y0 - (length + 4.*width)*scale, Z1);
      glScalef (2.*scale, 2.*scale, 2.*scale);
      gl_StrokeString ("X");
      glPopMatrix();


      glPushMatrix();
      
# 1050 "/Users/weugene/basilisk/src/draw.h" 3 4
     __builtin___sprintf_chk (
# 1050 "/Users/weugene/basilisk/src/draw.h"
     label
# 1050 "/Users/weugene/basilisk/src/draw.h" 3 4
     , 0, __builtin_object_size (
# 1050 "/Users/weugene/basilisk/src/draw.h"
     label
# 1050 "/Users/weugene/basilisk/src/draw.h" 3 4
     , 2 > 1 ? 1 : 0), 
# 1050 "/Users/weugene/basilisk/src/draw.h"
     "%g", Y0 + L0/2.
# 1050 "/Users/weugene/basilisk/src/draw.h" 3 4
     )
# 1050 "/Users/weugene/basilisk/src/draw.h"
                                      ;
      length = gl_StrokeLength (label);
      glTranslatef (X0 - (length + 4.*width)*scale,
      Y0 + L0/2. - height*scale, Z1);
      glScalef (2.*scale, 2.*scale, 2.*scale);
      gl_StrokeString ("Y");
      glPopMatrix();
# 1069 "/Users/weugene/basilisk/src/draw.h"
    }


     { { if (0 <= (grid->depth)) { { if (((Tree *)grid)->dirty) update_cache_f(); }; CacheLevel _active = ((Tree *)grid)->active[0]; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; point.level = 0; int _k; for (_k = 0; _k < _active.n; _k++) { point.i = _active.p[_k].i; point.j = _active.p[_k].j; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 1072 "/Users/weugene/basilisk/src/draw.h"
 {
      glBegin (
# 1073 "/Users/weugene/basilisk/src/draw.h" 3
              0x0002
# 1073 "/Users/weugene/basilisk/src/draw.h"
                          );
      glvertex2d (view, x - Delta/2., y - Delta/2.);
      glvertex2d (view, x + Delta/2., y - Delta/2.);
      glvertex2d (view, x + Delta/2., y + Delta/2.);
      glvertex2d (view, x - Delta/2., y + Delta/2.);
      glEnd ();
      view->ni++;
    } } } } }; }}; }
# 1101 "/Users/weugene/basilisk/src/draw.h"
  } end_draw_lines(); }
  { 
# 1102 "/Users/weugene/basilisk/src/draw.h" 3 4
   _Bool 
# 1102 "/Users/weugene/basilisk/src/draw.h"
        _ret = 
# 1102 "/Users/weugene/basilisk/src/draw.h" 3 4
                1
# 1102 "/Users/weugene/basilisk/src/draw.h"
                    ; ; return _ret; }
 ; }
# 1116 "/Users/weugene/basilisk/src/draw.h"
struct _isosurface {
  char * f;
  double v;
  
# 1119 "/Users/weugene/basilisk/src/draw.h" 3 4
 _Bool 
# 1119 "/Users/weugene/basilisk/src/draw.h"
      edges;

  char * color;
  double min, max, spread;
  
# 1123 "/Users/weugene/basilisk/src/draw.h" 3 4
 _Bool 
# 1123 "/Users/weugene/basilisk/src/draw.h"
      linear;
  colormap map;
  float fc[3], lc[3], lw;
};



# 1129 "/Users/weugene/basilisk/src/draw.h" 3 4
_Bool 
# 1129 "/Users/weugene/basilisk/src/draw.h"
    isosurface (struct _isosurface p)
{ ;
# 1199 "/Users/weugene/basilisk/src/draw.h"
  { 
# 1199 "/Users/weugene/basilisk/src/draw.h" 3 4
   _Bool 
# 1199 "/Users/weugene/basilisk/src/draw.h"
        _ret = 
# 1199 "/Users/weugene/basilisk/src/draw.h" 3 4
                1
# 1199 "/Users/weugene/basilisk/src/draw.h"
                    ; ; return _ret; }
 ; }
# 1210 "/Users/weugene/basilisk/src/draw.h"
struct _travelling {
  double start, end;
  float tx, ty, quat[4], fov;
};




void travelling (struct _travelling p)
{
  static float tx, ty, quat[4], fov;
  static double told = -1.;
  if (told < p.start && t >= p.start) {
    bview * view = get_view();
    tx = view->tx, ty = view->ty, fov = view->fov;
    for (int i = 0; i < 4; i++)
      quat[i] = view->quat[i];
  }
  if (t >= p.start && t <= p.end)
    view ((struct _view_set){.tx = (!p.tx ? tx : ((t - p.start)*(p.tx) + (p.end - t)*(tx))/(p.end - p.start)), .ty = (!p.ty ? ty : ((t - p.start)*(p.ty) + (p.end - t)*(ty))/(p.end - p.start)),
   .fov = (!p.fov ? fov : ((t - p.start)*(p.fov) + (p.end - t)*(fov))/(p.end - p.start)),
   .quat = {(!p.quat[0] ? quat[0] : ((t - p.start)*(p.quat[0]) + (p.end - t)*(quat[0]))/(p.end - p.start)), (!p.quat[1] ? quat[1] : ((t - p.start)*(p.quat[1]) + (p.end - t)*(quat[1]))/(p.end - p.start)),
           (!p.quat[2] ? quat[2] : ((t - p.start)*(p.quat[2]) + (p.end - t)*(quat[2]))/(p.end - p.start)), (!p.quat[3] ? quat[3] : ((t - p.start)*(p.quat[3]) + (p.end - t)*(quat[3]))/(p.end - p.start))}});
  if (told < p.end && t >= p.end) {
    bview * view = get_view();
    tx = view->tx, ty = view->ty, fov = view->fov;
    for (int i = 0; i < 4; i++)
      quat[i] = view->quat[i];
  }
  told = t;
}
# 1257 "/Users/weugene/basilisk/src/draw.h"
struct _draw_string {
  char * str;
  int pos;
  float size;
  float lc[3], lw;
};



# 1265 "/Users/weugene/basilisk/src/draw.h" 3 4
_Bool 
# 1265 "/Users/weugene/basilisk/src/draw.h"
    draw_string (struct _draw_string p)
{ ;
  bview * view = draw();

  glMatrixMode (
# 1269 "/Users/weugene/basilisk/src/draw.h" 3
               0x1701
# 1269 "/Users/weugene/basilisk/src/draw.h"
                            );
  glPushMatrix();
  glLoadIdentity();

  glMatrixMode (
# 1273 "/Users/weugene/basilisk/src/draw.h" 3
               0x1700
# 1273 "/Users/weugene/basilisk/src/draw.h"
                           );
  glPushMatrix();
  glLoadIdentity();

  glColor3f (p.lc[0], p.lc[1], p.lc[2]);
  glLineWidth (view->samples*(p.lw > 0. ? p.lw : 1.));

  float width = gl_StrokeWidth ('1'), height = gl_StrokeHeight();
  if (!p.size)
    p.size = 40;
  float hscale = 2./(p.size*width), vscale = hscale*view->width/view->height;
  float vmargin = width/2.*vscale;
  if (p.pos == 0)
    glTranslatef (-1., -1. + vmargin, 0.);
  else if (p.pos == 1)
    glTranslatef (-1., 1. - height*vscale, 0.);
  else if (p.pos == 2)
    glTranslatef (1. - strlen(p.str)*width*hscale, 1. - height*vscale, 0.);
  else
    glTranslatef (1. - strlen(p.str)*width*hscale, -1. + vmargin, 0.);
  glScalef (hscale, vscale, 1.);
  gl_StrokeString (p.str);

  glMatrixMode (
# 1296 "/Users/weugene/basilisk/src/draw.h" 3
               0x1700
# 1296 "/Users/weugene/basilisk/src/draw.h"
                           );
  glPopMatrix();
  glMatrixMode (
# 1298 "/Users/weugene/basilisk/src/draw.h" 3
               0x1701
# 1298 "/Users/weugene/basilisk/src/draw.h"
                            );
  glPopMatrix();

  { 
# 1301 "/Users/weugene/basilisk/src/draw.h" 3 4
   _Bool 
# 1301 "/Users/weugene/basilisk/src/draw.h"
        _ret = 
# 1301 "/Users/weugene/basilisk/src/draw.h" 3 4
                1
# 1301 "/Users/weugene/basilisk/src/draw.h"
                    ; ; return _ret; }
 ; }
# 346 "/Users/weugene/basilisk/src/view.h"
# 366 "/Users/weugene/basilisk/src/view.h"
struct _load {
  FILE * fp;
  char * file;
  Array * buf;
  Array * history;
};


# 373 "/Users/weugene/basilisk/src/view.h" 3 4
_Bool 
# 373 "/Users/weugene/basilisk/src/view.h"
    load (struct _load p);
# 417 "/Users/weugene/basilisk/src/view.h"
struct _save {
  char * file, * format, * opt;
  FILE * fp;
  float lw;
  int sort, options;

  Array * history;
  bview * view;
};

static void bview_draw (bview * view)
{
  if (!view->active)
    return;
  view->active = 
# 431 "/Users/weugene/basilisk/src/view.h" 3 4
                0
# 431 "/Users/weugene/basilisk/src/view.h"
                     ;
  glFinish ();
  feenableexcept (
# 433 "/Users/weugene/basilisk/src/view.h" 3 4
 0x0004
# 433 "/Users/weugene/basilisk/src/view.h"
 |
# 433 "/Users/weugene/basilisk/src/view.h" 3 4
 0x0001
# 433 "/Users/weugene/basilisk/src/view.h"
 );
}

static void redraw_feedback (struct _save * p)
{
  bview * view = p->view ? p->view : get_view();
  
# 439 "/Users/weugene/basilisk/src/view.h" 3 4
 (__builtin_expect(!(
# 439 "/Users/weugene/basilisk/src/view.h"
 p->history
# 439 "/Users/weugene/basilisk/src/view.h" 3 4
 ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/view.h", 439, 
# 439 "/Users/weugene/basilisk/src/view.h"
 "p->history"
# 439 "/Users/weugene/basilisk/src/view.h" 3 4
 ) : (void)0)
# 439 "/Users/weugene/basilisk/src/view.h"
                    ;
  if (p->history->len) {
    float res = view->res;
    view->res = 0.;
    view->vector = 
# 443 "/Users/weugene/basilisk/src/view.h" 3 4
                  1
# 443 "/Users/weugene/basilisk/src/view.h"
                      ;
    redraw();


    int list = glGenLists (1);
    glNewList (list, 
# 448 "/Users/weugene/basilisk/src/view.h" 3
                    0x1300
# 448 "/Users/weugene/basilisk/src/view.h"
                              );
    load ((struct _load){.buf = p->history});
    glEndList();
    glCallList (list);
    glFinish ();
    glDeleteLists (list, 1);
    feenableexcept (
# 454 "/Users/weugene/basilisk/src/view.h" 3 4
   0x0004
# 454 "/Users/weugene/basilisk/src/view.h"
   |
# 454 "/Users/weugene/basilisk/src/view.h" 3 4
   0x0001
# 454 "/Users/weugene/basilisk/src/view.h"
   );
    view->active = 
# 455 "/Users/weugene/basilisk/src/view.h" 3 4
                  0
# 455 "/Users/weugene/basilisk/src/view.h"
                       ;
    view->vector = 
# 456 "/Users/weugene/basilisk/src/view.h" 3 4
                  0
# 456 "/Users/weugene/basilisk/src/view.h"
                       ;
    view->res = res;
  }
}





# 464 "/Users/weugene/basilisk/src/view.h" 3 4
_Bool 
# 464 "/Users/weugene/basilisk/src/view.h"
    save (struct _save p)
{ ;
  char ppm[] = "ppm";
  if (!p.format) {
    p.format = ppm;
    if (p.file) {
      char * s = strchr (p.file, '.'), * dot = s;
      while (s) {
 dot = s;
 s = strchr (s + 1, '.');
      }
      if (dot)
 p.format = dot + 1;
    }
  }

  bview * view = p.view ? p.view : get_view();

  if (!strcmp (p.format, "png") ||
      !strcmp (p.format, "jpg") ||
      (p.file && is_animation (p.file))) {
    bview_draw (view);
    unsigned char * image = (unsigned char *) compose_image (view);
    if (0 == 0) {
      FILE * fp = open_image (p.file, p.opt);
      gl_write_image (fp, image, view->width, view->height, view->samples);
      close_image (p.file, fp);
    }
    { 
# 492 "/Users/weugene/basilisk/src/view.h" 3 4
     _Bool 
# 492 "/Users/weugene/basilisk/src/view.h"
          _ret = 
# 492 "/Users/weugene/basilisk/src/view.h" 3 4
                  1
# 492 "/Users/weugene/basilisk/src/view.h"
                      ; ; return _ret; }
  }

  if (p.file && (p.fp = fopen (p.file, "w")) == 
# 495 "/Users/weugene/basilisk/src/view.h" 3 4
                                               ((void *)0)
# 495 "/Users/weugene/basilisk/src/view.h"
                                                   ) {
    perror (p.file);
    { 
# 497 "/Users/weugene/basilisk/src/view.h" 3 4
     _Bool 
# 497 "/Users/weugene/basilisk/src/view.h"
          _ret = 
# 497 "/Users/weugene/basilisk/src/view.h" 3 4
                  0
# 497 "/Users/weugene/basilisk/src/view.h"
                       ; ; return _ret; }
  }
  if (!p.fp)
    p.fp = 
# 500 "/Users/weugene/basilisk/src/view.h" 3 4
          __stdoutp
# 500 "/Users/weugene/basilisk/src/view.h"
                   ;

  if (!strcmp (p.format, "ppm")) {
    bview_draw (view);
    unsigned char * image = (unsigned char *) compose_image (view);
    if (0 == 0)
      gl_write_image (p.fp, image, view->width, view->height, view->samples);
  }

  else if (!strcmp (p.format, "bv")) {
    
# 510 "/Users/weugene/basilisk/src/view.h" 3 4
   (__builtin_expect(!(
# 510 "/Users/weugene/basilisk/src/view.h"
   p.history
# 510 "/Users/weugene/basilisk/src/view.h" 3 4
   ), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/view.h", 510, 
# 510 "/Users/weugene/basilisk/src/view.h"
   "p.history"
# 510 "/Users/weugene/basilisk/src/view.h" 3 4
   ) : (void)0)
# 510 "/Users/weugene/basilisk/src/view.h"
                     ;
    fprintf (p.fp,
      "view (fov = %g, quat = {%g,%g,%g,%g}, "
      "tx = %g, ty = %g, "
      "bg = {%g,%g,%g}, "
      "width = %d, height = %d, samples = %d"
      ");\n",
      view->fov,
      view->quat[0], view->quat[1], view->quat[2], view->quat[3],
      view->tx, view->ty,
      view->bg[0], view->bg[1], view->bg[2],
      view->width/view->samples, view->height/view->samples,
      view->samples);
    fwrite (p.history->p, 1, p.history->len, p.fp);
  }

  else if (!strcmp (p.format, "gnu") ||
    !strcmp (p.format, "obj") ||
    !strcmp (p.format, "kml")) {
    int format = (!strcmp (p.format, "gnu") ? FEEDBACK_GNU :
    !strcmp (p.format, "obj") ? FEEDBACK_OBJ :
    !strcmp (p.format, "kml") ? FEEDBACK_KML :
    -1);
    unsigned buffsize = 1 << 24;
    
# 534 "/Users/weugene/basilisk/src/view.h" 3 4
   _Bool 
# 534 "/Users/weugene/basilisk/src/view.h"
        done = 
# 534 "/Users/weugene/basilisk/src/view.h" 3 4
               0
# 534 "/Users/weugene/basilisk/src/view.h"
                    ;
    while (!done && buffsize <= (1 << 28)) {
      float * f = gl_feedback_begin (buffsize);
      redraw_feedback (&p);
      done = gl_feedback_end (f, p.fp, format);
      buffsize *= 2;
    }
    if (!done)
      fprintf (
# 542 "/Users/weugene/basilisk/src/view.h" 3 4
              __stderrp
# 542 "/Users/weugene/basilisk/src/view.h"
                  , "save(): error: exceeded maximum feedback buffer size\n");
  }

  else if (!strcmp (p.format, "ps") ||
    !strcmp (p.format, "eps") ||
    !strcmp (p.format, "tex") ||
    !strcmp (p.format, "pdf") ||
    !strcmp (p.format, "svg") ||
    !strcmp (p.format, "pgf")) {
    GLint format = (!strcmp (p.format, "ps") ? 0 :
      !strcmp (p.format, "eps") ? 1 :
      !strcmp (p.format, "tex") ? 2 :
      !strcmp (p.format, "pdf") ? 3 :
      !strcmp (p.format, "svg") ? 4 :
      !strcmp (p.format, "pgf") ? 5 :
      -1);
    GLint state = 5;
    GLint sort = p.sort ? p.sort : 2;
    GLint options = p.options ? p.options : ((1<<1) |
          (1<<2) |
          (1<<3) |
          (1<<4) |
          (1<<9) |
          (1<<12));
    unsigned buffsize = 1 << 24;
    while (state == 5 && buffsize <= (1 << 28)) {
      gl2psBeginPage ("", "bview",
        
# 569 "/Users/weugene/basilisk/src/view.h" 3 4
       ((void *)0)
# 569 "/Users/weugene/basilisk/src/view.h"
           ,
        format, sort, options,
        
# 571 "/Users/weugene/basilisk/src/view.h" 3
       0x1908
# 571 "/Users/weugene/basilisk/src/view.h"
              , 0, 
# 571 "/Users/weugene/basilisk/src/view.h" 3 4
                   ((void *)0)
# 571 "/Users/weugene/basilisk/src/view.h"
                       ,
        0, 0, 0,
        buffsize, p.fp, "");
      redraw_feedback (&p);
      fedisableexcept (
# 575 "/Users/weugene/basilisk/src/view.h" 3 4
     0x0004
# 575 "/Users/weugene/basilisk/src/view.h"
     |
# 575 "/Users/weugene/basilisk/src/view.h" 3 4
     0x0001
# 575 "/Users/weugene/basilisk/src/view.h"
     );
      state = gl2psEndPage();
      feenableexcept (
# 577 "/Users/weugene/basilisk/src/view.h" 3 4
     0x0004
# 577 "/Users/weugene/basilisk/src/view.h"
     |
# 577 "/Users/weugene/basilisk/src/view.h" 3 4
     0x0001
# 577 "/Users/weugene/basilisk/src/view.h"
     );
      buffsize *= 2;
    }
    if (state == 5)
      fprintf (
# 581 "/Users/weugene/basilisk/src/view.h" 3 4
              __stderrp
# 581 "/Users/weugene/basilisk/src/view.h"
                  , "save(): error: exceeded maximum feedback buffer size\n");
  }

  else {
    fprintf (
# 585 "/Users/weugene/basilisk/src/view.h" 3 4
            __stderrp
# 585 "/Users/weugene/basilisk/src/view.h"
                , "save(): unknown format '%s'\n", p.format);
    if (p.file) {
      fclose (p.fp);
      remove (p.file);
    }
    { 
# 590 "/Users/weugene/basilisk/src/view.h" 3 4
     _Bool 
# 590 "/Users/weugene/basilisk/src/view.h"
          _ret = 
# 590 "/Users/weugene/basilisk/src/view.h" 3 4
                  0
# 590 "/Users/weugene/basilisk/src/view.h"
                       ; ; return _ret; }
  }

  fflush (p.fp);
  if (p.file)
    fclose (p.fp);

  { 
# 597 "/Users/weugene/basilisk/src/view.h" 3 4
   _Bool 
# 597 "/Users/weugene/basilisk/src/view.h"
        _ret = 
# 597 "/Users/weugene/basilisk/src/view.h" 3 4
                1
# 597 "/Users/weugene/basilisk/src/view.h"
                    ; ; return _ret; }
 ; }







static char * remove_blanks (char * line)
{
  while (strchr (" \t", *line)) line++;
  char * s = line, * cur = line;
  
# 610 "/Users/weugene/basilisk/src/view.h" 3 4
 _Bool 
# 610 "/Users/weugene/basilisk/src/view.h"
      instring = 
# 610 "/Users/weugene/basilisk/src/view.h" 3 4
                 0
# 610 "/Users/weugene/basilisk/src/view.h"
                      ;
  while (*s != '\0' && *s != '#') {
    if (*s == '"')
      instring = !instring;
    if (instring || !strchr (" \t", *s))
      *cur++ = *s;
    s++;
  }
  *cur = '\0';
  return line;
}

static void fields_stats()
{
  fprintf (
# 624 "/Users/weugene/basilisk/src/view.h" 3 4
          __stderrp
# 624 "/Users/weugene/basilisk/src/view.h"
              , "# t = %g, fields = {", t);
  if (all) for (scalar s = *all, *_i93 = all; ((scalar *)&s)->i >= 0; s = *++_i93)
    fprintf (
# 626 "/Users/weugene/basilisk/src/view.h" 3 4
            __stderrp
# 626 "/Users/weugene/basilisk/src/view.h"
                , " %s", _attribute[s.i].name);
  fputs (" }\n", 
# 627 "/Users/weugene/basilisk/src/view.h" 3 4
                __stderrp
# 627 "/Users/weugene/basilisk/src/view.h"
                    );
  fprintf (
# 628 "/Users/weugene/basilisk/src/view.h" 3 4
          __stderrp
# 628 "/Users/weugene/basilisk/src/view.h"
              , "# %12s: %12s %12s %12s %12s\n",
    "name", "min", "avg", "stddev", "max");
  if (all) for (scalar s = *all, *_i94 = all; ((scalar *)&s)->i >= 0; s = *++_i94) {
    stats ss = statsf (s);
    fprintf (
# 632 "/Users/weugene/basilisk/src/view.h" 3 4
            __stderrp
# 632 "/Users/weugene/basilisk/src/view.h"
                , "# %12s: %12g %12g %12g %12g\n",
      _attribute[s.i].name, ss.min, ss.sum/ss.volume, ss.stddev, ss.max);
  }
}

static void draw_append (char * buf, Array * history, FILE * interactive)
{
  if (interactive) {
    if (history->len)
      load ((struct _load){.buf = history});
    save ((struct _save){.fp = interactive});
  }
  array_append (history, buf, strlen(buf)*sizeof(char));
}
# 1 "draw_get.h"
# 1 "/Users/weugene/basilisk/src/draw_get.h"
# 1 "parse.h"
# 1 "/Users/weugene/basilisk/src/parse.h"




enum ParamsType { pstring, pint, punsigned, pbool, pfloat, pdouble, pcolormap };

typedef struct {
  char * key;
  enum ParamsType type;
  void * val;
  int n;
} Params;

static 
# 14 "/Users/weugene/basilisk/src/parse.h" 3 4
      _Bool 
# 14 "/Users/weugene/basilisk/src/parse.h"
           atobool (char * s)
{
  if (!strcmp (s, "true"))
    return 
# 17 "/Users/weugene/basilisk/src/parse.h" 3 4
          1
# 17 "/Users/weugene/basilisk/src/parse.h"
              ;
  if (!strcmp (s, "false"))
    return 
# 19 "/Users/weugene/basilisk/src/parse.h" 3 4
          0
# 19 "/Users/weugene/basilisk/src/parse.h"
               ;
  return atoi (s) != 0;
}

static 
# 23 "/Users/weugene/basilisk/src/parse.h" 3 4
      _Bool 
# 23 "/Users/weugene/basilisk/src/parse.h"
           args (Params * p, char * val)
{
  static char * name[] = { "string", "int", "unsigned",
      "bool", "float", "double", "colormap" };
  switch (p->type) {

  case pstring:
    if (val[0] != '"') {
      fprintf (
# 31 "/Users/weugene/basilisk/src/parse.h" 3 4
              __stderrp
# 31 "/Users/weugene/basilisk/src/parse.h"
                       , "expecting a string for '%s' got '%s'\n", p->key, val);
      return 
# 32 "/Users/weugene/basilisk/src/parse.h" 3 4
            0
# 32 "/Users/weugene/basilisk/src/parse.h"
                 ;
    }
    if (val[strlen(val) - 1] != '"') {
      fprintf (
# 35 "/Users/weugene/basilisk/src/parse.h" 3 4
              __stderrp
# 35 "/Users/weugene/basilisk/src/parse.h"
                       , "unterminated quoted string '%s'\n", val);
      return 
# 36 "/Users/weugene/basilisk/src/parse.h" 3 4
            0
# 36 "/Users/weugene/basilisk/src/parse.h"
                 ;
    }
    val[strlen(val) - 1] = '\0';
    *((char **)p->val) = &val[1];
    break;

  case pcolormap:
    if (!strcmp (val, "jet"))
      *((colormap *)p->val) = jet;
    else if (!strcmp (val, "cool_warm"))
      *((colormap *)p->val) = cool_warm;
    else if (!strcmp (val, "gray"))
      *((colormap *)p->val) = gray;
    else if (!strcmp (val, "randomap"))
      *((colormap *)p->val) = randomap;
    else {
      fprintf (
# 52 "/Users/weugene/basilisk/src/parse.h" 3 4
              __stderrp
# 52 "/Users/weugene/basilisk/src/parse.h"
                       , "unknown colormap '%s'\n", val);
      return 
# 53 "/Users/weugene/basilisk/src/parse.h" 3 4
            0
# 53 "/Users/weugene/basilisk/src/parse.h"
                 ;
    }
    break;

  case pint: case punsigned: case pbool: case pdouble: case pfloat:
    if (val[0] == '"') {
      fprintf (
# 59 "/Users/weugene/basilisk/src/parse.h" 3 4
              __stderrp
# 59 "/Users/weugene/basilisk/src/parse.h"
                       , "expecting a %s for '%s' got %s\n",
        name[p->type], p->key, val);
      return 
# 61 "/Users/weugene/basilisk/src/parse.h" 3 4
            0
# 61 "/Users/weugene/basilisk/src/parse.h"
                 ;
    }
    if (!p->n) {
      switch (p->type) {
      case pint: *((int *)p->val) = atoi(val); break;
      case punsigned: *((unsigned *)p->val) = atoi(val); break;
      case pbool: *((
# 67 "/Users/weugene/basilisk/src/parse.h" 3 4
                    _Bool 
# 67 "/Users/weugene/basilisk/src/parse.h"
                         *)p->val) = atobool(val); break;
      case pfloat: *((float *)p->val) = atof(val); break;
      case pdouble: *((double *)p->val) = atof(val); break;
      default: 
# 70 "/Users/weugene/basilisk/src/parse.h" 3 4
              (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/parse.h", 70, 
# 70 "/Users/weugene/basilisk/src/parse.h"
              "false"
# 70 "/Users/weugene/basilisk/src/parse.h" 3 4
              ) : (void)0)
# 70 "/Users/weugene/basilisk/src/parse.h"
                            ;
      }
    }
    else {
      if (val[0] != '{') {
 fprintf (
# 75 "/Users/weugene/basilisk/src/parse.h" 3 4
         __stderrp
# 75 "/Users/weugene/basilisk/src/parse.h"
                  , "expecting an array for '%s' got %s\n", p->key, val);
 return 
# 76 "/Users/weugene/basilisk/src/parse.h" 3 4
       0
# 76 "/Users/weugene/basilisk/src/parse.h"
            ;
      }
      val++;
      int i = 0;
      char c = ',';
      while (i < p->n && c != '}') {
 char * s = strchr (val, ',');
 if (!s)
   s = strchr (val, '}');
 if (!s) {
   fprintf (
# 86 "/Users/weugene/basilisk/src/parse.h" 3 4
           __stderrp
# 86 "/Users/weugene/basilisk/src/parse.h"
                    , "expecting an array for '%s' got %s\n", p->key, val);
   return 
# 87 "/Users/weugene/basilisk/src/parse.h" 3 4
         0
# 87 "/Users/weugene/basilisk/src/parse.h"
              ;
 }
 c = *s;
 *s++ = '\0';
 switch (p->type) {
 case pint: ((int *)p->val)[i++] = atoi (val); break;
 case punsigned: ((unsigned *)p->val)[i++] = atoi (val); break;
 case pbool: ((
# 94 "/Users/weugene/basilisk/src/parse.h" 3 4
              _Bool 
# 94 "/Users/weugene/basilisk/src/parse.h"
                   *)p->val)[i++] = atobool (val); break;
 case pfloat: ((float *)p->val)[i++] = atof (val); break;
 case pdouble: ((double *)p->val)[i++] = atof (val); break;
 default: 
# 97 "/Users/weugene/basilisk/src/parse.h" 3 4
         (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/parse.h", 97, 
# 97 "/Users/weugene/basilisk/src/parse.h"
         "false"
# 97 "/Users/weugene/basilisk/src/parse.h" 3 4
         ) : (void)0)
# 97 "/Users/weugene/basilisk/src/parse.h"
                       ;
 }
 val = s;
      }
      if (c != '}') {
 fprintf (
# 102 "/Users/weugene/basilisk/src/parse.h" 3 4
         __stderrp
# 102 "/Users/weugene/basilisk/src/parse.h"
                  , "expecting '}' for '%s' got %s\n", p->key, val);
 return 
# 103 "/Users/weugene/basilisk/src/parse.h" 3 4
       0
# 103 "/Users/weugene/basilisk/src/parse.h"
            ;
      }
    }
    break;

  default:
    
# 109 "/Users/weugene/basilisk/src/parse.h" 3 4
   (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "/Users/weugene/basilisk/src/parse.h", 109, 
# 109 "/Users/weugene/basilisk/src/parse.h"
   "false"
# 109 "/Users/weugene/basilisk/src/parse.h" 3 4
   ) : (void)0)
# 109 "/Users/weugene/basilisk/src/parse.h"
                 ;
  }
  return 
# 111 "/Users/weugene/basilisk/src/parse.h" 3 4
        1
# 111 "/Users/weugene/basilisk/src/parse.h"
            ;
}

static char * find_comma (char * s)
{
  int par = 0;
  while (*s != '\0') {
    if (*s == ',' && par == 0) {
      *s = '\0';
      return s + 1;
    }
    if (*s == '{')
      par++;
    else if (*s == '}')
      par--;
    s++;
  }
  return 
# 128 "/Users/weugene/basilisk/src/parse.h" 3 4
        ((void *)0)
# 128 "/Users/weugene/basilisk/src/parse.h"
            ;
}

int parse_params (Params * params)
{
  char * s;
  int i = 0, n = 0;
  Params * p = params;
  while (p->key) p++, n++;
  if (!(s = strtok (
# 137 "/Users/weugene/basilisk/src/parse.h" 3 4
                   ((void *)0)
# 137 "/Users/weugene/basilisk/src/parse.h"
                       , ");")) || s[0] == '\n')
    return 
# 138 "/Users/weugene/basilisk/src/parse.h" 3 4
          0
# 138 "/Users/weugene/basilisk/src/parse.h"
               ;
  while (s) {
    char * next = find_comma (s), * key = s;
    if ((s = strchr (key, '='))) {
      s[0] = '\0', s++;
      i = -1;
      Params * p = params;
      while (p->key && strcmp(p->key, key)) p++;
      if (!p->key) {
 fprintf (
# 147 "/Users/weugene/basilisk/src/parse.h" 3 4
         __stderrp
# 147 "/Users/weugene/basilisk/src/parse.h"
                  , "unknown key '%s'\n", key);
 return 
# 148 "/Users/weugene/basilisk/src/parse.h" 3 4
       0
# 148 "/Users/weugene/basilisk/src/parse.h"
            ;
      }
      if (!args (p, s))
 return 
# 151 "/Users/weugene/basilisk/src/parse.h" 3 4
       0
# 151 "/Users/weugene/basilisk/src/parse.h"
            ;
    }
    else {
      if (i < 0) {
 fprintf (
# 155 "/Users/weugene/basilisk/src/parse.h" 3 4
         __stderrp
# 155 "/Users/weugene/basilisk/src/parse.h"
                  , "anonymous value '%s' after keys\n", key);
 return 
# 156 "/Users/weugene/basilisk/src/parse.h" 3 4
       0
# 156 "/Users/weugene/basilisk/src/parse.h"
            ;
      }
      if (i >= n) {
 fprintf (
# 159 "/Users/weugene/basilisk/src/parse.h" 3 4
         __stderrp
# 159 "/Users/weugene/basilisk/src/parse.h"
                  , "too many parameters: '%s' %d %d\n", key, i, n);
 return 
# 160 "/Users/weugene/basilisk/src/parse.h" 3 4
       0
# 160 "/Users/weugene/basilisk/src/parse.h"
            ;
      }
      if (!args (&params[i], key))
 return 
# 163 "/Users/weugene/basilisk/src/parse.h" 3 4
       0
# 163 "/Users/weugene/basilisk/src/parse.h"
            ;
      i++;
    }
    s = next;
  }
  return 
# 168 "/Users/weugene/basilisk/src/parse.h" 3 4
        1
# 168 "/Users/weugene/basilisk/src/parse.h"
            ;
}
# 3 "/Users/weugene/basilisk/src/draw_get.h"


# 4 "/Users/weugene/basilisk/src/draw_get.h" 3 4
_Bool 
# 4 "/Users/weugene/basilisk/src/draw_get.h"
    _view_set_get (struct _view_set * p) {
  Params params[] = {
    {"ty", pfloat, &p->ty},
    {"tx", pfloat, &p->tx},
    {"fov", pfloat, &p->fov},
    {"quat", pfloat, p->quat, 4},
    {"sy", pfloat, &p->sy},
    {"sz", pfloat, &p->sz},
    {"sx", pfloat, &p->sx},
    {"height", punsigned, &p->height},
    {"samples", punsigned, &p->samples},
    {"width", punsigned, &p->width},
    {"bg", pfloat, p->bg, 3},
    {"phi", pfloat, &p->phi},
    {"psi", pfloat, &p->psi},
    {"theta", pfloat, &p->theta},
    {"relative", pbool, &p->relative},
    {"res", pfloat, &p->res},
    {"camera", pstring, &p->camera},
    {"p1y", pfloat, &p->p1y},
    {"p2x", pfloat, &p->p2x},
    {"p2y", pfloat, &p->p2y},
    {"p1x", pfloat, &p->p1x},
    {
# 27 "/Users/weugene/basilisk/src/draw_get.h" 3 4
    ((void *)0)
# 27 "/Users/weugene/basilisk/src/draw_get.h"
        }
  };
  return parse_params (params);
}


# 32 "/Users/weugene/basilisk/src/draw_get.h" 3 4
_Bool 
# 32 "/Users/weugene/basilisk/src/draw_get.h"
    _translate_get (struct _translate * p) {
  Params params[] = {
    {"y", pfloat, &p->y},
    {"z", pfloat, &p->z},
    {"x", pfloat, &p->x},
    {
# 37 "/Users/weugene/basilisk/src/draw_get.h" 3 4
    ((void *)0)
# 37 "/Users/weugene/basilisk/src/draw_get.h"
        }
  };
  return parse_params (params);
}


# 42 "/Users/weugene/basilisk/src/draw_get.h" 3 4
_Bool 
# 42 "/Users/weugene/basilisk/src/draw_get.h"
    _mirror_get (struct _mirror * p) {
  Params params[] = {
    {"n", pdouble, &p->n, 3},
    {"alpha", pdouble, &p->alpha},
    {
# 46 "/Users/weugene/basilisk/src/draw_get.h" 3 4
    ((void *)0)
# 46 "/Users/weugene/basilisk/src/draw_get.h"
        }
  };
  return parse_params (params);
}


# 51 "/Users/weugene/basilisk/src/draw_get.h" 3 4
_Bool 
# 51 "/Users/weugene/basilisk/src/draw_get.h"
    _draw_vof_get (struct _draw_vof * p) {
  Params params[] = {
    {"c", pstring, &p->c},
    {"s", pstring, &p->s},
    {"edges", pbool, &p->edges},
    {"larger", pdouble, &p->larger},
    {"filled", pint, &p->filled},
    {"color", pstring, &p->color},
    {"max", pdouble, &p->max},
    {"spread", pdouble, &p->spread},
    {"min", pdouble, &p->min},
    {"linear", pbool, &p->linear},
    {"map", pcolormap, &p->map},
    {"lc", pfloat, p->lc, 3},
    {"lw", pfloat, &p->lw},
    {"fc", pfloat, p->fc, 3},
    {
# 67 "/Users/weugene/basilisk/src/draw_get.h" 3 4
    ((void *)0)
# 67 "/Users/weugene/basilisk/src/draw_get.h"
        }
  };
  return parse_params (params);
}


# 72 "/Users/weugene/basilisk/src/draw_get.h" 3 4
_Bool 
# 72 "/Users/weugene/basilisk/src/draw_get.h"
    _isoline_get (struct _isoline * p) {
  Params params[] = {
    {"phi", pstring, &p->phi},
    {"val", pdouble, &p->val},
    {"n", pint, &p->n},
    {"c", pstring, &p->c},
    {"s", pstring, &p->s},
    {"edges", pbool, &p->edges},
    {"larger", pdouble, &p->larger},
    {"filled", pint, &p->filled},
    {"color", pstring, &p->color},
    {"max", pdouble, &p->max},
    {"spread", pdouble, &p->spread},
    {"min", pdouble, &p->min},
    {"linear", pbool, &p->linear},
    {"map", pcolormap, &p->map},
    {"lc", pfloat, p->lc, 3},
    {"lw", pfloat, &p->lw},
    {"fc", pfloat, p->fc, 3},
    {
# 91 "/Users/weugene/basilisk/src/draw_get.h" 3 4
    ((void *)0)
# 91 "/Users/weugene/basilisk/src/draw_get.h"
        }
  };
  return parse_params (params);
}


# 96 "/Users/weugene/basilisk/src/draw_get.h" 3 4
_Bool 
# 96 "/Users/weugene/basilisk/src/draw_get.h"
    _cells_get (struct _cells * p) {
  Params params[] = {
    {"n", pdouble, &p->n, 3},
    {"alpha", pdouble, &p->alpha},
    {"lw", pfloat, &p->lw},
    {"lc", pfloat, p->lc, 3},
    {
# 102 "/Users/weugene/basilisk/src/draw_get.h" 3 4
    ((void *)0)
# 102 "/Users/weugene/basilisk/src/draw_get.h"
        }
  };
  return parse_params (params);
}


# 107 "/Users/weugene/basilisk/src/draw_get.h" 3 4
_Bool 
# 107 "/Users/weugene/basilisk/src/draw_get.h"
    _vectors_get (struct _vectors * p) {
  Params params[] = {
    {"u", pstring, &p->u},
    {"scale", pdouble, &p->scale},
    {"lw", pfloat, &p->lw},
    {"lc", pfloat, p->lc, 3},
    {
# 113 "/Users/weugene/basilisk/src/draw_get.h" 3 4
    ((void *)0)
# 113 "/Users/weugene/basilisk/src/draw_get.h"
        }
  };
  return parse_params (params);
}


# 118 "/Users/weugene/basilisk/src/draw_get.h" 3 4
_Bool 
# 118 "/Users/weugene/basilisk/src/draw_get.h"
    _squares_get (struct _squares * p) {
  Params params[] = {
    {"color", pstring, &p->color},
    {"max", pdouble, &p->max},
    {"spread", pdouble, &p->spread},
    {"min", pdouble, &p->min},
    {"linear", pbool, &p->linear},
    {"map", pcolormap, &p->map},
    {"lc", pfloat, p->lc, 3},
    {"fc", pfloat, p->fc, 3},
    {"n", pdouble, &p->n, 3},
    {"alpha", pdouble, &p->alpha},
    {
# 130 "/Users/weugene/basilisk/src/draw_get.h" 3 4
    ((void *)0)
# 130 "/Users/weugene/basilisk/src/draw_get.h"
        }
  };
  return parse_params (params);
}


# 135 "/Users/weugene/basilisk/src/draw_get.h" 3 4
_Bool 
# 135 "/Users/weugene/basilisk/src/draw_get.h"
    _box_get (struct _box * p) {
  Params params[] = {
    {"notics", pbool, &p->notics},
    {"lw", pfloat, &p->lw},
    {"lc", pfloat, p->lc, 3},
    {
# 140 "/Users/weugene/basilisk/src/draw_get.h" 3 4
    ((void *)0)
# 140 "/Users/weugene/basilisk/src/draw_get.h"
        }
  };
  return parse_params (params);
}


# 145 "/Users/weugene/basilisk/src/draw_get.h" 3 4
_Bool 
# 145 "/Users/weugene/basilisk/src/draw_get.h"
    _isosurface_get (struct _isosurface * p) {
  Params params[] = {
    {"f", pstring, &p->f},
    {"v", pdouble, &p->v},
    {"edges", pbool, &p->edges},
    {"color", pstring, &p->color},
    {"max", pdouble, &p->max},
    {"spread", pdouble, &p->spread},
    {"min", pdouble, &p->min},
    {"linear", pbool, &p->linear},
    {"map", pcolormap, &p->map},
    {"lc", pfloat, p->lc, 3},
    {"lw", pfloat, &p->lw},
    {"fc", pfloat, p->fc, 3},
    {
# 159 "/Users/weugene/basilisk/src/draw_get.h" 3 4
    ((void *)0)
# 159 "/Users/weugene/basilisk/src/draw_get.h"
        }
  };
  return parse_params (params);
}


# 164 "/Users/weugene/basilisk/src/draw_get.h" 3 4
_Bool 
# 164 "/Users/weugene/basilisk/src/draw_get.h"
    _travelling_get (struct _travelling * p) {
  Params params[] = {
    {"end", pdouble, &p->end},
    {"start", pdouble, &p->start},
    {"ty", pfloat, &p->ty},
    {"quat", pfloat, p->quat, 4},
    {"fov", pfloat, &p->fov},
    {"tx", pfloat, &p->tx},
    {
# 172 "/Users/weugene/basilisk/src/draw_get.h" 3 4
    ((void *)0)
# 172 "/Users/weugene/basilisk/src/draw_get.h"
        }
  };
  return parse_params (params);
}


# 177 "/Users/weugene/basilisk/src/draw_get.h" 3 4
_Bool 
# 177 "/Users/weugene/basilisk/src/draw_get.h"
    _draw_string_get (struct _draw_string * p) {
  Params params[] = {
    {"str", pstring, &p->str},
    {"pos", pint, &p->pos},
    {"size", pfloat, &p->size},
    {"lw", pfloat, &p->lw},
    {"lc", pfloat, p->lc, 3},
    {
# 184 "/Users/weugene/basilisk/src/draw_get.h" 3 4
    ((void *)0)
# 184 "/Users/weugene/basilisk/src/draw_get.h"
        }
  };
  return parse_params (params);
}
# 653 "/Users/weugene/basilisk/src/view.h"

static 
# 654 "/Users/weugene/basilisk/src/view.h" 3 4
      _Bool 
# 654 "/Users/weugene/basilisk/src/view.h"
           process_line (char * line, Array * history, FILE * interactive)
{
  if (line[0] == '\0')
    return 
# 657 "/Users/weugene/basilisk/src/view.h" 3 4
          1
# 657 "/Users/weugene/basilisk/src/view.h"
              ;
  char * buf = strdup(line);
  char * s = strtok (remove_blanks (line), "(");
  if (!s) {
    free(buf);
    return 
# 662 "/Users/weugene/basilisk/src/view.h" 3 4
          1
# 662 "/Users/weugene/basilisk/src/view.h"
              ;
  }

  if (!strcmp (s, "restore")) {
    char * file = 
# 666 "/Users/weugene/basilisk/src/view.h" 3 4
                 ((void *)0)
# 666 "/Users/weugene/basilisk/src/view.h"
                     ;
    parse_params ((Params[]){{"file", pstring, &file}, {
# 667 "/Users/weugene/basilisk/src/view.h" 3 4
                                                       ((void *)0)
# 667 "/Users/weugene/basilisk/src/view.h"
                                                           }});
    if (file) {
      if (!restore ((struct Dump){.file = file, .list = all}))
 fprintf (
# 670 "/Users/weugene/basilisk/src/view.h" 3 4
         __stderrp
# 670 "/Users/weugene/basilisk/src/view.h"
             , "could not restore from '%s'\n", file);
      else {
 restriction (all);
 fields_stats();
 clear();

 if (history->len && load ((struct _load){.buf = history}) && interactive)
   save ((struct _save){.fp = interactive});
      }
    }
  }

  else if (!strcmp (s, "dump")) {
    char * file = 
# 683 "/Users/weugene/basilisk/src/view.h" 3 4
                 ((void *)0)
# 683 "/Users/weugene/basilisk/src/view.h"
                     ;
    parse_params ((Params[]){{"file", pstring, &file}, {
# 684 "/Users/weugene/basilisk/src/view.h" 3 4
                                                       ((void *)0)
# 684 "/Users/weugene/basilisk/src/view.h"
                                                           }});
    dump ((struct Dump){.file = file});
  }

  else if (!strcmp (s, "input_gfs")) {
    char * file = 
# 689 "/Users/weugene/basilisk/src/view.h" 3 4
                 ((void *)0)
# 689 "/Users/weugene/basilisk/src/view.h"
                     ;
    parse_params ((Params[]){{"file", pstring, &file}, {
# 690 "/Users/weugene/basilisk/src/view.h" 3 4
                                                       ((void *)0)
# 690 "/Users/weugene/basilisk/src/view.h"
                                                           }});
    if (file) {
      input_gfs ((struct OutputGfs){.file = file, .list = all});
      restriction (all);
      fields_stats();
      clear();

      if (history->len && load ((struct _load){.buf = history}) && interactive)
 save ((struct _save){.fp = interactive});
    }
  }

  else if (!strcmp (s, "save")) {
    char * file = 
# 703 "/Users/weugene/basilisk/src/view.h" 3 4
                 ((void *)0)
# 703 "/Users/weugene/basilisk/src/view.h"
                     ;
    parse_params ((Params[]){{"file", pstring, &file}, {
# 704 "/Users/weugene/basilisk/src/view.h" 3 4
                                                       ((void *)0)
# 704 "/Users/weugene/basilisk/src/view.h"
                                                           }});
    if (file)
      save ((struct _save){.file = file, .history = history});
  }

  else if (!strcmp (s, "load")) {
    char * file = 
# 710 "/Users/weugene/basilisk/src/view.h" 3 4
                 ((void *)0)
# 710 "/Users/weugene/basilisk/src/view.h"
                     ;
    parse_params ((Params[]){{"file", pstring, &file}, {
# 711 "/Users/weugene/basilisk/src/view.h" 3 4
                                                       ((void *)0)
# 711 "/Users/weugene/basilisk/src/view.h"
                                                           }});
    if (file && load ((struct _load){.file = file, .history = history}) && interactive) {
      load ((struct _load){.buf = history});
      save ((struct _save){.fp = interactive});
    }
  }

  else if (!strcmp (s, "cells")) {
    struct _cells p = {{0}};
    _cells_get (&p);
    cells (p);
    draw_append (buf, history, interactive);
  }

  else if (!strcmp (s, "vectors")) {
    struct _vectors p = {0};
    _vectors_get (&p);
    vectors (p);
    draw_append (buf, history, interactive);
  }

  else if (!strcmp (s, "draw_vof")) {
    struct _draw_vof p = {0};
    _draw_vof_get (&p);
    if (draw_vof (p))
      draw_append (buf, history, interactive);
  }

  else if (!strcmp (s, "isoline")) {
    struct _isoline p = {0};
    _isoline_get (&p);
    if (isoline (p))
      draw_append (buf, history, interactive);
  }

  else if (!strcmp (s, "squares")) {
    struct _squares p = {0};
    _squares_get (&p);
    squares (p);
    draw_append (buf, history, interactive);
  }

  else if (!strcmp (s, "begin_translate")) {
    struct _translate p = {0};
    _translate_get (&p);
    begin_translate (p);
    draw_append (buf, history, interactive);
  }

  else if (!strcmp (s, "end_translate")) {
    end_translate();
    draw_append (buf, history, interactive);
  }

  else if (!strcmp (s, "begin_mirror")) {
    struct _mirror p = {{0}};
    _mirror_get (&p);
    begin_mirror (p);
    draw_append (buf, history, interactive);
  }

  else if (!strcmp (s, "end_mirror")) {
    end_mirror();
    draw_append (buf, history, interactive);
  }

  else if (!strcmp (s, "squares")) {
    struct _squares p = {0};
    _squares_get (&p);
    squares (p);
    draw_append (buf, history, interactive);
  }

  else if (!strcmp (s, "isosurface")) {
    struct _isosurface p = {0};
    _isosurface_get (&p);
    isosurface (p);
    draw_append (buf, history, interactive);
  }

  else if (!strcmp (s, "draw_string")) {
    struct _draw_string p = {0};
    _draw_string_get (&p);
    draw_string (p);
    draw_append (buf, history, interactive);
  }

  else if (!strcmp (s, "display")) {
    if (interactive && history->len && load ((struct _load){.buf = history}))
      save ((struct _save){.fp = interactive});
  }

  else if (!strcmp (s, "clear")) {
    clear();
    if (interactive)
      save ((struct _save){.fp = interactive});
    history->len = 0;
  }

  else if (!strcmp (s, "show")) {
    if (interactive && history->len)
      save ((struct _save){.fp = 
# 812 "/Users/weugene/basilisk/src/view.h" 3 4
                                __stderrp
# 812 "/Users/weugene/basilisk/src/view.h"
                                    , .format = "bv", .history = history});
  }

  else if (!strcmp (s, "box")) {
    struct _box p = {0};
    _box_get (&p);
    box (p);
    draw_append (buf, history, interactive);
  }

  else if (!strcmp (s, "view")) {
    struct _view_set p = {0};
    _view_set_get (&p);
    view (p);
    if (p.width || p.height || p.samples) {

      if (history->len && load ((struct _load){.buf = history}) && p.samples && interactive)
 save ((struct _save){.fp = interactive});
    }
  }

  else if (!strcmp (s, "quit")) {
    free(buf);
    return 
# 835 "/Users/weugene/basilisk/src/view.h" 3 4
          0
# 835 "/Users/weugene/basilisk/src/view.h"
               ;
  }

  else if (s[0] != '\n')
    fprintf (
# 839 "/Users/weugene/basilisk/src/view.h" 3 4
            __stderrp
# 839 "/Users/weugene/basilisk/src/view.h"
                , "load(): syntax error: '%s'\n", s);

  free(buf);
  return 
# 842 "/Users/weugene/basilisk/src/view.h" 3 4
        1
# 842 "/Users/weugene/basilisk/src/view.h"
            ;
}


# 845 "/Users/weugene/basilisk/src/view.h" 3 4
_Bool 
# 845 "/Users/weugene/basilisk/src/view.h"
    load (struct _load p) {
  if (p.file) {
    p.fp = fopen (p.file, "r");
    if (!p.fp) {
      perror (p.file);
      return 
# 850 "/Users/weugene/basilisk/src/view.h" 3 4
            0
# 850 "/Users/weugene/basilisk/src/view.h"
                 ;
    }
  }

  Array * history = array_new();
  if (p.fp) {
    char line[256];
    while (fgets (line, 256, p.fp) && process_line (line, history, 
# 857 "/Users/weugene/basilisk/src/view.h" 3 4
                                                                  ((void *)0)
# 857 "/Users/weugene/basilisk/src/view.h"
                                                                      ));
  }
  else if (p.buf) {
    int i = 0;
    char * s = (char *) p.buf->p;
    while (i < p.buf->len) {
      char * start = s;
      while (i < p.buf->len && *s != '\n')
 s++, i++;
      if (*s == '\n' && ++s > start) {
 char line[s - start + 1];
 
# 868 "/Users/weugene/basilisk/src/view.h" 3 4
__builtin___strncpy_chk (
# 868 "/Users/weugene/basilisk/src/view.h"
line
# 868 "/Users/weugene/basilisk/src/view.h" 3 4
, 
# 868 "/Users/weugene/basilisk/src/view.h"
start, s - start
# 868 "/Users/weugene/basilisk/src/view.h" 3 4
, __builtin_object_size (
# 868 "/Users/weugene/basilisk/src/view.h"
line
# 868 "/Users/weugene/basilisk/src/view.h" 3 4
, 2 > 1 ? 1 : 0))
# 868 "/Users/weugene/basilisk/src/view.h"
                                ;
 line[s - start] = '\0';
 process_line (line, history, 
# 870 "/Users/weugene/basilisk/src/view.h" 3 4
                             ((void *)0)
# 870 "/Users/weugene/basilisk/src/view.h"
                                 );
      }
    }
  }
  if (p.history)
    array_append (p.history, history->p, history->len);
  array_free (history);

  return 
# 878 "/Users/weugene/basilisk/src/view.h" 3 4
        1
# 878 "/Users/weugene/basilisk/src/view.h"
            ;
}
# 8 "karman_GI.c"
# 1 "../src_local/output_vtu_foreach.h"
# 1 "./../src_local/output_vtu_foreach.h"
# 16 "./../src_local/output_vtu_foreach.h"
void output_pvtu_ascii (scalar * list, vector * vlist, int n, FILE * fp, char * subname)
{
    fputs ("<?xml version=\"1.0\"?>\n"
    "<VTKFile type=\"PUnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\" header_type=\"UInt64\">\n", fp);
    fputs ("\t <PUnstructuredGrid GhostLevel=\"0\">\n", fp);
    fputs ("\t\t\t <PCellData Scalars=\"scalars\">\n", fp);
    if (list) for (scalar s = *list, *_i95 = list; ((scalar *)&s)->i >= 0; s = *++_i95) {
      fprintf (fp,"\t\t\t\t <PDataArray type=\"Float64\" Name=\"%s\" format=\"ascii\">\n", _attribute[s.i].name);
      fputs ("\t\t\t\t </PDataArray>\n", fp);
    }
    if (vlist) for (vector v = *vlist, *_i96 = vlist; ((scalar *)&v)->i >= 0; v = *++_i96) {
      fprintf (fp,"\t\t\t\t <PDataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"%s\" format=\"ascii\">\n", _attribute[v.x.i].name);
      fputs ("\t\t\t\t </PDataArray>\n", fp);
    }
    fputs ("\t\t\t </PCellData>\n", fp);
    fputs ("\t\t\t <PPoints>\n", fp);
    fputs ("\t\t\t\t <PDataArray type=\"Float64\" NumberOfComponents=\"3\" format=\"ascii\">\n", fp);
    fputs ("\t\t\t\t </PDataArray>\n", fp);
    fputs ("\t\t\t </PPoints>\n", fp);

    for (int i = 0; i < 1; i++)
      fprintf (fp, "<Piece Source=\"%s_n%3.3d.vtu\"/> \n", subname, i);

    fputs ("\t </PUnstructuredGrid>\n", fp);
    fputs ("</VTKFile>\n", fp);
}
# 51 "./../src_local/output_vtu_foreach.h"
void output_vtu_ascii_foreach (scalar * list, vector * vlist, int n, FILE * fp, 
# 51 "./../src_local/output_vtu_foreach.h" 3 4
                                                                               _Bool 
# 51 "./../src_local/output_vtu_foreach.h"
                                                                                    linear, double shift)
{
    int dim = 3; 
# 53 "./../src_local/output_vtu_foreach.h" 3 4
                _Bool 
# 53 "./../src_local/output_vtu_foreach.h"
                     periodic_bc = shift > 0;
    coord Pmin = {X0 + shift - 1e-12, Y0 + shift - 1e-12, Z0 + shift - 1e-12};
 coord Pmax = {X0 + L0 - shift + 1e-12, Y0 + L0 - shift + 1e-12, Z0 + L0 - shift + 1e-12};





  scalar marker= new_vertex_scalar("marker");
  int no_points = 0, no_cells=0 ;
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { x -= Delta/2.; y -= Delta/2.;{
# 63 "./../src_local/output_vtu_foreach.h"
{
    if ((!periodic_bc) || (x - Pmin.x - 0.5*Delta > 0) && (Pmax.x - x - 0.5*Delta > 0) && (y - Pmin.y - 0.5*Delta > 0) && (Pmax.y - y - 0.5*Delta > 0)) {
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[marker.i] = no_points++;
    }else{
   ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[marker.i] = -1;
    }
  } } } } } }; }
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 70 "./../src_local/output_vtu_foreach.h"
{
    if ((!periodic_bc) || (x - Pmin.x - 0.5*Delta > 0) && (Pmax.x - x - 0.5*Delta > 0) && (y - Pmin.y - 0.5*Delta > 0) && (Pmax.y - y - 0.5*Delta > 0)) no_cells += 1;
  } } } } }; }

  fputs ("<?xml version=\"1.0\"?>\n"
  "<VTKFile type=\"UnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\" header_type=\"UInt64\">\n", fp);
  fputs ("\t <UnstructuredGrid>\n", fp);
  fprintf (fp,"\t\t <Piece NumberOfPoints=\"%d\" NumberOfCells=\"%d\">\n", no_points, no_cells);
  fputs ("\t\t\t <CellData Scalars=\"scalars\">\n", fp);
  if (list) for (scalar s = *list, *_i97 = list; ((scalar *)&s)->i >= 0; s = *++_i97) {
    fprintf (fp,"\t\t\t\t <DataArray type=\"Float64\" Name=\"%s\" format=\"ascii\">\n", _attribute[s.i].name);
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 81 "./../src_local/output_vtu_foreach.h"
{
      if ((!periodic_bc) || (x - Pmin.x - 0.5*Delta > 0) && (Pmax.x - x - 0.5*Delta > 0) && (y - Pmin.y - 0.5*Delta > 0) && (Pmax.y - y - 0.5*Delta > 0))
        fprintf (fp, "\t\t\t\t\t %g\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i]);
    } } } } }; }
    fputs ("\t\t\t\t </DataArray>\n", fp);
  }
  if (vlist) for (vector v = *vlist, *_i98 = vlist; ((scalar *)&v)->i >= 0; v = *++_i98) {
    fprintf (fp,"\t\t\t\t <DataArray type=\"Float64\" NumberOfComponents=\"3\" Name=\"%s\" format=\"ascii\">\n", _attribute[v.x.i].name);
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 89 "./../src_local/output_vtu_foreach.h"
{
      if ((!periodic_bc) || (x - Pmin.x - 0.5*Delta > 0) && (Pmax.x - x - 0.5*Delta > 0) && (y - Pmin.y - 0.5*Delta > 0) && (Pmax.y - y - 0.5*Delta > 0))




          fprintf (fp, "\t\t\t\t\t %g %g 0.\n", ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i], ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i]);




    } } } } }; }
    fputs ("\t\t\t\t </DataArray>\n", fp);
  }
  fputs ("\t\t\t </CellData>\n", fp);
  fputs ("\t\t\t <Points>\n", fp);
  fputs ("\t\t\t\t <DataArray type=\"Float64\" NumberOfComponents=\"3\" format=\"ascii\">\n", fp);
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { x -= Delta/2.; y -= Delta/2.;{
# 106 "./../src_local/output_vtu_foreach.h"
{
    if ((!periodic_bc) || (x - Pmin.x - 0.5*Delta > 0) && (Pmax.x - x - 0.5*Delta > 0) && (y - Pmin.y - 0.5*Delta > 0) && (Pmax.y - y - 0.5*Delta > 0))




      fprintf (fp, "\t\t\t\t\t %g %g %g\n", x, y, z);




  } } } } } }; }
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t </Points>\n", fp);
  fputs ("\t\t\t <Cells>\n", fp);
  fputs ("\t\t\t\t <DataArray type=\"Int64\" Name=\"connectivity\" format=\"ascii\">\n", fp);
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 122 "./../src_local/output_vtu_foreach.h"
{
    if ((!periodic_bc) || (x - Pmin.x - 0.5*Delta > 0) && (Pmax.x - x - 0.5*Delta > 0) && (y - Pmin.y - 0.5*Delta > 0) && (Pmax.y - y - 0.5*Delta > 0))




      fprintf (fp, "\t\t\t\t\t %d %d %d %d \n", (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[marker.i], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[marker.i], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[marker.i], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[marker.i]);




  } } } } }; }
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t\t <DataArray type=\"Int64\" Name=\"offsets\" format=\"ascii\">\n", fp);

  for (int i = 1; i < no_cells+1; i++){

    fprintf (fp, "\t\t\t\t\t %d \n", i*4);




  }
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t\t <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">\n", fp);
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 147 "./../src_local/output_vtu_foreach.h"
{
    if ((!periodic_bc) || (x - Pmin.x - 0.5*Delta > 0) && (Pmax.x - x - 0.5*Delta > 0) && (y - Pmin.y - 0.5*Delta > 0) && (Pmax.y - y - 0.5*Delta > 0))




      fputs ("\t\t\t\t\t 9 \n", fp);




  } } } } }; }
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t </Cells>\n", fp);
  fputs ("\t\t </Piece>\n", fp);
  fputs ("\t </UnstructuredGrid>\n", fp);
  fputs ("</VTKFile>\n", fp);
  fflush (fp);



 delete (((scalar []){marker,{-1}})); }






void output_pvtu_bin (scalar * list, vector * vlist, int n, FILE * fp, char * subname)
{
    int dim = 3;
    fputs ("<?xml version=\"1.0\"?>\n"
    "<VTKFile type=\"PUnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\" header_type=\"UInt64\">\n", fp);
    fputs ("\t <PUnstructuredGrid GhostLevel=\"0\">\n", fp);
    fputs ("\t\t\t <PCellData Scalars=\"scalars\">\n", fp);
    if (list) for (scalar s = *list, *_i99 = list; ((scalar *)&s)->i >= 0; s = *++_i99) {
      fprintf (fp,"\t\t\t\t <PDataArray type=\"Float64\" Name=\"%s\" format=\"appended\"/>\n", _attribute[s.i].name);
    }
    if (vlist) for (vector v = *vlist, *_i100 = vlist; ((scalar *)&v)->i >= 0; v = *++_i100) {
      fprintf (fp,"\t\t\t\t <PDataArray type=\"Float64\" NumberOfComponents=\"%d\" Name=\"%s\" format=\"appended\"/>\n", dim, _attribute[v.x.i].name);
    }
    fputs ("\t\t\t </PCellData>\n", fp);
    fputs ("\t\t\t <PPoints>\n", fp);
    fprintf (fp,"\t\t\t\t <PDataArray type=\"Float64\" NumberOfComponents=\"%d\" format=\"ascii\"/>\n", dim);
    fputs ("\t\t\t </PPoints>\n", fp);

    for (int i = 0; i < 1; i++)
      fprintf (fp, "<Piece Source=\"%s_n%3.3d.vtu\"/> \n", subname, i);

    fputs ("\t </PUnstructuredGrid>\n", fp);
    fputs ("</VTKFile>\n", fp);
}
# 209 "./../src_local/output_vtu_foreach.h"
void output_vtu_bin_foreach (scalar * list, vector * vlist, int n, FILE * fp, 
# 209 "./../src_local/output_vtu_foreach.h" 3 4
                                                                             _Bool 
# 209 "./../src_local/output_vtu_foreach.h"
                                                                                  linear, double shift)
{
  int dim = 3; 
# 211 "./../src_local/output_vtu_foreach.h" 3 4
              _Bool 
# 211 "./../src_local/output_vtu_foreach.h"
                   periodic_bc = shift > 0;
  coord Pmin = {X0 + 1e-12, Y0 + 1e-12, Z0 + 1e-12};
  coord Pmax = {X0 + L0 - 1e-12, Y0 + L0 - 1e-12, Z0 + L0 - 1e-12};






  scalar marker= new_vertex_scalar("marker");
  int no_points = 0, no_cells = 0;
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { x -= Delta/2.; y -= Delta/2.;{
# 222 "./../src_local/output_vtu_foreach.h"
{
    if ((!periodic_bc) || (x - Pmin.x - 0.5*Delta > 0) && (Pmax.x - x - 0.5*Delta > 0) && (y - Pmin.y - 0.5*Delta > 0) && (Pmax.y - y - 0.5*Delta > 0)) {
      ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[marker.i] = no_points++;
    }else{
     ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[marker.i] = -1;
    }
  } } } } } }; }
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 229 "./../src_local/output_vtu_foreach.h"
{
    if ((!periodic_bc) || (x - Pmin.x - 0.5*Delta > 0) && (Pmax.x - x - 0.5*Delta > 0) && (y - Pmin.y - 0.5*Delta > 0) && (Pmax.y - y - 0.5*Delta > 0)) no_cells++;
  } } } } }; }
  fputs ("<?xml version=\"1.0\"?>\n"
  "<VTKFile type=\"UnstructuredGrid\" version=\"1.0\" byte_order=\"LittleEndian\" header_type=\"UInt64\">\n", fp);
  fputs ("\t <UnstructuredGrid>\n", fp);
  fprintf (fp,"\t\t <Piece NumberOfPoints=\"%d\" NumberOfCells=\"%d\">\n", no_points, no_cells);
  fputs ("\t\t\t <CellData Scalars=\"scalars\">\n", fp);
  int count = 0;
  if (list) for (scalar s = *list, *_i101 = list; ((scalar *)&s)->i >= 0; s = *++_i101) {
    fprintf (fp,"\t\t\t\t <DataArray type=\"Float64\" Name=\"%s\" format=\"appended\" offset=\"%d\">\n", _attribute[s.i].name,count);
    count += ((no_cells)+1)*8;
    fputs ("\t\t\t\t </DataArray>\n", fp);
  }
  if (vlist) for (vector v = *vlist, *_i102 = vlist; ((scalar *)&v)->i >= 0; v = *++_i102) {
    fprintf (fp,"\t\t\t\t <DataArray type=\"Float64\" Name=\"%s\" NumberOfComponents=\"%d\"  format=\"appended\" offset=\"%d\">\n", _attribute[v.x.i].name, dim, count);
    count += (no_cells*dim+1)*8;
    fputs ("\t\t\t\t </DataArray>\n", fp);
  }
  fputs ("\t\t\t </CellData>\n", fp);
  fputs ("\t\t\t <Points>\n", fp);
  fprintf (fp,"\t\t\t\t <DataArray type=\"Float64\" NumberOfComponents=\"%d\"  format=\"appended\" offset=\"%d\">\n", dim, count);
  count += (no_points*dim+1)*8;
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t </Points>\n", fp);
  fputs ("\t\t\t <Cells>\n", fp);
  fputs ("\t\t\t\t <DataArray type=\"Int64\" Name=\"connectivity\" format=\"ascii\">\n", fp);
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 256 "./../src_local/output_vtu_foreach.h"
{
    if ((!periodic_bc) || (x - Pmin.x - 0.5*Delta > 0) && (Pmax.x - x - 0.5*Delta > 0) && (y - Pmin.y - 0.5*Delta > 0) && (Pmax.y - y - 0.5*Delta > 0)) {




     fprintf (fp, "\t\t\t\t\t %d %d %d %d \n", (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[marker.i], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[marker.i], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+1]) + sizeof(Cell)))[marker.i], (int)((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[marker.i]);




    }
  } } } } }; }
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t\t <DataArray type=\"Int64\" Name=\"offsets\" format=\"ascii\">\n", fp);
  for (int i = 1; i < no_cells+1; i++){




    fprintf (fp, "%d \n", i*4);




  }
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t\t <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">\n", fp);
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 284 "./../src_local/output_vtu_foreach.h"
{
    if ((!periodic_bc) || (x - Pmin.x - 0.5*Delta > 0) && (Pmax.x - x - 0.5*Delta > 0) && (y - Pmin.y - 0.5*Delta > 0) && (Pmax.y - y - 0.5*Delta > 0))




      fputs ("9 \n", fp);




  } } } } }; }
  fputs ("\t\t\t\t </DataArray>\n", fp);
  fputs ("\t\t\t </Cells>\n", fp);
  fputs ("\t\t </Piece>\n", fp);
  fputs ("\t </UnstructuredGrid>\n", fp);
  fputs ("\t <AppendedData encoding=\"raw\">\n", fp);
  fputs ("_", fp);
  unsigned long long block_len=no_cells*8;





  double z=0, vz=0;

  if (list) for (scalar s = *list, *_i103 = list; ((scalar *)&s)->i >= 0; s = *++_i103) {
    fwrite (&block_len, sizeof (unsigned long long), 1, fp);
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 312 "./../src_local/output_vtu_foreach.h"

      if ((!periodic_bc) || (x - Pmin.x - 0.5*Delta > 0) && (Pmax.x - x - 0.5*Delta > 0) && (y - Pmin.y - 0.5*Delta > 0) && (Pmax.y - y - 0.5*Delta > 0))
        fwrite (&((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[s.i], sizeof (double), 1, fp); } } } }; }
  }
  block_len=no_cells*8*dim;
  if (vlist) for (vector v = *vlist, *_i104 = vlist; ((scalar *)&v)->i >= 0; v = *++_i104) {
    fwrite (&block_len, sizeof (unsigned long long), 1, fp);
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 319 "./../src_local/output_vtu_foreach.h"
{
      if ((!periodic_bc) || (x - Pmin.x - 0.5*Delta > 0) && (Pmax.x - x - 0.5*Delta > 0) && (y - Pmin.y - 0.5*Delta > 0) && (Pmax.y - y - 0.5*Delta > 0)){






        fwrite (&((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.x.i], sizeof (double), 1, fp);
        fwrite (&((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[v.y.i], sizeof (double), 1, fp);
        fwrite (&vz, sizeof (double), 1, fp);




      }
    } } } } }; }
  }
  block_len=no_points*8*dim;
  fwrite (&block_len, sizeof (unsigned long long), 1, fp);
   { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { x -= Delta/2.; y -= Delta/2.;{
# 339 "./../src_local/output_vtu_foreach.h"
{
    if ((!periodic_bc) || (x - Pmin.x - 0.5*Delta > 0) && (Pmax.x - x - 0.5*Delta > 0) && (y - Pmin.y - 0.5*Delta > 0) && (Pmax.y - y - 0.5*Delta > 0)){
      fwrite (&x, sizeof (double), 1, fp);
      fwrite (&y, sizeof (double), 1, fp);
      fwrite (&z, sizeof (double), 1, fp);
    }
  } } } } } }; }
  fputs ("\t\n", fp);
  fputs ("\t </AppendedData>\n", fp);
  fputs ("</VTKFile>\n", fp);
  fflush (fp);



 delete (((scalar []){marker,{-1}})); }



static int iter_fp=0;
void output_vtu_MPI(scalar * list, vector * vlist, char * subname, double shift){
    int nf = iter_fp;
    char name_vtu[80];
    FILE *fp;
    if (nf>9999) { fprintf(
# 362 "./../src_local/output_vtu_foreach.h" 3 4
                          __stderrp
# 362 "./../src_local/output_vtu_foreach.h"
                                   , "too many files, more than 9999"); exit(1); }
    
# 363 "./../src_local/output_vtu_foreach.h" 3 4
   __builtin___sprintf_chk (
# 363 "./../src_local/output_vtu_foreach.h"
   name_vtu
# 363 "./../src_local/output_vtu_foreach.h" 3 4
   , 0, __builtin_object_size (
# 363 "./../src_local/output_vtu_foreach.h"
   name_vtu
# 363 "./../src_local/output_vtu_foreach.h" 3 4
   , 2 > 1 ? 1 : 0), 
# 363 "./../src_local/output_vtu_foreach.h"
   "%s_%4.4d_n%3.3d.vtu", subname, nf, 0
# 363 "./../src_local/output_vtu_foreach.h" 3 4
   )
# 363 "./../src_local/output_vtu_foreach.h"
                                                               ;
    fp = fopen(name_vtu, "w");
    output_vtu_bin_foreach(list, vlist, 64, fp, 
# 365 "./../src_local/output_vtu_foreach.h" 3 4
                                               1
# 365 "./../src_local/output_vtu_foreach.h"
                                                   , shift);
    fclose(fp);
    if (0 == 0) {
        char name_pvtu[80], tmp[80];
     
# 369 "./../src_local/output_vtu_foreach.h" 3 4
    __builtin___sprintf_chk (
# 369 "./../src_local/output_vtu_foreach.h"
    name_pvtu
# 369 "./../src_local/output_vtu_foreach.h" 3 4
    , 0, __builtin_object_size (
# 369 "./../src_local/output_vtu_foreach.h"
    name_pvtu
# 369 "./../src_local/output_vtu_foreach.h" 3 4
    , 2 > 1 ? 1 : 0), 
# 369 "./../src_local/output_vtu_foreach.h"
    "%s_%4.4d.pvtu", subname, nf
# 369 "./../src_local/output_vtu_foreach.h" 3 4
    )
# 369 "./../src_local/output_vtu_foreach.h"
                                                    ;
        
# 370 "./../src_local/output_vtu_foreach.h" 3 4
       __builtin___sprintf_chk (
# 370 "./../src_local/output_vtu_foreach.h"
       tmp
# 370 "./../src_local/output_vtu_foreach.h" 3 4
       , 0, __builtin_object_size (
# 370 "./../src_local/output_vtu_foreach.h"
       tmp
# 370 "./../src_local/output_vtu_foreach.h" 3 4
       , 2 > 1 ? 1 : 0), 
# 370 "./../src_local/output_vtu_foreach.h"
       "%s_%4.4d", subname, nf
# 370 "./../src_local/output_vtu_foreach.h" 3 4
       )
# 370 "./../src_local/output_vtu_foreach.h"
                                            ;
        fp = fopen(name_pvtu, "w");
        output_pvtu_bin(list, vlist, 64, fp, tmp);
        fclose(fp);
    }




    fprintf (
# 379 "./../src_local/output_vtu_foreach.h" 3 4
            __stderrp
# 379 "./../src_local/output_vtu_foreach.h"
                , "iter_fp: %d t=%g dt=%g\n", nf, t, dt);

    iter_fp++;
}


void face_vector2vector(vector fv, vector mapped_data_lower, vector mapped_data_upper){



     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 389 "./../src_local/output_vtu_foreach.h"

    {
# 390 "./../src_local/output_vtu_foreach.h"
{
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mapped_data_lower.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fv.x.i];
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mapped_data_upper.x.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[fv.x.i];
    }
# 390 "./../src_local/output_vtu_foreach.h"
{
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mapped_data_lower.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fv.y.i];
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[mapped_data_upper.y.i] = ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[fv.y.i];
    }} } } } }; }
}
# 9 "karman_GI.c"

int maxlevel = 9;
int minlevel = 4;
double xx0 = 0, rad = 0.0625;
coord vc = {0.01, 0.0, 0.0};
scalar fs= {16}, omega= {17};
# 34 "karman_GI.c"
int main(int argc, char * argv[])
{ _init_solver();
 if (argc > 1) {
  maxlevel = atoi(argv[2]);
 }
 size (8.0);
 origin ((struct _origin){-0.5, -L0/2.});
 eta_s = 1e-10;


 N = 512;
    vector muc= new_const_vector("muc", 9, (double []) {0.00078125,0.00078125});
    mu = muc;
    vector U_wall= new_const_vector("U_wall", 11, (double []) {0.01, 0});
    target_U = U_wall;
 run();
 free_solver(); }

scalar divu= {18};
void soild_fs(scalar fs, double t){
 do { scalar phi= new_vertex_scalar("phi"); { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->vertices.n; _k++) { point.i = ((Tree *)grid)->vertices.p[_k].i; point.j = ((Tree *)grid)->vertices.p[_k].j; point.level = ((Tree *)grid)->vertices.p[_k].level; _flags = ((Tree *)grid)->vertices.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;; { x -= Delta/2.; y -= Delta/2.;{
# 54 "karman_GI.c"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[phi.i] = ((rad)*(rad)) - ((x - xx0 - vc.x*t)*(x - xx0 - vc.x*t)) - ((y - vc.y*t)*(y - vc.y*t)); } } } } }; } boundary (((scalar []){phi,{-1}})); fractions ((struct Fractions){phi, fs}); delete (((scalar []){phi,{-1}})); } while(0);
    _attribute[fs.i].refine = _attribute[fs.i].prolongation = fraction_refine;
    boundary(((scalar []){fs,{-1}}));
}
static int init_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (t = 0); *ip = i; *tp = t; return ret; } static int init_0 (const int i, const double t, Event * _ev) { ; {
    if (!restore ((struct Dump){.file = "restart"})) {
        int it = 0;
        do {
            soild_fs (fs, 0);

        }while (adapt_wavelet((struct Adapt){((scalar []){fs,{-1}}), (double []){1e-3}, .maxlevel=maxlevel, .minlevel=minlevel}).nf != 0 && ++it <= 10);
    }
 ; } return 0; }





static int moving_cylinder_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int moving_cylinder (const int i, const double t, Event * _ev) { ; {
    soild_fs(fs, t);


 ; } return 0; }

static int logfile_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int logfile (const int i, const double t, Event * _ev) { ; {
     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 79 "karman_GI.c"
 {
        ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[divu.i] = 0;
        {
# 81 "karman_GI.c"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[divu.i] += (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+1][point.j+0]) + sizeof(Cell)))[uf.x.i]-((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.x.i])/Delta;
# 81 "karman_GI.c"
 ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[divu.i] += (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+1]) + sizeof(Cell)))[uf.y.i]-((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[uf.y.i])/Delta;}
    } } } } }; }
    double Linfu = -10;
     {


 {
double _Linfu = Linfu;
# 84 "karman_GI.c"
{ if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 84 "karman_GI.c"
{
        if (fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[divu.i]) > _Linfu) _Linfu = fabs(((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[divu.i]);
    } } } } }; if (_Linfu > Linfu) Linfu = _Linfu;
;



}
# 86 "karman_GI.c"
 }
    fprintf (
# 87 "karman_GI.c" 3 4
            __stderrp
# 87 "karman_GI.c"
                , "i=%d t=%g dt=%g iter_p=%d iter_u=%d div u=%g \n", i, t, dt, mgp.i, mgu.i, Linfu);
 ; } return 0; }
# 107 "karman_GI.c"
static int vtk_file_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i += 1); *ip = i; *tp = t; return ret; } static int vtk_file_0 (const int i, const double t, Event * _ev) { ; {
    char subname[80]; 
# 108 "karman_GI.c" 3 4
                     __builtin___sprintf_chk (
# 108 "karman_GI.c"
                     subname
# 108 "karman_GI.c" 3 4
                     , 0, __builtin_object_size (
# 108 "karman_GI.c"
                     subname
# 108 "karman_GI.c" 3 4
                     , 2 > 1 ? 1 : 0), 
# 108 "karman_GI.c"
                     "rk"
# 108 "karman_GI.c" 3 4
                     )
# 108 "karman_GI.c"
                                           ;
    scalar l= new_scalar("l");

     { { if (((Tree *)grid)->dirty) update_cache_f(); }; { { int ig = 0, jg = 0, kg = 0; (void)(ig); (void)(jg); (void)(kg); Point point = {2,2,0}; int _k; unsigned short _flags; (void)(_flags); for (_k = 0; _k < ((Tree *)grid)->leaves.n; _k++) { point.i = ((Tree *)grid)->leaves.p[_k].i; point.j = ((Tree *)grid)->leaves.p[_k].j; point.level = ((Tree *)grid)->leaves.p[_k].level; _flags = ((Tree *)grid)->leaves.p[_k].flags; double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;{
# 111 "karman_GI.c"
 {((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[l.i] = level; ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[omega.i] *= 1 - ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fs.i];} } } } }; }
    output_vtu_MPI( (scalar *) ((scalar []){fs,omega,p,l,divu,{-1}}), (vector *) ((vector []){{u.x,u.y},{dbp.x,dbp.y},{total_rhs.x,total_rhs.y},{{-1},{-1}}}), subname, 0 );
 delete (((scalar []){l,{-1}})); ; } return 0; }



static int adapt_0_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i++); *ip = i; *tp = t; return ret; } static int adapt_0 (const int i, const double t, Event * _ev) { ; {
 double eps_arr[] = {1e-3, 3e-2, 3e-2};

 adapt_wavelet ((struct Adapt){(scalar *) ((scalar []){fs,u.x,u.y,{-1}}), eps_arr, .maxlevel = maxlevel, .minlevel = minlevel});
 ; } return 0; }

static int stop_expr0 (int * ip, double * tp, Event * _ev) { int i = *ip; double t = *tp; int ret = (i = 5); *ip = i; *tp = t; return ret; } static int stop (const int i, const double t, Event * _ev) { ; ; ; return 0; }
# 103 "./../src_local/centered-weugene.h"
static double _boundary0 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 102 "./../src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 103 "./../src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[a.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[fm.x.i]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[alpha.x.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 103 "./../src_local/centered-weugene.h"
return (Delta*((_const_a.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[fm.x.i]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[alpha.x.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 117 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 103 "./../src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[a.x.i]*_const_fm.x/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[alpha.x.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 119 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 103 "./../src_local/centered-weugene.h"
return (Delta*((_const_a.x*_const_fm.x/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[alpha.x.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 129 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 103 "./../src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[a.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[fm.x.i]/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 131 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 103 "./../src_local/centered-weugene.h"
return (Delta*((_const_a.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[fm.x.i]/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 117 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 131 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 103 "./../src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[a.x.i]*_const_fm.x/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 119 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 133 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 103 "./../src_local/centered-weugene.h"
return (Delta*((_const_a.x*_const_fm.x/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); } return 0.; } static double _boundary0_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 102 "./../src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 103 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 103 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 117 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 103 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 119 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 103 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 129 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 103 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 131 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 103 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 117 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 131 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 103 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 119 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 133 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 103 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); } return 0.; }
# 104 "./../src_local/centered-weugene.h"
static double _boundary1 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 103 "./../src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 104 "./../src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.x.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 104 "./../src_local/centered-weugene.h"
return (Delta*(- (_const_a.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.x.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 118 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 104 "./../src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.x.i]*_const_fm.x/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.x.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 120 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 104 "./../src_local/centered-weugene.h"
return (Delta*(- (_const_a.x*_const_fm.x/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.x.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 130 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 104 "./../src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.x.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i]/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 132 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 104 "./../src_local/centered-weugene.h"
return (Delta*(- (_const_a.x*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.x.i]/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 118 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 132 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 104 "./../src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.x.i]*_const_fm.x/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 120 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 134 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 104 "./../src_local/centered-weugene.h"
return (Delta*(- (_const_a.x*_const_fm.x/_const_alpha.x)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); } return 0.; } static double _boundary1_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 103 "./../src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 104 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 104 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 118 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 104 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 120 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 104 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 130 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 104 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 132 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 104 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 118 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 132 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 104 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 120 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 134 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 104 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); } return 0.; }
# 113 "./../src_local/centered-weugene.h"
static double _boundary2 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 112 "./../src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 113 "./../src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[a.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[fm.y.i]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[alpha.y.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 113 "./../src_local/centered-weugene.h"
return (Delta*((_const_a.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[fm.y.i]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[alpha.y.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 127 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 113 "./../src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[a.y.i]*_const_fm.y/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[alpha.y.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 129 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 113 "./../src_local/centered-weugene.h"
return (Delta*((_const_a.y*_const_fm.y/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[alpha.y.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 139 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 113 "./../src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[a.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[fm.y.i]/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 141 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 113 "./../src_local/centered-weugene.h"
return (Delta*((_const_a.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[fm.y.i]/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 127 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 141 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 113 "./../src_local/centered-weugene.h"
return (Delta*((((double *) ((((Tree *)grid)->L[point.level]->m[point.i+(ig > 0 ? 1 : ig < 0 ? -1 : 0)][point.j+(jg > 0 ? 1 : jg < 0 ? -1 : 0)]) + sizeof(Cell)))[a.y.i]*_const_fm.y/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 129 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 143 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 113 "./../src_local/centered-weugene.h"
return (Delta*((_const_a.y*_const_fm.y/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); } return 0.; } static double _boundary2_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 112 "./../src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 113 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 113 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 127 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 113 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 129 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 113 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 139 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 113 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 141 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 113 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 127 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 141 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 113 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 129 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 143 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 113 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); } return 0.; }
# 114 "./../src_local/centered-weugene.h"
static double _boundary3 (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 113 "./../src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 114 "./../src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.y.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 114 "./../src_local/centered-weugene.h"
return (Delta*(- (_const_a.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i]/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.y.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 128 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 114 "./../src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.y.i]*_const_fm.y/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.y.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 130 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 114 "./../src_local/centered-weugene.h"
return (Delta*(- (_const_a.y*_const_fm.y/((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[alpha.y.i])) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 140 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 114 "./../src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.y.i]*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i]/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 142 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 114 "./../src_local/centered-weugene.h"
return (Delta*(- (_const_a.y*((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[fm.y.i]/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 128 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 142 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 114 "./../src_local/centered-weugene.h"
return (Delta*(- (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[a.y.i]*_const_fm.y/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 130 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 144 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 114 "./../src_local/centered-weugene.h"
return (Delta*(- (_const_a.y*_const_fm.y/_const_alpha.y)) + ((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); } return 0.; } static double _boundary3_homogeneous (Point point, Point neighbor, scalar _s, void * data) { int ig = neighbor.i - point.i; if (ig == 0) ig = _attribute[_s.i].d.x; (void)(ig); int jg = neighbor.j - point.j; if (jg == 0) jg = _attribute[_s.i].d.y; (void)(jg); double Delta = L0*(1./(1 << point.level)); double Delta_x = Delta; double Delta_y = Delta; double x = (ig/2. + (point.i - 2) + 0.5)*Delta + X0; (void)(x); double y = (jg/2. + (point.j - 2) + 0.5)*Delta + Y0; (void)(y); double z = 0.; (void)(z); (void)(Delta); (void)(Delta_x); (void)(Delta_y); ; int level = point.level; (void)(level); struct { int x, y; } child = { 2*((point.i+2)%2)-1, 2*((point.j+2)%2)-1 }; (void)(child); Point parent = point; (void)(parent); parent.level--; parent.i = (point.i + 2)/2; parent.j = (point.j + 2)/2;;
# 113 "./../src_local/centered-weugene.h"

if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 114 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 114 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
# 128 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 114 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && !((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 130 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 114 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 140 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 114 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && !((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 142 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 114 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (!((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
# 128 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 142 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 114 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); }
if (((a.x).i >= 65536) && ((fm.x).i >= 65536) && ((alpha.x).i >= 65536)) {
const struct { double x, y; } _const_a = {_constant[a.x.i -65536], _constant[a.y.i - 65536]};
(void)(_const_a);
# 130 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_fm = {_constant[fm.x.i -65536], _constant[fm.y.i - 65536]};
(void)(_const_fm);
# 144 "./../src_local/centered-weugene.h"
const struct { double x, y; } _const_alpha = {_constant[alpha.x.i -65536], _constant[alpha.y.i - 65536]};
(void)(_const_alpha);
# 114 "./../src_local/centered-weugene.h"
return (((double *) ((((Tree *)grid)->L[point.level]->m[point.i+0][point.j+0]) + sizeof(Cell)))[_s.i]); } return 0.; }
size_t datasize = 19*sizeof (double);
static int defaults (const int i, const double t, Event * _ev);
static int defaults_expr0 (int * ip, double * tp, Event * _ev);
static int init (const int i, const double t, Event * _ev);
static int init_expr0 (int * ip, double * tp, Event * _ev);
static int set_dtmax (const int i, const double t, Event * _ev);
static int set_dtmax_expr0 (int * ip, double * tp, Event * _ev);
static int stability (const int i, const double t, Event * _ev);
static int stability_expr0 (int * ip, double * tp, Event * _ev);
static int vof (const int i, const double t, Event * _ev);
static int vof_expr0 (int * ip, double * tp, Event * _ev);
static int tracer_advection (const int i, const double t, Event * _ev);
static int tracer_advection_expr0 (int * ip, double * tp, Event * _ev);
static int properties (const int i, const double t, Event * _ev);
static int properties_expr0 (int * ip, double * tp, Event * _ev);
static int tracer_diffusion (const int i, const double t, Event * _ev);
static int tracer_diffusion_expr0 (int * ip, double * tp, Event * _ev);
static int advection_term (const int i, const double t, Event * _ev);
static int advection_term_expr0 (int * ip, double * tp, Event * _ev);
static int viscous_term (const int i, const double t, Event * _ev);
static int viscous_term_expr0 (int * ip, double * tp, Event * _ev);
static int acceleration (const int i, const double t, Event * _ev);
static int acceleration_expr0 (int * ip, double * tp, Event * _ev);
static int projection (const int i, const double t, Event * _ev);
static int projection_expr0 (int * ip, double * tp, Event * _ev);
static int brinkman_penalization (const int i, const double t, Event * _ev);
static int brinkman_penalization_expr0 (int * ip, double * tp, Event * _ev);
static int end_timestep (const int i, const double t, Event * _ev);
static int end_timestep_expr0 (int * ip, double * tp, Event * _ev);
static int vtk_file (const int i, const double t, Event * _ev);
static int vtk_file_expr0 (int * ip, double * tp, Event * _ev);
static int adapt (const int i, const double t, Event * _ev);
static int adapt_expr0 (int * ip, double * tp, Event * _ev);
static int init_0 (const int i, const double t, Event * _ev);
static int init_0_expr0 (int * ip, double * tp, Event * _ev);
static int moving_cylinder (const int i, const double t, Event * _ev);
static int moving_cylinder_expr0 (int * ip, double * tp, Event * _ev);
static int logfile (const int i, const double t, Event * _ev);
static int logfile_expr0 (int * ip, double * tp, Event * _ev);
static int vtk_file_0 (const int i, const double t, Event * _ev);
static int vtk_file_0_expr0 (int * ip, double * tp, Event * _ev);
static int adapt_0 (const int i, const double t, Event * _ev);
static int adapt_0_expr0 (int * ip, double * tp, Event * _ev);
static int stop (const int i, const double t, Event * _ev);
static int stop_expr0 (int * ip, double * tp, Event * _ev);
static void _set_boundary0 (void);
static void _set_boundary1 (void);
static void _set_boundary2 (void);
static void _set_boundary3 (void);
void _init_solver (void) {
  void init_solver();
  init_solver();
  Events = (Event *) malloc(sizeof (Event));
  Events[0].last = 1;
  event_register ((Event){ 0, 1, defaults, {defaults_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 138, "defaults"});
  event_register ((Event){ 0, 1, init, {init_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 193, "init"});
  event_register ((Event){ 0, 1, init_0, {init_0_expr0}, ((int *)0), ((double *)0),
    "karman_GI.c", 58, "init"});
  event_register ((Event){ 0, 1, moving_cylinder, {moving_cylinder_expr0}, ((int *)0), ((double *)0),
    "karman_GI.c", 72, "moving_cylinder"});
  event_register ((Event){ 0, 1, logfile, {logfile_expr0}, ((int *)0), ((double *)0),
    "karman_GI.c", 78, "logfile"});
  event_register ((Event){ 0, 1, stop, {stop_expr0}, ((int *)0), ((double *)0),
    "karman_GI.c", 123, "stop"});
  event_register ((Event){ 0, 1, set_dtmax, {set_dtmax_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 221, "set_dtmax"});
  event_register ((Event){ 0, 1, stability, {stability_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 223, "stability"});
  event_register ((Event){ 0, 1, vof, {vof_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 233, "vof"});
  event_register ((Event){ 0, 1, tracer_advection, {tracer_advection_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 234, "tracer_advection"});
  event_register ((Event){ 0, 1, properties, {properties_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 241, "properties"});
  event_register ((Event){ 0, 1, tracer_diffusion, {tracer_diffusion_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 245, "tracer_diffusion"});
  event_register ((Event){ 0, 1, advection_term, {advection_term_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 320, "advection_term"});
  event_register ((Event){ 0, 1, viscous_term, {viscous_term_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 350, "viscous_term"});
  event_register ((Event){ 0, 1, acceleration, {acceleration_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 386, "acceleration"});
  event_register ((Event){ 0, 1, projection, {projection_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 429, "projection"});
  event_register ((Event){ 0, 1, brinkman_penalization, {brinkman_penalization_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 441, "brinkman_penalization"});
  event_register ((Event){ 0, 1, end_timestep, {end_timestep_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 449, "end_timestep"});
  event_register ((Event){ 0, 1, vtk_file, {vtk_file_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 454, "vtk_file"});
  event_register ((Event){ 0, 1, vtk_file_0, {vtk_file_0_expr0}, ((int *)0), ((double *)0),
    "karman_GI.c", 107, "vtk_file"});
  event_register ((Event){ 0, 1, adapt, {adapt_expr0}, ((int *)0), ((double *)0),
    "./../src_local/centered-weugene.h", 463, "adapt"});
  event_register ((Event){ 0, 1, adapt_0, {adapt_0_expr0}, ((int *)0), ((double *)0),
    "karman_GI.c", 117, "adapt"});
  _attribute = (_Attributes *) calloc(datasize/sizeof(double),sizeof (_Attributes));
  all = (scalar *) malloc(sizeof (scalar)*20);
  for (int i = 0; i < 19; i++)
    all[i].i = i;
  all[19].i = -1;
  set_fpe();
  quadtree_methods();
  init_scalar ((scalar){18}, "divu");
  init_scalar ((scalar){17}, "omega");
  init_scalar ((scalar){16}, "fs");
  init_face_vector ((vector){{14},{15}}, "uf");
  init_scalar ((scalar){13}, "pf");
  init_vector ((vector){{11},{12}}, "g");
  init_vector ((vector){{9},{10}}, "u");
  init_scalar ((scalar){8}, "p");
  init_vector ((vector){{6},{7}}, "grad_utau_n");
  init_vector ((vector){{4},{5}}, "utau");
  init_vector ((vector){{2},{3}}, "total_rhs");
  init_vector ((vector){{0},{1}}, "dbp");
  init_const_vector ((vector){{65536 +7},{65536 +8}}, "zerocf", (double []) {0.,0.,0.});
  init_const_scalar ((scalar){65536 +5}, "zeroc", 0.);
  init_const_scalar ((scalar){65536 +4}, "unity", 1.);
  init_const_vector ((vector){{65536 +2},{65536 +3}}, "unityf", (double []) {1.,1.,1.});
  init_const_vector ((vector){{65536 +0},{65536 +1}}, "zerof", (double []) {0.,0.,0.});
  _set_boundary0();
  _set_boundary1();
  _set_boundary2();
  _set_boundary3();
}
