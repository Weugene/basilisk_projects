/**
# Atomisation of a pulsed liquid jet onto a cylinder surface

A dense cylindrical liquid jet is injected into a stagnant lighter
phase (density ratio 1/27.84) with a cylinder solid obstacle. The inflow velocity is modulated
sinusoidally to promote the growth of primary shear
instabilities. Surface tension is included and ultimately controls the
characteristic scale of the smallest droplets.

We solve the two-phase Navier--Stokes equations with surface
tension.

 Brinkman Penalization method (BPM) is used to handle solids. To switch on BPM, BRINKMAN_PENALIZATION defined,
 to see/output debug fields (penalization term - dbp, total right-hand-side - total_rhs,
 tangential (along the solid surface) component of the velocity - utau (NEED CALCULATION of the normal to the solid surface n_sol),
 grad_utau_n(NEED n_sol)), DEBUG_BRINKMAN_PENALIZATION is defined.

 Default solid velocity target_U is equal to 0.
 Penalization coefficient eta_s = 1e-15.
 fs is a mask field: 1 inside solid, 0 outside.

 */
#define BRINKMAN_PENALIZATION 1
#define DEBUG_BRINKMAN_PENALIZATION 1
//#include "grid/octree.h"
#include "../src_local/centered-weugene.h"
#include "two-phase.h"
#include "tension.h"
#include "tag.h"
#include "view.h"
#include "../src_local/output_vtu_foreach.h"

/**
We define the radius of the jet, the initial jet length, the Reynolds
number and the surface tension coefficient. */

#define radius 1./12.
#define Rsolid 1
#define length 0.025
#define Re 5800
#define SIGMA 1e-4
/**
The default maximum level of refinement is 10 and the error threshold
on velocity is 0.1. */

int minlevel = 5;
int maxlevel = 10;
double uemax = 0.1;
static int iteration=0;
/**
To impose boundary conditions on a disk we use an auxilliary volume
fraction field *f* which is one inside the cylinder and zero
outside. We then set an oscillating inflow velocity on the
left-hand-side and free outflow on the right-hand-side. */

scalar f0[], fs[], omega[];
u.n[left]  = dirichlet(f0[]*(1. + 0.05*sin (10.*2.*pi*t)));
u.t[left]  = dirichlet(0);
#if dimension > 2
u.r[left]  = dirichlet(0);
#endif
p[left]    = neumann(0);
f[left]    = f0[];

u.n[right] = neumann(0);
u.t[right] = neumann(0);
p[right]   = dirichlet(0);

u.n[bottom] = neumann(0);
u.t[bottom] = neumann(0);
p[bottom]   = neumann(0);

u.n[top] = neumann(0);
u.t[top] = neumann(0);
p[top]   = neumann(0);
/**
The program can take two optional command-line arguments: the maximum
level and the error threshold on velocity. */

int main (int argc, char * argv[])
{
    if (argc > 1) maxlevel = atoi (argv[1]);
    if (argc > 2) uemax = atof (argv[2]);

    /**
    The initial domain is discretised with $64^3$ grid points. We set
    the origin and domain size. */
    eta_s = 1e-15;
    init_grid (64);
    origin (0, -1.5, -1.5);
    size (3.);

    /**
    We set the density and viscosity of each phase as well as the
    surface tension coefficient and start the simulation. */

    rho1 = 1., rho2 = 1./27.84;
    mu1 = 2.*radius/Re*rho1, mu2 = 2.*radius/Re*rho2;
    f.sigma = SIGMA;
    f0.refine = f0.prolongation = fraction_refine;
    run();
}

/**
## Initial conditions */

event init (t = 0) {

  if (!restore (file = "restart")) {

    /**
    We use a static refinement down to *maxlevel* in a cylinder 1.2
    times longer than the initial jet and twice the radius.
    We initialise the auxilliary volume fraction field for a cylinder of
    constant radius. */
    
    /**
    We then use this to define the initial jet and its velocity. */
    int it = 0;
    do {
        fraction (f0, sq(radius) - sq(y) - sq(z));
        foreach() {
            f[] = f0[]*(x < length);
            fs[] = sq(x - L0/2) + sq(y) < sq(Rsolid) ? 1 : 0;
            u.x[] = f[];
        }
        boundary ({f,u.x});
    }while (adapt_wavelet({f, fs}, (double []){0.001, 0.001}, maxlevel=maxlevel, minlevel=minlevel).nf != 0 && ++it <= 10);
  }
}

/**
## Outputs

We log some statistics on the solver. */

event logfile (i++) {
  if (i == 0)
    fprintf (ferr,
	     "t dt mgp.i mgpf.i mgu.i grid->tn perf.t perf.speed\n");
  fprintf (ferr, "%g %g %d %d %d %ld %g %g\n", 
	   t, dt, mgp.i, mgpf.i, mgu.i,
	   grid->tn, perf.t, perf.speed);
}
/**
We save snapshots of the simulation at regular intervals to
restart or to post-process with [bview](/src/bview). */

event snapshot (t = 0.1; t += 0.1; t <= 10.8) {
  char name[80];
  sprintf (name, "snapshot-%g", t);
  scalar pid[];
  foreach()
    pid[] = fmod(pid()*(npe() + 37), npe());
  boundary ({pid});
  dump (name);
}

/**
## Counting droplets

The number and sizes of droplets generated by the atomising jet is a
useful statistics for atomisation problems. This is not a quantity
which is trivial to compute. The *tag()* function is designed to solve
this problem. Any connected region for which *f[] > 1e-3* (i.e. a
droplet) will be identified by a unique "tag" value between 0 and
*n-1*. */

event droplets (t += 0.1)
{
  scalar m[];
  foreach()
    m[] = f[] > 1e-3;
  int n = tag (m);

  /**
  Once each cell is tagged with a unique droplet index, we can easily
  compute the volume *v* and position *b* of each droplet. Note that
  we use *foreach_leaf()* rather than *foreach()* to avoid doing a
  parallel traversal when using OpenMP. This is because we don't have
  reduction operations for the *v* and *b* arrays (yet). */

  double v[n];
  coord b[n];
  for (int j = 0; j < n; j++)
    v[j] = b[j].x = b[j].y = b[j].z = 0.;
  foreach_leaf()
    if (m[] > 0) {
      int j = m[] - 1;
      v[j] += dv()*f[];
      coord p = {x,y,z};
      foreach_dimension()
	b[j].x += dv()*f[]*p.x;
    }

 /**
 When using MPI we need to perform a global reduction to get the
 volumes and positions of droplets which span multiple processes. */

#if _MPI
  MPI_Allreduce (MPI_IN_PLACE, v, n, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
  MPI_Allreduce (MPI_IN_PLACE, b, 3*n, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
#endif

  /**
  Finally we output the volume and position of each droplet to
  standard output. */

  for (int j = 0; j < n; j++)
    fprintf (fout, "%d %g %d %g %g %g\n", i, t,
	     j, v[j], b[j].x/v[j], b[j].y/v[j]);
  fflush (fout);
}
  
/**
## Mesh adaptation

We adapt the mesh according to the error on the volume fraction fields of liquid and solid f, fs
and the velocity $\mathbf{u}$. */

event adapt (i++) {
  adapt_wavelet ({f, fs, u}, (double[]){0.01, 0.01, uemax, uemax, uemax}, maxlevel=maxlevel, minlevel=minlevel);
}

//Output
event vtk_file (t += 0.01){
    char subname[80]; sprintf(subname, "atom");
    scalar l[];
    vorticity (u, omega);
    foreach() {l[] = level; omega[] *= 1 - fs[];}
    output_vtu_MPI( (scalar *) {f, fs, rhov, omega, p, l}, (vector *) {u}, subname, 0);
}

/*
## Results

![Atomisation of a pulsed liquid jet. 4096^2^ equivalent
 resolution.](link)(width="800" height="600")
Symmetry of the solution is violated because of sinusoidal pulsation of the jet.
It is seen that

- there is no penetration of liquid into the solid,

- velocity is equal 0 in solids

 ![Volume fraction](https://drive.google.com/uc?authuser=0&id=1xhnstbrB4JtEjLYF7Dm_BR0LZ-l85-28&export=download)
 ![Vorticity](https://drive.google.com/uc?authuser=0&id=1JDhJe_ICUXM_WUOTZ6pIGrsqPZZnsD8V&export=download)
 ![Grid](https://drive.google.com/uc?authuser=0&id=1UUjA_4z0a1D9jPmd-afjc8BzhGSg5zuY&export=download)
 ![Magnitute of velocity](https://drive.google.com/uc?authuser=0&id=1KA1EtiT1E_n46mos5UBVnQ2yzWg6nTHc&export=download)
 ![](https://drive.google.com/file/d/1weHONySfNJebPZR--LE_uDS_hVhiDOoo/view?usp=sharing)
## See also

* [Same example with Gerris](http://gerris.dalembert.upmc.fr/gerris/examples/examples/atomisation.html)
*/
